diff --git a/apps/server/src/auth/recipes/github/github-provider.config.ts b/apps/server/src/auth/recipes/github/github-provider.config.ts
index 860d1492..ae95dd77 100644
--- a/apps/server/src/auth/recipes/github/github-provider.config.ts
+++ b/apps/server/src/auth/recipes/github/github-provider.config.ts
@@ -8,6 +8,7 @@ export const githubProviderConfig = (configService: ConfigService) => {
         scope: [
           'read:user',
           'user:email',
+          'read:org',
           'repo',
           'write:repo_hook',
           'admin:repo_hook',
diff --git a/apps/server/src/contexts/github/infrastructure/controllers/github.controller.ts b/apps/server/src/contexts/github/infrastructure/controllers/github.controller.ts
index a3ac78f9..b3bed652 100644
--- a/apps/server/src/contexts/github/infrastructure/controllers/github.controller.ts
+++ b/apps/server/src/contexts/github/infrastructure/controllers/github.controller.ts
@@ -1,25 +1,25 @@
 import {
   Controller,
   Get,
-  UseGuards,
-  Inject,
-  HttpStatus,
   HttpException,
+  HttpStatus,
+  Inject,
+  UseGuards,
 } from '@nestjs/common';
 import {
-  ApiTags,
+  ApiCookieAuth,
   ApiOperation,
   ApiResponse,
-  ApiCookieAuth,
+  ApiTags,
 } from '@nestjs/swagger';
-import { GitHubOctokit } from '../decorators/github-octokit.decorator';
 import { Octokit } from '@octokit/rest';
-import { GithubAuthGuard } from '../guards/github-auth.guard';
-import { GithubRepoListInput } from '../repositories/inputs/github-repo-list.input';
 import {
   GITHUB_REPOSITORY_PORT,
   GithubRepositoryPort,
 } from '../../use-cases/ports/github-repository.port';
+import { GitHubOctokit } from '../decorators/github-octokit.decorator';
+import { GithubAuthGuard } from '../guards/github-auth.guard';
+import { GithubRepoListInput } from '../repositories/inputs/github-repo-list.input';
 
 @ApiTags('Github')
 @Controller('github')
@@ -69,4 +69,45 @@ export class GithubController {
     }
     return repos.value;
   }
+
+  @Get('orgs/repos')
+  @UseGuards(GithubAuthGuard)
+  @ApiOperation({
+    summary:
+      "Récupérer la liste des repository github des organisations de l'utilisateur courant",
+  })
+  @ApiCookieAuth('sAccessToken')
+  @ApiResponse({
+    status: 200,
+    description: 'List repository organisations retournée avec succès',
+    example: {
+      repositories: [
+        {
+          owner: 'OrganizationName',
+          title: 'SampleProject',
+          description: "Un projet d'example",
+          url: 'https://github.com/OrganizationName/SampleProject',
+        },
+      ],
+    },
+  })
+  @ApiResponse({
+    status: 404,
+    description: 'Erreur lors de la récupération des repositories',
+    example: {
+      message: 'Failed to fetch organization repositories.',
+      error: 'Not Found',
+      statusCode: 404,
+    },
+  })
+  async getOrganizationRepositories(
+    @GitHubOctokit() octokit: Octokit,
+  ): Promise<GithubRepoListInput[]> {
+    const repos =
+      await this.githubRepository.findRepositoriesOfOrganizations(octokit);
+    if (!repos.success) {
+      throw new HttpException(repos.error, HttpStatus.NOT_FOUND);
+    }
+    return repos.value;
+  }
 }
diff --git a/apps/server/src/contexts/github/infrastructure/repositories/github.repository.ts b/apps/server/src/contexts/github/infrastructure/repositories/github.repository.ts
index 5dda8e09..e36ff924 100644
--- a/apps/server/src/contexts/github/infrastructure/repositories/github.repository.ts
+++ b/apps/server/src/contexts/github/infrastructure/repositories/github.repository.ts
@@ -216,29 +216,15 @@ export class GithubRepository implements GithubRepositoryPort {
       const response = await octokit.rest.repos.listForAuthenticatedUser({
         visibility: 'public',
         per_page: 50,
+        affiliation: 'owner,organization_member',
         headers: {
           'X-GitHub-Api-Version': '2022-11-28',
         },
       });
 
-      // Récupérer les informations de l'utilisateur authentifié
-      const userResponse = await octokit.rest.users.getAuthenticated({
-        headers: {
-          'X-GitHub-Api-Version': '2022-11-28',
-        },
-      });
-      const authenticatedUser = userResponse.data.login;
-
-      // Filtrer pour ne garder que les repositories dont l'utilisateur est le propriétaire
-      const ownedRepositories = response.data.filter(
-        (repo) => repo.owner.login === authenticatedUser,
-      );
-
-      this.Logger.log(
-        `Found ${ownedRepositories.length} owned repositories out of ${response.data.length} total repositories`,
-      );
+      this.Logger.log(`Found ${response.data.length} matching repositories.`);
 
-      const repositories = ownedRepositories
+      const repositories = response.data
         .map((repo) => {
           const rep = toGithubRepositoryDto(repo);
           if (rep.success) {
@@ -300,6 +286,220 @@ export class GithubRepository implements GithubRepositoryPort {
     }
   }
 
+  async findRepositoriesOfOrganizations(
+    octokit: Octokit,
+  ): Promise<Result<GithubRepoListInput[], string>> {
+    try {
+      // Initialiser la liste des repositories d'organisations
+      const allOrgRepositories: GithubRepoListInput[] = [];
+
+      // Récupérer les informations de l'utilisateur pour vérifier les scopes
+      const userResponse = await octokit.rest.users.getAuthenticated({
+        headers: {
+          'X-GitHub-Api-Version': '2022-11-28',
+        },
+      });
+
+      this.Logger.log('Authenticated user:', userResponse.data.login);
+      this.Logger.log('User scopes:', userResponse.headers['x-oauth-scopes']);
+
+      // Récupérer les organisations de l'utilisateur authentifié
+      const orgsResponse = await octokit.rest.orgs.listForAuthenticatedUser({
+        headers: {
+          'X-GitHub-Api-Version': '2022-11-28',
+        },
+      });
+
+      this.Logger.log(`Found ${orgsResponse.data.length} organizations`);
+      this.Logger.log(
+        'Organizations:',
+        orgsResponse.data.map((org) => org.login),
+      );
+
+      // Test direct avec les organisations connues si aucune n'est trouvée
+      if (orgsResponse.data.length === 0) {
+        this.Logger.log(
+          'No organizations found via API, trying direct access...',
+        );
+        const knownOrgs = ['LeetGrindBot', 'opensource-together', 'y2-Corp'];
+
+        for (const orgName of knownOrgs) {
+          try {
+            const orgReposResponse = await octokit.rest.repos.listForOrg({
+              org: orgName,
+              type: 'all',
+              per_page: 50,
+              headers: {
+                'X-GitHub-Api-Version': '2022-11-28',
+              },
+            });
+
+            this.Logger.log(
+              `Direct access to ${orgName}: ${orgReposResponse.data.length} repositories`,
+            );
+
+            // Transformer les repositories de l'organisation
+            const orgRepositories = orgReposResponse.data
+              .map((repo) => {
+                const rep = toGithubRepositoryDto(repo);
+                if (rep.success) {
+                  return rep.value;
+                } else {
+                  this.Logger.error(
+                    'Failed to transform organization repository to DTO:',
+                    rep.error,
+                  );
+                  return undefined;
+                }
+              })
+              .filter((v) => v !== undefined)
+              .map((repo) => {
+                const rep = toGithubRepoListInput(repo);
+                if (rep.success) {
+                  return rep.value;
+                } else {
+                  this.Logger.error(
+                    'Failed to transform organization repository to list input:',
+                    rep.error,
+                  );
+                  return undefined;
+                }
+              })
+              .filter((v) => v !== undefined);
+
+            // Récupérer les README pour chaque repository de l'organisation
+            const orgRepositoriesWithReadme = await Promise.all(
+              orgRepositories.map(async (repo) => {
+                try {
+                  const readmeResult = await this.getRepositoryReadme(
+                    repo.owner,
+                    repo.title,
+                    octokit,
+                  );
+                  if (readmeResult.success) {
+                    return { ...repo, readme: readmeResult.value };
+                  } else {
+                    this.Logger.warn(
+                      `Failed to fetch README for ${repo.owner}/${repo.title}: ${readmeResult.error}`,
+                    );
+                    return repo;
+                  }
+                } catch (error) {
+                  this.Logger.error(
+                    `Error fetching README for ${repo.owner}/${repo.title}:`,
+                    error,
+                  );
+                  return repo;
+                }
+              }),
+            );
+
+            allOrgRepositories.push(...orgRepositoriesWithReadme);
+          } catch (error) {
+            this.Logger.error(`Direct access failed for ${orgName}:`, error);
+          }
+        }
+      }
+
+      // Récupérer les repositories de toutes les organisations
+      // Test direct avec les organisations connues si aucune n'est trouvée
+
+      for (const org of orgsResponse.data) {
+        try {
+          const orgReposResponse = await octokit.rest.repos.listForOrg({
+            org: org.login,
+            type: 'all', // Inclure public et privé pour le test
+            per_page: 50,
+            headers: {
+              'X-GitHub-Api-Version': '2022-11-28',
+            },
+          });
+
+          this.Logger.log(
+            `Found ${orgReposResponse.data.length} repositories in organization ${org.login}`,
+          );
+
+          // Transformer les repositories de l'organisation
+          const orgRepositories = orgReposResponse.data
+            .map((repo) => {
+              const rep = toGithubRepositoryDto(repo);
+              if (rep.success) {
+                return rep.value;
+              } else {
+                this.Logger.error(
+                  'Failed to transform organization repository to DTO:',
+                  rep.error,
+                );
+                return undefined;
+              }
+            })
+            .filter((v) => v !== undefined)
+            .map((repo) => {
+              const rep = toGithubRepoListInput(repo);
+              if (rep.success) {
+                return rep.value;
+              } else {
+                this.Logger.error(
+                  'Failed to transform organization repository to list input:',
+                  rep.error,
+                );
+                return undefined;
+              }
+            })
+            .filter((v) => v !== undefined);
+
+          // Récupérer les README pour chaque repository de l'organisation
+          const orgRepositoriesWithReadme = await Promise.all(
+            orgRepositories.map(async (repo) => {
+              try {
+                const readmeResult = await this.getRepositoryReadme(
+                  repo.owner,
+                  repo.title,
+                  octokit,
+                );
+                if (readmeResult.success) {
+                  return { ...repo, readme: readmeResult.value };
+                } else {
+                  this.Logger.warn(
+                    `Failed to fetch README for ${repo.owner}/${repo.title}: ${readmeResult.error}`,
+                  );
+                  return repo;
+                }
+              } catch (error) {
+                this.Logger.error(
+                  `Error fetching README for ${repo.owner}/${repo.title}:`,
+                  error,
+                );
+                return repo;
+              }
+            }),
+          );
+
+          allOrgRepositories.push(...orgRepositoriesWithReadme);
+        } catch (orgError) {
+          this.Logger.error(
+            `Error fetching repositories for organization ${org.login}:`,
+            orgError,
+          );
+          this.Logger.error(
+            `Error details for ${org.login}:`,
+            JSON.stringify(orgError, null, 2),
+          );
+          // Continuer avec les autres organisations même si une échoue
+        }
+      }
+
+      this.Logger.log(
+        `Total repositories from organizations: ${allOrgRepositories.length}`,
+      );
+
+      return Result.ok(allOrgRepositories);
+    } catch (e) {
+      this.Logger.error('error fetching organization repositories', e);
+      return Result.fail('Failed to fetch organization repositories');
+    }
+  }
+
   async getRepositoryReadme(
     owner: string,
     repo: string,
diff --git a/apps/server/src/contexts/github/use-cases/github.use-cases.ts b/apps/server/src/contexts/github/use-cases/github.use-cases.ts
index eabd66ee..15328e90 100644
--- a/apps/server/src/contexts/github/use-cases/github.use-cases.ts
+++ b/apps/server/src/contexts/github/use-cases/github.use-cases.ts
@@ -1,3 +1,7 @@
 import { githubCommandsContainer } from './commands/github.commands';
+import { githubQueriesContainer } from './queries/github.queries';
 
-export const githubUseCases = [...githubCommandsContainer];
+export const githubUseCases = [
+  ...githubCommandsContainer,
+  ...githubQueriesContainer,
+];
diff --git a/apps/server/src/contexts/github/use-cases/ports/github-repository.port.ts b/apps/server/src/contexts/github/use-cases/ports/github-repository.port.ts
index 0eca0abe..f25056cb 100644
--- a/apps/server/src/contexts/github/use-cases/ports/github-repository.port.ts
+++ b/apps/server/src/contexts/github/use-cases/ports/github-repository.port.ts
@@ -1,11 +1,11 @@
-import { GithubRepositoryDto } from '@/contexts/github/infrastructure/repositories/dto/github-repository.dto';
 import { GithubInvitationDto } from '@/contexts/github/infrastructure/repositories/dto/github-invitation.dto';
+import { GithubRepositoryDto } from '@/contexts/github/infrastructure/repositories/dto/github-repository.dto';
 // import { CreateGithubRepositoryInput } from '@/application/dto/inputs/create-github-repository-inputs.dto';
 import { InviteUserToRepoInput } from '@/contexts/github/infrastructure/repositories/inputs/invite-user-to-repo.inputs.dto';
+import { ContributionGraph } from '@/contexts/user/domain/github-stats.vo';
 import { Result } from '@/libs/result';
 import { Octokit } from '@octokit/rest';
 import { GithubRepoListInput } from '../../infrastructure/repositories/inputs/github-repo-list.input';
-import { ContributionGraph } from '@/contexts/user/domain/github-stats.vo';
 
 export type LastCommit = {
   sha: string;
@@ -75,6 +75,10 @@ export interface GithubRepositoryPort {
     octokit: Octokit,
   ): Promise<Result<GithubRepoListInput[], string>>;
 
+  findRepositoriesOfOrganizations(
+    octokit: Octokit,
+  ): Promise<Result<GithubRepoListInput[], string>>;
+
   // Nouvelles méthodes pour les statistiques utilisateur
   getUserTotalStars(octokit: Octokit): Promise<Result<number, string>>;
   getUserContributedRepos(octokit: Octokit): Promise<Result<number, string>>;
diff --git a/apps/server/src/contexts/github/use-cases/queries/find-organization-repositories.query.ts b/apps/server/src/contexts/github/use-cases/queries/find-organization-repositories.query.ts
new file mode 100644
index 00000000..517cae19
--- /dev/null
+++ b/apps/server/src/contexts/github/use-cases/queries/find-organization-repositories.query.ts
@@ -0,0 +1,29 @@
+import { Result } from '@/libs/result';
+import { Inject } from '@nestjs/common';
+import { IQuery, IQueryHandler, QueryHandler } from '@nestjs/cqrs';
+import { Octokit } from '@octokit/rest';
+import { GithubRepoListInput } from '../../infrastructure/repositories/inputs/github-repo-list.input';
+import {
+  GITHUB_REPOSITORY_PORT,
+  GithubRepositoryPort,
+} from '../ports/github-repository.port';
+
+export class FindOrganizationRepositoriesQuery implements IQuery {
+  constructor(public readonly octokit: Octokit) {}
+}
+
+@QueryHandler(FindOrganizationRepositoriesQuery)
+export class FindOrganizationRepositoriesQueryHandler
+  implements IQueryHandler<FindOrganizationRepositoriesQuery>
+{
+  constructor(
+    @Inject(GITHUB_REPOSITORY_PORT)
+    private readonly githubRepository: GithubRepositoryPort,
+  ) {}
+
+  async execute(
+    query: FindOrganizationRepositoriesQuery,
+  ): Promise<Result<GithubRepoListInput[], string>> {
+    return this.githubRepository.findRepositoriesOfOrganizations(query.octokit);
+  }
+}
diff --git a/apps/server/src/contexts/github/use-cases/queries/github.queries.ts b/apps/server/src/contexts/github/use-cases/queries/github.queries.ts
new file mode 100644
index 00000000..ea180b7f
--- /dev/null
+++ b/apps/server/src/contexts/github/use-cases/queries/github.queries.ts
@@ -0,0 +1,7 @@
+import { FindOrganizationRepositoriesQueryHandler } from './find-organization-repositories.query';
+import { FindUserGitHubCredentialsQueryHandler } from './find-user-github-credentials.query';
+
+export const githubQueriesContainer = [
+  FindUserGitHubCredentialsQueryHandler,
+  FindOrganizationRepositoriesQueryHandler,
+];
diff --git a/apps/server/src/contexts/project/infrastructure/repositories/prisma.project.repository.ts b/apps/server/src/contexts/project/infrastructure/repositories/prisma.project.repository.ts
index e5e3ac2d..049bcd78 100644
--- a/apps/server/src/contexts/project/infrastructure/repositories/prisma.project.repository.ts
+++ b/apps/server/src/contexts/project/infrastructure/repositories/prisma.project.repository.ts
@@ -1,13 +1,14 @@
-import { Injectable } from '@nestjs/common';
-import { ProjectRepositoryPort } from '@/contexts/project/use-cases/ports/project.repository.port';
-import { PrismaService } from '@/persistence/orm/prisma/services/prisma.service';
 import { Project } from '@/contexts/project/domain/project.entity';
+import { ProjectRepositoryPort } from '@/contexts/project/use-cases/ports/project.repository.port';
 import { Result } from '@/libs/result';
+import { PrismaService } from '@/persistence/orm/prisma/services/prisma.service';
+import { Injectable, Logger } from '@nestjs/common';
 import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
 import { PrismaProjectMapper } from './prisma.project.mapper';
 
 @Injectable()
 export class PrismaProjectRepository implements ProjectRepositoryPort {
+  private readonly logger = new Logger(PrismaProjectRepository.name);
   constructor(private readonly prisma: PrismaService) {}
 
   async create(project: Project): Promise<Result<Project, string>> {
@@ -61,6 +62,7 @@ export class PrismaProjectRepository implements ProjectRepositoryPort {
         }
       }
       // Catch any other errors that are not PrismaClientKnownRequestError
+      this.logger.error('Project creation error:', error);
       return Result.fail(`Unknown error during project creation`);
     }
   }
diff --git a/apps/server/src/contexts/project/use-cases/commands/create/create-project.command.ts b/apps/server/src/contexts/project/use-cases/commands/create/create-project.command.ts
index 57d61fa6..ba77a950 100644
--- a/apps/server/src/contexts/project/use-cases/commands/create/create-project.command.ts
+++ b/apps/server/src/contexts/project/use-cases/commands/create/create-project.command.ts
@@ -22,7 +22,7 @@ import {
 } from '@/contexts/techstack/use-cases/ports/techstack.repository.port';
 
 import { Result } from '@/libs/result';
-import { Inject } from '@nestjs/common';
+import { Inject, Logger } from '@nestjs/common';
 import { CommandHandler, ICommand, ICommandHandler } from '@nestjs/cqrs';
 import { Octokit } from '@octokit/rest';
 
@@ -56,6 +56,7 @@ export class CreateProjectCommand implements ICommand {
 export class CreateProjectCommandHandler
   implements ICommandHandler<CreateProjectCommand>
 {
+  private readonly logger = new Logger(CreateProjectCommandHandler.name);
   constructor(
     @Inject(PROJECT_REPOSITORY_PORT)
     private readonly projectRepo: ProjectRepositoryPort,
@@ -70,6 +71,11 @@ export class CreateProjectCommandHandler
   async execute(
     createProjectCommand: CreateProjectCommand,
   ): Promise<Result<Project, ProjectValidationErrors | string>> {
+    this.logger.log('CreateProjectCommand received:', {
+      method: createProjectCommand.props.method,
+      title: createProjectCommand.props.title,
+      externalLinks: createProjectCommand.props.externalLinks,
+    });
     // const errors: CreateProjectCommandErrors = {};
     const {
       ownerId,
@@ -163,7 +169,10 @@ export class CreateProjectCommandHandler
     const projectValidated = projectResult.value;
     //si valide alors on enregistre le projet dans la persistance
     let savedProject = await this.projectRepo.create(projectValidated);
-    if (!savedProject.success) return Result.fail('Unable to create project');
+    if (!savedProject.success) {
+      this.logger.error('Failed to save project:', savedProject.error);
+      return Result.fail('Unable to create project');
+    }
 
     switch (method) {
       //si le projet est valide alors on créer un github repository
@@ -178,6 +187,12 @@ export class CreateProjectCommandHandler
       //si le projet est créé depuis github, on ne fait rien de plus
       case 'github':
         savedProject = this.validateGithubProject(savedProject.value);
+        if (!savedProject.success) {
+          this.logger.error(
+            'GitHub project validation failed:',
+            savedProject.error,
+          );
+        }
         break;
       default:
         break;
diff --git a/apps/web/src/features/projects/forms/github/step-one.form.tsx b/apps/web/src/features/projects/forms/github/step-one.form.tsx
index d6be921a..a932c91c 100644
--- a/apps/web/src/features/projects/forms/github/step-one.form.tsx
+++ b/apps/web/src/features/projects/forms/github/step-one.form.tsx
@@ -2,7 +2,7 @@
 
 import { zodResolver } from "@hookform/resolvers/zod";
 import { useRouter } from "next/navigation";
-import React, { useRef, useState } from "react";
+import React, { useEffect, useRef, useState } from "react";
 import { useForm } from "react-hook-form";
 
 import { Button } from "@/shared/components/ui/button";
@@ -13,9 +13,19 @@ import {
   FormItem,
   FormMessage,
 } from "@/shared/components/ui/form";
+import {
+  Select,
+  SelectContent,
+  SelectItem,
+  SelectTrigger,
+  SelectValue,
+} from "@/shared/components/ui/select";
 
 import FormNavigationButtons from "../../components/stepper/stepper-navigation-buttons.component";
-import { useGithubRepos } from "../../hooks/use-projects.hook";
+import {
+  useGithubOrgRepos,
+  useGithubRepos,
+} from "../../hooks/use-projects.hook";
 import { useProjectCreateStore } from "../../stores/project-create.store";
 import { GithubRepoType } from "../../types/project.type";
 import {
@@ -26,7 +36,13 @@ import {
 export default function StepOneForm() {
   const router = useRouter();
   const { selectRepository, formData } = useProjectCreateStore();
-  const { data: githubRepos, isLoading } = useGithubRepos();
+  const { data: githubRepos, isLoading: isLoadingUserRepos } = useGithubRepos();
+  const { data: githubOrgRepos, isLoading: isLoadingOrgRepos } =
+    useGithubOrgRepos();
+  const [selectedRepoType, setSelectedRepoType] = useState<"user" | "org">(
+    "user"
+  );
+
   const form = useForm<SelectedRepoFormData>({
     resolver: zodResolver(selectedRepoSchema),
     defaultValues: {
@@ -44,6 +60,11 @@ export default function StepOneForm() {
 
   const selectedRepository = watch("selectedRepository");
 
+  // Reset selection when switching repository types
+  useEffect(() => {
+    setValue("selectedRepository", null);
+  }, [selectedRepoType, setValue]);
+
   // Scrollbar logic
   const scrollRef = useRef<HTMLDivElement>(null);
   const [scrollTop, setScrollTop] = useState(0);
@@ -52,7 +73,11 @@ export default function StepOneForm() {
   const [dragStartScroll, setDragStartScroll] = useState(0);
 
   const itemHeight = 64; // px
-  const totalCount = githubRepos?.length || 0;
+  const currentRepos =
+    selectedRepoType === "user" ? githubRepos : githubOrgRepos;
+  const isLoading =
+    selectedRepoType === "user" ? isLoadingUserRepos : isLoadingOrgRepos;
+  const totalCount = currentRepos?.length || 0;
   const totalHeight = itemHeight * totalCount;
   const visibleHeight = 320;
   const scrollbarHeight = Math.max(
@@ -111,6 +136,41 @@ export default function StepOneForm() {
   return (
     <Form {...form}>
       <form onSubmit={onSubmit} className="w-full">
+        {/* Repository Type Selector */}
+        <div className="mb-4 flex items-center justify-between">
+          <div className="flex items-center gap-2">
+            <Select
+              value={selectedRepoType}
+              onValueChange={(value) =>
+                setSelectedRepoType(value as "user" | "org")
+              }
+            >
+              <SelectTrigger className="w-[200px]">
+                <SelectValue placeholder="Sélectionner un compte" />
+              </SelectTrigger>
+              <SelectContent>
+                <SelectItem value="user">
+                  <div className="flex items-center gap-2">
+                    <span className="text-sm">Mes repositories</span>
+                  </div>
+                </SelectItem>
+                <SelectItem value="org">
+                  <div className="flex items-center gap-2">
+                    <span className="text-sm">Organisations</span>
+                  </div>
+                </SelectItem>
+              </SelectContent>
+            </Select>
+          </div>
+          {currentRepos && (
+            <span className="text-sm text-gray-600">
+              {currentRepos.length} repository
+              {currentRepos.length > 1 ? "s" : ""} trouvé
+              {currentRepos.length > 1 ? "s" : ""}
+            </span>
+          )}
+        </div>
+
         <FormField
           control={control}
           name="selectedRepository"
@@ -130,7 +190,7 @@ export default function StepOneForm() {
                       {isLoading ? (
                         <GithubRepoSkeleton />
                       ) : (
-                        githubRepos?.map((repo, idx) => (
+                        currentRepos?.map((repo, idx) => (
                           <div
                             key={idx}
                             className={`flex h-[64px] items-center justify-between px-6 transition-colors ${
diff --git a/apps/web/src/features/projects/hooks/use-projects.hook.ts b/apps/web/src/features/projects/hooks/use-projects.hook.ts
index 57a2dda2..24a601a3 100644
--- a/apps/web/src/features/projects/hooks/use-projects.hook.ts
+++ b/apps/web/src/features/projects/hooks/use-projects.hook.ts
@@ -7,6 +7,7 @@ import { getQueryClient } from "@/shared/lib/query-client";
 import {
   createProject,
   deleteProject,
+  getGithubOrgRepos,
   getGithubRepos,
   getProjectDetails,
   getProjects,
@@ -57,6 +58,18 @@ export function useGithubRepos() {
   });
 }
 
+/**
+ * Fetches the list of GitHub organization repositories for the authenticated user.
+ *
+ * @returns A React Query result containing the list of GitHub organization repositories.
+ */
+export function useGithubOrgRepos() {
+  return useQuery<GithubRepoType[]>({
+    queryKey: ["github-org-repos"],
+    queryFn: getGithubOrgRepos,
+  });
+}
+
 /**
  * Handles the creation of a new project.
  *
diff --git a/apps/web/src/features/projects/services/project.service.ts b/apps/web/src/features/projects/services/project.service.ts
index b7c52d6c..a70cd24e 100644
--- a/apps/web/src/features/projects/services/project.service.ts
+++ b/apps/web/src/features/projects/services/project.service.ts
@@ -113,6 +113,35 @@ export const getGithubRepos = async (): Promise<GithubRepoType[]> => {
   }
 };
 
+/**
+ * Fetch GitHub organization repositories for the authenticated user.
+ *
+ * @returns A promise that resolves to an array of GitHub organization repositories.
+ */
+export const getGithubOrgRepos = async (): Promise<GithubRepoType[]> => {
+  try {
+    const response = await fetch(`${API_BASE_URL}/github/orgs/repos`, {
+      method: "GET",
+      headers: {
+        "Content-Type": "application/json",
+      },
+      credentials: "include",
+    });
+
+    if (!response.ok) {
+      const errorData = await response.json();
+      throw new Error(
+        errorData.message || "Failed to fetch GitHub organization repositories"
+      );
+    }
+
+    return await response.json();
+  } catch (error) {
+    console.error("Error fetching GitHub organization repositories:", error);
+    throw error;
+  }
+};
+
 /**
  * Creates a new project with optional image upload.
  *
diff --git a/apps/web/src/features/projects/stores/project-create.store.ts b/apps/web/src/features/projects/stores/project-create.store.ts
index d24a2bff..ee7c1a0d 100644
--- a/apps/web/src/features/projects/stores/project-create.store.ts
+++ b/apps/web/src/features/projects/stores/project-create.store.ts
@@ -106,6 +106,12 @@ export const useProjectCreateStore = create<ProjectCreateStore>()(
               ...state.formData,
               selectedRepository: repo,
               readme: repo.readme || "",
+              externalLinks: [
+                ...state.formData.externalLinks.filter(
+                  (link) => link.type !== "github"
+                ),
+                { type: "github", url: repo.url },
+              ],
             },
           })),
 
diff --git a/apps/web/src/features/projects/views/stepper-views/github/step-one.view.tsx b/apps/web/src/features/projects/views/stepper-views/github/step-one.view.tsx
index 01aff46d..94c56913 100644
--- a/apps/web/src/features/projects/views/stepper-views/github/step-one.view.tsx
+++ b/apps/web/src/features/projects/views/stepper-views/github/step-one.view.tsx
@@ -8,7 +8,7 @@ export default function StepOneView() {
     <StepperWrapper currentStep={1} method="github">
       <StepperHeaderComponent
         title="Importer un repository Github"
-        description="Choisissez le repository Github que vous souhaitez importer."
+        description="Choisissez le repository Github public que vous souhaitez importer."
       />
       <StepOneForm />
     </StepperWrapper>
diff --git a/docs/y2/ost-331-github-organizations-repositories.md b/docs/y2/ost-331-github-organizations-repositories.md
new file mode 100644
index 00000000..0389f4f0
--- /dev/null
+++ b/docs/y2/ost-331-github-organizations-repositories.md
@@ -0,0 +1,201 @@
+# OST-331: Intégration des repositories d'organisations GitHub - OpenSource Together
+
+## Description
+
+Cette fonctionnalité permet de récupérer et gérer les repositories des organisations GitHub dont l'utilisateur est membre, en plus des repositories personnels déjà supportés.
+
+## Fonctionnalités ajoutées
+
+### 1. Récupération des repositories d'organisations
+
+- **Endpoint**: `GET /v1/github/orgs/repos`
+- **Authentification**: Requiert un token GitHub avec les scopes appropriés
+- **Fonctionnalités**:
+  - Récupération automatique des repositories publics
+  - Support des organisations multiples
+  - Récupération des README pour chaque repository
+  - Gestion d'erreurs robuste par organisation
+  - Fallback vers l'accès direct si l'API standard échoue
+
+### 2. Scopes GitHub requis
+
+Les tokens GitHub doivent maintenant inclure le scope `read:org` en plus des scopes existants :
+
+- `read:org` : Pour accéder aux organisations
+- `repo` : Pour les repositories privés
+- `user:email` : Pour les informations utilisateur
+- `read:user` : Pour les informations utilisateur
+
+## Procédure de création d'un repository depuis une organisation
+
+### 1. Prérequis
+
+- Être membre d'une organisation GitHub
+- Avoir les permissions appropriées dans l'organisation
+- Token GitHub avec les scopes requis
+
+### 2. Étapes de création
+
+#### Étape 1: Accéder à l'organisation
+
+1. Se connecter à GitHub
+2. Naviguer vers l'organisation cible
+3. Vérifier les permissions d'accès
+
+#### Étape 2: Créer le repository
+
+1. Dans l'organisation, cliquer sur "New repository"
+2. Remplir les informations :
+   - **Repository name**: Nom du projet
+   - **Description**: Description du projet
+   - **Visibility**: Public ou Private
+   - **Initialize**: Cocher "Add a README file"
+3. Cliquer sur "Create repository"
+
+#### Étape 3: Configurer le repository
+
+1. Ajouter un fichier `.gitignore` approprié
+2. Créer une structure de dossiers cohérente
+3. Documenter le projet dans le README
+
+### 3. Intégration avec OpenSource Together
+
+#### Étape 1: Synchronisation
+
+1. Se connecter à l'application OpenSource Together
+2. Aller dans la section "Mes Projets"
+3. Cliquer sur "Importer depuis GitHub"
+4. Sélectionner l'onglet "Organisations"
+5. Choisir le repository créé
+
+#### Étape 2: Configuration du projet
+
+1. Remplir les informations du projet :
+   - **Titre**: Nom du projet
+   - **Description**: Description détaillée
+   - **Technologies**: Stack technique utilisée
+   - **Objectifs**: Buts du projet
+2. Sauvegarder la configuration
+
+## Procédure de fetch des repositories d'organisations
+
+### 1. Via l'API REST
+
+```bash
+curl -X GET "http://localhost:4000/v1/github/orgs/repos" \
+  -H "Cookie: sAccessToken=your-github-token"
+```
+
+### 2. Réponse attendue
+
+```json
+[
+  {
+    "owner": "OrganizationName",
+    "title": "project-name",
+    "description": "Description du projet",
+    "url": "https://github.com/OrganizationName/project-name",
+    "readme": "# Project Name\n\nDescription du projet..."
+  }
+]
+```
+
+### 3. Gestion d'erreurs
+
+- **401 Unauthorized**: Token GitHub invalide ou expiré
+- **404 Not Found**: Erreur lors de la récupération
+- **500 Internal Server Error**: Erreur serveur
+
+## Architecture technique
+
+### Structure Clean Architecture
+
+```
+github/
+├── use-cases/
+│   ├── queries/
+│   │   └── find-organization-repositories.query.ts
+│   └── ports/
+│       └── github-repository.port.ts
+└── infrastructure/
+    ├── controllers/
+    │   └── github.controller.ts
+    └── repositories/
+        └── github.repository.ts
+```
+
+### Nouveaux composants
+
+1. **FindOrganizationRepositoriesQuery**: Query CQRS pour la récupération
+2. **GithubRepository.findRepositoriesOfOrganizations()**: Méthode de récupération
+3. **GithubController.getOrganizationRepositories()**: Endpoint REST
+
+## Tests et validation
+
+### Tests unitaires
+
+- Query handler pour la récupération des organisations
+- Repository pour la transformation des données
+- Contrôleur pour la gestion des erreurs
+
+### Tests d'intégration
+
+- End-to-end avec l'API GitHub
+- Validation des scopes et permissions
+- Gestion des erreurs réseau
+
+## Logs et monitoring
+
+### Informations loggées
+
+- Utilisateur authentifié et ses scopes
+- Organisations trouvées
+- Nombre de repositories par organisation
+- Erreurs spécifiques par organisation
+- Total des repositories récupérés
+
+### Exemple de logs
+
+```
+[GithubRepository] Authenticated user: username
+[GithubRepository] User scopes: read:org, repo, user:email
+[GithubRepository] Found 2 organizations
+[GithubRepository] Organization org1: 5 repositories
+[GithubRepository] Organization org2: 3 repositories
+[GithubRepository] Total repositories from organizations: 8
+```
+
+## Améliorations futures
+
+- [ ] Pagination pour les grandes organisations
+- [ ] Filtrage par type de repository
+- [ ] Cache intelligent pour les performances
+- [ ] Support des permissions spécifiques
+- [ ] Métriques d'utilisation
+
+## Migration et compatibilité
+
+### Changements breaking
+
+- Ajout du scope `read:org` requis pour les tokens GitHub
+- Nouveau endpoint `/v1/github/orgs/repos`
+
+### Compatibilité
+
+- Les repositories personnels continuent de fonctionner
+- L'API existante reste inchangée
+- Migration transparente pour les utilisateurs existants
+
+## Documentation utilisateur
+
+### Pour les développeurs
+
+- Guide d'intégration des organisations
+- Exemples de code pour l'API
+- Gestion des erreurs et debugging
+
+### Pour les utilisateurs finaux
+
+- Tutoriel de création de repository d'organisation
+- Guide d'import dans OpenSource Together
+- FAQ sur les permissions et scopes
