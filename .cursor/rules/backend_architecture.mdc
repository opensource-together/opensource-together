---
description: Ceci donnes une documentation de la clean architecture utilisÃ© et de sa logique. Elle met du contexte quand on parle de notre clean architecture et de comment integrer de nouvelles choses si necessaire
globs: 
alwaysApply: false
---
# ğŸ—ï¸ Architecture du Monorepo et Configuration Docker Compose

## Vue d'ensemble du Monorepo

Le projet est structurÃ© en monorepo pour faciliter la gestion des diffÃ©rentes applications et packages partagÃ©s. Cela permet une meilleure organisation, une gestion centralisÃ©e des dÃ©pendances, et une optimisation des builds.

## Services Principaux

### Base de DonnÃ©es MÃ©tier (PostgreSQL)
- **Port** : 5433  
- **Objectif** : Stockage des donnÃ©es principales de l'application

### Base de DonnÃ©es SuperTokens (PostgreSQL)
- **Port** : 5432  
- **Objectif** : Stockage des donnÃ©es d'authentification

### SuperTokens Core
- **Port** : 3567  
- **Objectif** : Service d'authentification

### Backend (NestJS)
- **Port** : 4000  
- **Objectif** : Serveur API

### Frontend (Next.js)
- **Port** : 3000  
- **Objectif** : Application web

## Configuration Docker Compose

- **Isolation des Services** : Chaque service est conteneurisÃ©, assurant une isolation complÃ¨te et une communication via un rÃ©seau Docker personnalisÃ©.  
- **Volumes** : Utilisation de volumes pour la persistance des donnÃ©es et le rechargement Ã  chaud des applications.  
- **VÃ©rifications de SantÃ©** : ImplÃ©mentation de vÃ©rifications de santÃ© pour garantir le bon dÃ©marrage et la disponibilitÃ© des services.  
- **DÃ©pendances** : Utilisation de `depends_on` pour assurer l'ordre de dÃ©marrage correct des services.

## Avantages de cette Configuration

- **DÃ©veloppement SimplifiÃ©** : Hot reload et gestion centralisÃ©e des dÃ©pendances.  
- **ScalabilitÃ©** : FacilitÃ© d'ajout de nouveaux services ou de mise Ã  jour des existants.  
- **Maintenance** : Structure claire et modulaire facilitant la maintenance et l'Ã©volution du projet.

---

# ğŸ§± Architecture de l'application server â€” Clean Architecture + CQRS avec NestJS

## ğŸ—ï¸ Vue d'ensemble

Le projet suit les principes de **Clean Architecture**, en sÃ©parant clairement les responsabilitÃ©s entre les couches :

- **PrÃ©sentation (Interface)** : gÃ¨re les entrÃ©es HTTP (contrÃ´leurs)  
- **Infrastructure** : fait le lien entre NestJS et l'application (via CQRS, ORM, etc.)  
- **Application** : contient la logique mÃ©tier sous forme de Use Cases, Ports et DTOs  
- **Domaine** : le cÅ“ur mÃ©tier pur, indÃ©pendant de toute technologie

Le pattern **CQRS (Command Query Responsibility Segregation)** est utilisÃ© pour sÃ©parer clairement :

- les **commands** (Ã©criture)  
- les **queries** (lecture)  

Chaque action utilisateur transite par cette structure, facilitant le dÃ©couplage, le test et l'Ã©volution.

## ğŸ›¡ï¸ Utilisation du pattern CQRS dans ce projet

Le pattern CQRS est utilisÃ© ici comme un outil de routage intelligent entre lâ€™infrastructure (NestJS) et la logique mÃ©tier (use cases). Il sert Ã  :

- Faciliter lâ€™injection de dÃ©pendances grÃ¢ce aux `CommandBus` et `QueryBus` de NestJS  
- Centraliser le wiring via des modules dÃ©diÃ©s (`user-cqrs.module.ts`, `cqrs-wiring.module.ts`)  
- Garantir une sÃ©paration stricte entre les couches **domain/application** et **infrastructure**  
- Maintenir les use cases indÃ©pendants du framework NestJS pour une **portabilitÃ©, testabilitÃ© et dÃ©couplage complet**

Cette approche assure que lâ€™application respecte les principes de Clean Architecture tout en bÃ©nÃ©ficiant des fonctionnalitÃ©s avancÃ©es de NestJS (injection, modules, dÃ©corateurs), sans en dÃ©pendre directement dans la logique mÃ©tier.

---

## ğŸ“ Structure des dossiers

### `src/application`

Contient la logique mÃ©tier applicative (use cases) et les abstractions nÃ©cessaires pour exÃ©cuter ces cas dâ€™usage.

- `dto/` : Data Transfer Objects pour la couche application (`XxxDtoInput`, `XxxDtoOutput`)  
- `ports/` : Interfaces (ex: `UserRepositoryPort`) que lâ€™infra doit implÃ©menter  
- `use-cases/` : Les cas dâ€™usage (ex: `create-user.usecase.ts`)  

### `src/domain`

Contient la reprÃ©sentation mÃ©tier pure, indÃ©pendante de NestJS ou de toute autre lib/framework. OrganisÃ© par entitÃ©.

- `email.vo.ts`, `username.vo.ts` â†’ Value Objects (`Email`, `Username`, etc.)  
- `user.entity.ts` â†’ EntitÃ©  
- `user.factory.ts` â†’ Fabrique pour crÃ©er lâ€™entitÃ© Ã  partir d'objets primitifs  

**âœ³ï¸ Convention de nommage VO :**  
- Fichier : `xxx.vo.ts`  
- Classe : `Email`, `Username`, etc. (pas besoin dâ€™ajouter "Vo" dans le nom de la classe)

### `src/infrastructures`

Cette couche contient les Ã©lÃ©ments techniques concrets :

- `auth/` : IntÃ©gration de lâ€™authentification (ex: Supertokens)  
- `cqrs/user/` :  
  - `commands/` et `queries/` : fichiers dÃ©clarant les objets `Command` / `Query`  
  - `use-case-handlers/` : Handlers qui interceptent les commandes et appellent le bon Use Case  
  - `user-cqrs.module.ts` : regroupe les handlers CQRS utilisateur  
- `repositories/` : ImplÃ©mentations concrÃ¨tes des ports (ex: Prisma)  
- `orm/` : Configuration ORM  

Un module central `cqrs-wiring.module.ts` permet de rassembler tous les handlers et de les injecter dans lâ€™app principale.

### `src/presentation`

Contient les contrÃ´leurs NestJS, responsables de recevoir les requÃªtes HTTP et dâ€™appeler les `CommandBus` / `QueryBus`.

- `user.controller.ts` : appel des Command ou Query selon la logique  
- `dto/` : DTO de requÃªte/rÃ©ponse (ex: `XxxDtoRequest`, `XxxDtoResponse`)  

> Les contrÃ´leurs ne contiennent **aucune logique mÃ©tier**, seulement lâ€™appel du bon use case et le formatage de la rÃ©ponse HTTP.

### `src/shared`

Contient tout ce qui est rÃ©utilisable globalement :

- `result.ts` : ImplÃ©mentation du **Result Pattern** pour Ã©viter les exceptions levÃ©es de maniÃ¨re incontrÃ´lÃ©e. Permet de retourner des succÃ¨s ou des erreurs de faÃ§on explicite et typÃ©e (`Result.ok()`, `Result.fail()`)

---

## ğŸ” Flux de traitement typique (commandes)

1. Le contrÃ´leur reÃ§oit une requÃªte HTTP  
2. Il utilise le `CommandBus` ou `QueryBus` pour dÃ©clencher lâ€™action  
3. Le handler CQRS intercepte la commande et appelle le Use Case  
4. Le Use Case applique la logique mÃ©tier et utilise les ports  
5. Lâ€™implÃ©mentation concrÃ¨te du port (infra) exÃ©cute lâ€™action (ex: via Prisma)  
6. Un objet `Result` est retournÃ© au contrÃ´leur, qui le transforme en rÃ©ponse HTTP