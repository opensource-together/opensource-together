---
description: Frontend Architecture & Development Guidelines for OpenSource Together
alwaysApply: true
---

This rule formalizes best practices and principles for working effectively with the OpenSource Together frontend, built with Next.js and a feature-based architecture with hybrid state management (TanStack Query + Zustand).

The goal is to ensure modularity, maintainability, scalability, and an optimal developer experience through clear separation of concerns and consistency in conventions.

ðŸš¨ CRITICAL INSTRUCTIONS FOR DEVELOPERS ðŸš¨

You MUST strictly follow these principles and rules. Violations will cause maintenance issues, bugs, and performance degradation.

## Feature-Based Architecture

- Each feature is an autonomous module under src/features/ containing views, components, hooks, services, store, validations, and types.
- Never mix multiple features inside one module.
- Features must not depend directly on each other; favor clear, decoupled APIs.
- The src/app/ folder contains only Next.js routing, with no business logic or UI.

## Code Organization & Structure

src/
â”œâ”€â”€ app/ # Next.js routing only (no business logic or UI)
â”œâ”€â”€ features/ # Autonomous business feature modules
â”‚ â””â”€â”€ feature-name/Â 
â”‚ â”œâ”€â”€ components/ # Stateless UI components
â”‚ â”œâ”€â”€ views/ # Feature-specific views/pages
â”‚ â”œâ”€â”€ forms/ # Feature-specific forms (React Hook Form components)
â”‚ â”œâ”€â”€ hooks/ # Business logic hooks
â”‚ â”œâ”€â”€ services/ # API communication and side-effects
â”‚ â”œâ”€â”€ stores/ # Zustand stores (UI/client state)
â”‚ â”œâ”€â”€ validations/ # Zod schemas for runtime validation
â”‚ â””â”€â”€ types/ # Feature-specific TypeScript types (.type.ts files)
â”œâ”€â”€ shared/ # Reusable components, hooks, lib, and stores (cross-feature)
â”‚ â”œâ”€â”€ components/
â”‚ â”œâ”€â”€ hooks/
â”‚ â”œâ”€â”€ lib/
â”‚ â”œâ”€â”€ stores/
â”‚ â””â”€â”€ types/ # Generic technical types (.type.ts files, e.g., Nullable<T>)
â”œâ”€â”€ config/ # Global app configuration (e.g., TanStack Query)
â”œâ”€â”€ styles/ # Global styles and Tailwind setup
â”œâ”€â”€ types/ # Global app-level types (e.g., User, ApiResponse, MiddlewareMeta)
â””â”€â”€ proxy.ts # Next.js proxy (e.g., auth routing logic)

## Hybrid State Management

- TanStack Query manages server state only (data fetching, caching, API sync).
- Zustand manages client state only (UI state, user preferences).
- Never duplicate data between server and client state.
- Business logic hooks in each feature must use TanStack Query or Zustand based on the state nature.

## Naming Conventions and File Structure

- Files use kebab-case.
- Precise suffixes per file role:
- .component.tsx â€” UI components
- .view.tsx â€” main pages/views exported by the feature
- .form.tsx â€” React Hook Form components with logic
- .hook.ts â€” business logic hooks (logic + state)
- .service.ts â€” API calls / communication services
- .store.ts â€” Zustand stores (UI state)
- .schema.ts â€” Zod schemas for runtime validation
- .type.ts â€” TypeScript types and interfaces
- .config.ts â€” configuration files
- TypeScript exports use PascalCase (interfaces/types) and camelCase for Zod schemas.

## Design & Development Principles

- Modularity: decoupled features, reusable components, custom hooks.
- Predictability: strict typing with TypeScript + Zod, unidirectional state flow.
- Performance: intelligent TanStack Query cache, optimistic updates, minimized re-renders.
- Maintainability: clear responsibility separation, isolated layers, easy testing, integrated debugging tools (TanStack DevTools, Sentry).
- Clear responsibilities:
- Views: UI composition and orchestration.
- Hooks: business logic and state management.
- Services: API calls and communication.
- Components: stateless, reusable UI pieces.

## Best Practices

- Never put business logic or API calls inside UI components.
- Always use business logic hooks to access state and services.
- Validate all incoming data with Zod before usage.
- Centralize TanStack Query configuration in config/query.config.ts.
- Favor full type safety by always defining and importing types from \*.type.ts.
- Never duplicate data between TanStack Query and Zustand â€” synchronize via events or optimistic updates only.
- Use DevTools (TanStack Query DevTools, Zustand proxy) to debug and monitor state.

## Validation & Testing

- Validate API data with Zod in hooks/services.
- Unit test business logic hooks with mocks.
- Unit test UI components in isolation.
- Each feature must be independently testable and deployable.

## Consequences of Rule Violations

- Increased complexity, hard-to-maintain code.
- Bugs from inconsistent or duplicated state.
- Difficulty scaling and integrating new features.
- Performance issues and poor user experience.
- Ineffective tests and harder debugging.
