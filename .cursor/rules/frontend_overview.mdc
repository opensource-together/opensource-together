---
description: Frontend rules for OpenSource Together
globs: apps/web/**/*
alwaysApply: false
---
Project Rule: Frontend Architecture & Development Guidelines for OpenSource Together

Overview

This rule formalizes best practices and principles for working effectively with the OpenSource Together frontend, built with Next.js and a feature-based architecture with hybrid state management (TanStack Query + Zustand).

The goal is to ensure modularity, maintainability, scalability, and an optimal developer experience through clear separation of concerns and consistency in conventions.

ðŸš¨ CRITICAL INSTRUCTIONS FOR DEVELOPERS ðŸš¨

You MUST strictly follow these principles and rules. Violations will cause maintenance issues, bugs, and performance degradation.

â¸»

1. Feature-Based Architecture
   â€¢ Each feature is an autonomous module under src/features/ containing views, components, hooks, services, store, validations, and types.
   â€¢ Never mix multiple features inside one module.
   â€¢ Features must not depend directly on each other; favor clear, decoupled APIs.
   â€¢ The src/app/ folder contains only Next.js routing, with no business logic or UI.

â¸»

2. Code Organization & Structure

src/
â”œâ”€â”€ app/            # Next.js routing only (no business logic or UI)
â”œâ”€â”€ features/       # Autonomous business feature modules
â”‚   â””â”€â”€ feature-name/
â”‚       â”œâ”€â”€ components/    # Stateless UI components
â”‚       â”œâ”€â”€ views/         # Feature-specific views/pages
â”‚       â”œâ”€â”€ hooks/         # Business logic hooks
â”‚       â”œâ”€â”€ services/      # API communication and side-effects
â”‚       â”œâ”€â”€ store/         # Zustand stores (UI/client state)
â”‚       â”œâ”€â”€ validations/   # Zod schemas for runtime validation
â”‚       â””â”€â”€ types/         # Feature-specific TypeScript types (.type.ts files)
â”œâ”€â”€ shared/         # Reusable components, hooks, lib, and stores (cross-feature)
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ stores/
â”‚   â””â”€â”€ types/       # Generic technical types (.type.ts files, e.g., Nullable<T>)
â”œâ”€â”€ config/          # Global app configuration (e.g., TanStack Query)
â”œâ”€â”€ styles/          # Global styles and Tailwind setup
â”œâ”€â”€ types/           # Global app-level types (e.g., User, ApiResponse, MiddlewareMeta)
â””â”€â”€ middleware.ts    # Next.js middleware (e.g., auth routing logic)

â¸»

3. Hybrid State Management
   â€¢ TanStack Query manages server state only (data fetching, caching, API sync).
   â€¢ Zustand manages client state only (UI state, user preferences).
   â€¢ Never duplicate data between server and client state.
   â€¢ Business logic hooks in each feature must use TanStack Query or Zustand based on the state nature.

â¸»


4. Naming Conventions and File Structure
   â€¢ Files use kebab-case.
   â€¢ Precise suffixes per file role:
   â€¢ .component.tsx â€” UI components
   â€¢ .view.tsx â€” main pages/views exported by the feature
   â€¢ .hook.ts â€” business logic hooks (logic + state)
   â€¢ .service.ts â€” API calls / communication services
   â€¢ .store.ts â€” Zustand stores (UI state)
   â€¢ .schema.ts â€” Zod schemas for runtime validation
   â€¢ .type.ts â€” TypeScript types and interfaces
   â€¢ .config.ts â€” configuration files
   â€¢ TypeScript exports use PascalCase (interfaces/types) and camelCase for Zod schemas.

â¸»

5. Design & Development Principles
   â€¢ Modularity: decoupled features, reusable components, custom hooks.
   â€¢ Predictability: strict typing with TypeScript + Zod, unidirectional state flow.
   â€¢ Performance: intelligent TanStack Query cache, optimistic updates, minimized re-renders.
   â€¢ Maintainability: clear responsibility separation, isolated layers, easy testing, integrated debugging tools (TanStack DevTools, Sentry).
   â€¢ Clear responsibilities:
   â€¢ Views: UI composition and orchestration.
   â€¢ Hooks: business logic and state management.
   â€¢ Services: API calls and communication.
   â€¢ Components: stateless, reusable UI pieces.

â¸»

6. Best Practices
   â€¢ Never put business logic or API calls inside UI components.
   â€¢ Always use business logic hooks to access state and services.
   â€¢ Validate all incoming data with Zod before usage.
   â€¢ Centralize TanStack Query configuration in config/query.config.ts.
   â€¢ Favor full type safety by always defining and importing types from \*.type.ts.
   â€¢ Never duplicate data between TanStack Query and Zustand â€” synchronize via events or optimistic updates only.
   â€¢ Use DevTools (TanStack Query DevTools, Zustand middleware) to debug and monitor state.

â¸»

7. Validation & Testing
   â€¢ Validate API data with Zod in hooks/services.
   â€¢ Unit test business logic hooks with mocks.
   â€¢ Unit test UI components in isolation.
   â€¢ Each feature must be independently testable and deployable.

â¸»

8. Import Organization (via Prettier)

"importOrder": [
  "<THIRD_PARTY_MODULES>",
  "^@/config/(.*)$",
  "^@/types/(.*)$",
  "^@/shared/(.*)$",
  "^@/shared/components/(.*)$",
  "^@/shared/hooks/(.*)$",
  "^@/shared/lib/(.*)$",
  "^@/shared/stores/(.*)$",
  "^@/shared/types/(.*)$",
  "^@/features/(.*)$",
  "^@/app/(.*)$",
  "^[./]"
]

"importOrderSeparation": true,
"importOrderSortSpecifiers": true

â¸»

9. Consequences of Rule Violations
   â€¢ Increased complexity, hard-to-maintain code.
   â€¢ Bugs from inconsistent or duplicated state.
   â€¢ Difficulty scaling and integrating new features.
   â€¢ Performance issues and poor user experience.
   â€¢ Ineffective tests and harder debugging.

â¸»