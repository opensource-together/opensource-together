---
description: Ceci est un guide permettant de savoir comment implementer un systeme qui fonctionnera a l'aide de websocket.
alwaysApply: false
---

# üöÄ R√®gle WebSocket : Architecture et Conventions

## üìñ Vue d'ensemble

R√®gle pour cr√©er des syst√®mes WebSocket temps r√©el (notifications, messagerie, chat) dans l'architecture clean du projet avec EventEmitter et authentification JWT.

## üèóÔ∏è Architecture

### Flux Event-Driven

```
Action ‚Üí Command Handler ‚Üí EventEmitter.emit() ‚Üí @OnEvent Listener ‚Üí Notification Command ‚Üí Service ‚Üí WebSocket Gateway ‚Üí Client
```

### Couches

- **Domain** : Entit√©s m√©tier avec validation
- **Use Cases** : Commands/Queries CQRS + Ports (interfaces)
- **Infrastructure** : Controllers REST, Gateway WebSocket, Services, Listeners

## üìÅ Structure des Fichiers

```
src/contexts/[votre-contexte]/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ [entity].entity.ts                 # Entit√©s avec validation m√©tier
‚îú‚îÄ‚îÄ use-cases/
‚îÇ   ‚îú‚îÄ‚îÄ commands/create-[entity].command.ts # Commands CQRS
‚îÇ   ‚îú‚îÄ‚îÄ queries/get-[entities].query.ts     # Queries CQRS
‚îÇ   ‚îî‚îÄ‚îÄ ports/
‚îÇ       ‚îú‚îÄ‚îÄ [entity].service.port.ts        # Interface service
‚îÇ       ‚îî‚îÄ‚îÄ [entity].gateway.port.ts        # Interface gateway
‚îî‚îÄ‚îÄ infrastructure/
    ‚îú‚îÄ‚îÄ controllers/[entity].controller.ts  # REST API
    ‚îú‚îÄ‚îÄ gateways/
    ‚îÇ   ‚îú‚îÄ‚îÄ [entity].gateway.ts             # WebSocket Gateway
    ‚îÇ   ‚îî‚îÄ‚îÄ websocket-connection.manager.ts # Gestion connexions
    ‚îú‚îÄ‚îÄ listeners/[entity].listener.ts      # Event Listeners (@OnEvent)
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îú‚îÄ‚îÄ [entity].service.ts             # Service m√©tier
    ‚îÇ   ‚îî‚îÄ‚îÄ realtime-notifier.adapter.ts    # Adapter WebSocket
    ‚îî‚îÄ‚îÄ [entity].infrastructure.ts          # Module NestJS
```

## üéØ √âtapes d'Impl√©mentation

### 1. Entit√© Domain

```typescript
export class Notification {
  private constructor(props: NotificationData) {
    /* ... */
  }

  public static create(props: CreateProps): Result<Notification, string> {
    const validation = this.validate(props);
    if (!validation.success) return Result.fail(validation.error);
    return Result.ok(new Notification(props));
  }

  public static reconstitute(
    props: NotificationData
  ): Result<Notification, string> {
    return Result.ok(new Notification(props));
  }
}
```

### 2. Ports (Interfaces)

```typescript
export interface NotificationServicePort {
  sendNotification(
    notification: SendNotificationPayload
  ): Promise<Result<void, string>>;
  getUnreadNotifications(
    userId: string
  ): Promise<Result<NotificationData[], string>>;
}

export interface NotificationGatewayPort {
  sendNotificationToUser(
    notification: NotificationData
  ): Promise<string | null>;
}

export const NOTIFICATION_SERVICE_PORT = Symbol("NOTIFICATION_SERVICE_PORT");
```

### 3. Commands/Queries CQRS

```typescript
@CommandHandler(CreateNotificationCommand)
export class CreateNotificationCommandHandler {
  constructor(
    @Inject(NOTIFICATION_SERVICE_PORT)
    private readonly notificationService: NotificationServicePort
  ) {}

  async execute(
    command: CreateNotificationCommand
  ): Promise<Result<void, string>> {
    // 1. Validation avec entit√© domain
    const notificationResult = Notification.create(command.payload);
    if (!notificationResult.success)
      return Result.fail(notificationResult.error);

    // 2. D√©l√©guer au service
    return await this.notificationService.sendNotification(command.payload);
  }
}
```

### 4. Service Infrastructure

```typescript
@Injectable()
export class NotificationService implements NotificationServicePort {
  constructor(
    private readonly prisma: PrismaService,
    private readonly realtimeAdapter: RealtimeNotifierAdapter
  ) {}

  async sendNotification(notification: SendNotificationPayload): Promise<Result<void, string>> {
    // 1. Persister en DB
    const saved = await this.prisma.notification.create({...});

    // 2. Envoyer via WebSocket si canal realtime
    if (notification.channels?.includes("realtime")) {
      await this.realtimeAdapter.send(notificationData);
    }

    return Result.ok();
  }
}
```

### 5. Gateway WebSocket

```typescript
@WebSocketGateway({
  cors: { credentials: true, origin: "*" },
  namespace: "notifications",
})
export class NotificationsGateway implements NotificationGatewayPort {
  constructor(
    private readonly webSocketAuthService: WebSocketAuthService,
    private readonly connectionManager: WebSocketConnectionManager
  ) {}

  async handleConnection(client: AuthenticatedSocket): Promise<void> {
    const userId = await this.webSocketAuthService.authenticateSocket(client);
    if (!userId) {
      client.disconnect();
      return;
    }

    this.connectionManager.registerConnection(userId, client);
    await this.sendUnreadNotifications(userId, client);
  }

  async sendNotificationToUser(
    notification: NotificationData
  ): Promise<string | null> {
    const userSocket = this.connectionManager.getUserSocket(
      notification.receiverId
    );
    if (!userSocket) return `User ${notification.receiverId} not connected`;

    userSocket.emit("new-notification", notification);
    return null;
  }
}
```

### 6. Event Listeners

```typescript
@Injectable()
export class ProjectNotificationsListener {
  constructor(private readonly commandBus: CommandBus) {}

  @OnEvent("project.created")
  async handleProjectCreated(event: ProjectCreatedEvent) {
    const command = new CreateNotificationCommand({
      object: "project.created",
      receiverId: event.ownerId,
      senderId: event.ownerId,
      type: "project.created",
      payload: {
        projectTitle: event.projectTitle,
        message: `Votre projet "${event.projectTitle}" a √©t√© cr√©√© avec succ√®s !`,
      },
      channels: ["realtime"],
    });

    await this.commandBus.execute(command);
  }
}
```

### 7. √âmission d'√âv√©nements

```typescript
@CommandHandler(CreateProjectCommand)
export class CreateProjectCommandHandler {
  constructor(
    @Inject(EventEmitter2)
    private readonly eventEmitter: EventEmitter2
  ) {}

  async execute(
    command: CreateProjectCommand
  ): Promise<Result<Project, string>> {
    // 1. Logique m√©tier + sauvegarde
    const savedProject = await this.projectRepo.create(projectResult.value);

    // 2. √âmettre √©v√©nement pour d√©clencher notifications
    this.eventEmitter.emit("project.created", {
      projectId: savedProject.value.toPrimitive().id,
      projectTitle: savedProject.value.toPrimitive().title,
      ownerId: command.props.ownerId,
    });

    return Result.ok(savedProject.value);
  }
}
```

### 8. Module Configuration

```typescript
@Module({
  imports: [CqrsModule, PersistenceInfrastructure],
  providers: [
    ...notificationUseCases, // Commands & Queries handlers
    { provide: NOTIFICATION_SERVICE_PORT, useClass: NotificationService },
    { provide: NOTIFICATION_GATEWAY_PORT, useClass: NotificationsGateway },
    RealtimeNotifierAdapter,
    WebSocketConnectionManager,
    ProjectNotificationsListener,
  ],
  controllers: [NotificationsController],
  exports: [NOTIFICATION_SERVICE_PORT, NOTIFICATION_GATEWAY_PORT],
})
export class NotificationInfrastructure {}
```

## üîÑ Patterns et Conventions

### √âv√©nements Recommand√©s

```typescript
// Format: "contexte.action" ou "contexte.resource.action"
"project.created";
"project.role.application.created";
"project.role.application.accepted";
"message.received";
"user.welcome";
```

### Authentification WebSocket

- Token JWT via query param `x-ws-token`
- Service `WebSocketAuthService.authenticateSocket()`
- Interface `AuthenticatedSocket` avec `userId`

### Gestion Connexions

- Une connexion par utilisateur (remplacement automatique)
- Synchronisation hors ligne : envoi notifications non lues √† la connexion
- Events: `unread-notifications`, `new-notification`, `notification-read`

### Structure Notification

```typescript
{
  id: string,
  object: string,         // Type d'objet notifi√©
  receiverId: string,     // Destinataire
  senderId: string,       // Exp√©diteur
  type: string,          // Type d'√©v√©nement
  payload: object,       // Donn√©es sp√©cifiques
  channels: string[],    // ["realtime", "email"]
  createdAt: Date,
  readAt: Date | null
}
```

## ‚úÖ Bonnes Pratiques

### √Ä Faire

- Validation stricte avec entit√©s domain
- Authentification JWT pour WebSocket
- Persistance AVANT envoi WebSocket
- Logs d√©taill√©s pour debugging
- Gestion d'erreurs avec Result<T, E>
- D√©couplage via √©v√©nements
- Tests des listeners individuellement

### √Ä √âviter

- Logique m√©tier dans Gateway
- Connexions non authentifi√©es
- Listeners synchrones lourds
- Couplage fort entre contextes
- Payload trop volumineux
- CORS trop permissif en production

## üß™ Test Frontend

```javascript
// 1. Token auth
const { wsToken } = await fetch("/notifications/ws-token").then((r) =>
  r.json()
);

// 2. Connexion
const socket = io("ws://localhost:4000/notifications", {
  query: { "x-ws-token": wsToken },
});

// 3. Events
socket.on("connect", () => console.log("‚úÖ Connect√©"));
socket.on("unread-notifications", (notifs) =>
  console.log("üì¨ Non lues:", notifs)
);
socket.on("new-notification", (notif) => console.log("üì© Nouvelle:", notif));
socket.on("notification-read", (notif) => console.log("üîÑ Lue:", notif));
```

## üöÄ Extensions

- Email adapter : `EmailNotifierAdapter`
- Push mobile : `PushNotifierAdapter`
- Pr√©f√©rences utilisateur : `NotificationPreferencesService`
- Retry automatique : `ReliableNotificationService`
- Groupage : `NotificationGroupingService`

# üöÄ R√®gle WebSocket : Architecture et Conventions

## üìñ Vue d'ensemble

R√®gle pour cr√©er des syst√®mes WebSocket temps r√©el (notifications, messagerie, chat) dans l'architecture clean du projet avec EventEmitter et authentification JWT.

## üèóÔ∏è Architecture

### Flux Event-Driven

```
Action ‚Üí Command Handler ‚Üí EventEmitter.emit() ‚Üí @OnEvent Listener ‚Üí Notification Command ‚Üí Service ‚Üí WebSocket Gateway ‚Üí Client
```

### Couches

- **Domain** : Entit√©s m√©tier avec validation
- **Use Cases** : Commands/Queries CQRS + Ports (interfaces)
- **Infrastructure** : Controllers REST, Gateway WebSocket, Services, Listeners

## üìÅ Structure des Fichiers

```
src/contexts/[votre-contexte]/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ [entity].entity.ts                 # Entit√©s avec validation m√©tier
‚îú‚îÄ‚îÄ use-cases/
‚îÇ   ‚îú‚îÄ‚îÄ commands/create-[entity].command.ts # Commands CQRS
‚îÇ   ‚îú‚îÄ‚îÄ queries/get-[entities].query.ts     # Queries CQRS
‚îÇ   ‚îî‚îÄ‚îÄ ports/
‚îÇ       ‚îú‚îÄ‚îÄ [entity].service.port.ts        # Interface service
‚îÇ       ‚îî‚îÄ‚îÄ [entity].gateway.port.ts        # Interface gateway
‚îî‚îÄ‚îÄ infrastructure/
    ‚îú‚îÄ‚îÄ controllers/[entity].controller.ts  # REST API
    ‚îú‚îÄ‚îÄ gateways/
    ‚îÇ   ‚îú‚îÄ‚îÄ [entity].gateway.ts             # WebSocket Gateway
    ‚îÇ   ‚îî‚îÄ‚îÄ websocket-connection.manager.ts # Gestion connexions
    ‚îú‚îÄ‚îÄ listeners/[entity].listener.ts      # Event Listeners (@OnEvent)
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îú‚îÄ‚îÄ [entity].service.ts             # Service m√©tier
    ‚îÇ   ‚îî‚îÄ‚îÄ realtime-notifier.adapter.ts    # Adapter WebSocket
    ‚îî‚îÄ‚îÄ [entity].infrastructure.ts          # Module NestJS
```

## üéØ √âtapes d'Impl√©mentation

### 1. Entit√© Domain

```typescript
export class Notification {
  private constructor(props: NotificationData) {
    /* ... */
  }

  public static create(props: CreateProps): Result<Notification, string> {
    const validation = this.validate(props);
    if (!validation.success) return Result.fail(validation.error);
    return Result.ok(new Notification(props));
  }

  public static reconstitute(
    props: NotificationData
  ): Result<Notification, string> {
    return Result.ok(new Notification(props));
  }
}
```

### 2. Ports (Interfaces)

```typescript
export interface NotificationServicePort {
  sendNotification(
    notification: SendNotificationPayload
  ): Promise<Result<void, string>>;
  getUnreadNotifications(
    userId: string
  ): Promise<Result<NotificationData[], string>>;
}

export interface NotificationGatewayPort {
  sendNotificationToUser(
    notification: NotificationData
  ): Promise<string | null>;
}

export const NOTIFICATION_SERVICE_PORT = Symbol("NOTIFICATION_SERVICE_PORT");
```

### 3. Commands/Queries CQRS

```typescript
@CommandHandler(CreateNotificationCommand)
export class CreateNotificationCommandHandler {
  constructor(
    @Inject(NOTIFICATION_SERVICE_PORT)
    private readonly notificationService: NotificationServicePort
  ) {}

  async execute(
    command: CreateNotificationCommand
  ): Promise<Result<void, string>> {
    // 1. Validation avec entit√© domain
    const notificationResult = Notification.create(command.payload);
    if (!notificationResult.success)
      return Result.fail(notificationResult.error);

    // 2. D√©l√©guer au service
    return await this.notificationService.sendNotification(command.payload);
  }
}
```

### 4. Service Infrastructure

```typescript
@Injectable()
export class NotificationService implements NotificationServicePort {
  constructor(
    private readonly prisma: PrismaService,
    private readonly realtimeAdapter: RealtimeNotifierAdapter
  ) {}

  async sendNotification(notification: SendNotificationPayload): Promise<Result<void, string>> {
    // 1. Persister en DB
    const saved = await this.prisma.notification.create({...});

    // 2. Envoyer via WebSocket si canal realtime
    if (notification.channels?.includes("realtime")) {
      await this.realtimeAdapter.send(notificationData);
    }

    return Result.ok();
  }
}
```

### 5. Gateway WebSocket

```typescript
@WebSocketGateway({
  cors: { credentials: true, origin: "*" },
  namespace: "notifications",
})
export class NotificationsGateway implements NotificationGatewayPort {
  constructor(
    private readonly webSocketAuthService: WebSocketAuthService,
    private readonly connectionManager: WebSocketConnectionManager
  ) {}

  async handleConnection(client: AuthenticatedSocket): Promise<void> {
    const userId = await this.webSocketAuthService.authenticateSocket(client);
    if (!userId) {
      client.disconnect();
      return;
    }

    this.connectionManager.registerConnection(userId, client);
    await this.sendUnreadNotifications(userId, client);
  }

  async sendNotificationToUser(
    notification: NotificationData
  ): Promise<string | null> {
    const userSocket = this.connectionManager.getUserSocket(
      notification.receiverId
    );
    if (!userSocket) return `User ${notification.receiverId} not connected`;

    userSocket.emit("new-notification", notification);
    return null;
  }
}
```

### 6. Event Listeners

```typescript
@Injectable()
export class ProjectNotificationsListener {
  constructor(private readonly commandBus: CommandBus) {}

  @OnEvent("project.created")
  async handleProjectCreated(event: ProjectCreatedEvent) {
    const command = new CreateNotificationCommand({
      object: "project.created",
      receiverId: event.ownerId,
      senderId: event.ownerId,
      type: "project.created",
      payload: {
        projectTitle: event.projectTitle,
        message: `Votre projet "${event.projectTitle}" a √©t√© cr√©√© avec succ√®s !`,
      },
      channels: ["realtime"],
    });

    await this.commandBus.execute(command);
  }
}
```

### 7. √âmission d'√âv√©nements

```typescript
@CommandHandler(CreateProjectCommand)
export class CreateProjectCommandHandler {
  constructor(
    @Inject(EventEmitter2)
    private readonly eventEmitter: EventEmitter2
  ) {}

  async execute(
    command: CreateProjectCommand
  ): Promise<Result<Project, string>> {
    // 1. Logique m√©tier + sauvegarde
    const savedProject = await this.projectRepo.create(projectResult.value);

    // 2. √âmettre √©v√©nement pour d√©clencher notifications
    this.eventEmitter.emit("project.created", {
      projectId: savedProject.value.toPrimitive().id,
      projectTitle: savedProject.value.toPrimitive().title,
      ownerId: command.props.ownerId,
    });

    return Result.ok(savedProject.value);
  }
}
```

### 8. Module Configuration

```typescript
@Module({
  imports: [CqrsModule, PersistenceInfrastructure],
  providers: [
    ...notificationUseCases, // Commands & Queries handlers
    { provide: NOTIFICATION_SERVICE_PORT, useClass: NotificationService },
    { provide: NOTIFICATION_GATEWAY_PORT, useClass: NotificationsGateway },
    RealtimeNotifierAdapter,
    WebSocketConnectionManager,
    ProjectNotificationsListener,
  ],
  controllers: [NotificationsController],
  exports: [NOTIFICATION_SERVICE_PORT, NOTIFICATION_GATEWAY_PORT],
})
export class NotificationInfrastructure {}
```

## üîÑ Patterns et Conventions

### √âv√©nements Recommand√©s

```typescript
// Format: "contexte.action" ou "contexte.resource.action"
"project.created";
"project.role.application.created";
"project.role.application.accepted";
"message.received";
"user.welcome";
```

### Authentification WebSocket

- Token JWT via query param `x-ws-token`
- Service `WebSocketAuthService.authenticateSocket()`
- Interface `AuthenticatedSocket` avec `userId`

### Gestion Connexions

- Une connexion par utilisateur (remplacement automatique)
- Synchronisation hors ligne : envoi notifications non lues √† la connexion
- Events: `unread-notifications`, `new-notification`, `notification-read`

### Structure Notification

```typescript
{
  id: string,
  object: string,         // Type d'objet notifi√©
  receiverId: string,     // Destinataire
  senderId: string,       // Exp√©diteur
  type: string,          // Type d'√©v√©nement
  payload: object,       // Donn√©es sp√©cifiques
  channels: string[],    // ["realtime", "email"]
  createdAt: Date,
  readAt: Date | null
}
```

## ‚úÖ Bonnes Pratiques

### √Ä Faire

- Validation stricte avec entit√©s domain
- Authentification JWT pour WebSocket
- Persistance AVANT envoi WebSocket
- Logs d√©taill√©s pour debugging
- Gestion d'erreurs avec Result<T, E>
- D√©couplage via √©v√©nements
- Tests des listeners individuellement

### √Ä √âviter

- Logique m√©tier dans Gateway
- Connexions non authentifi√©es
- Listeners synchrones lourds
- Couplage fort entre contextes
- Payload trop volumineux
- CORS trop permissif en production

## üß™ Test Frontend

```javascript
// 1. Token auth
const { wsToken } = await fetch("/notifications/ws-token").then((r) =>
  r.json()
);

// 2. Connexion
const socket = io("ws://localhost:4000/notifications", {
  query: { "x-ws-token": wsToken },
});

// 3. Events
socket.on("connect", () => console.log("‚úÖ Connect√©"));
socket.on("unread-notifications", (notifs) =>
  console.log("üì¨ Non lues:", notifs)
);
socket.on("new-notification", (notif) => console.log("üì© Nouvelle:", notif));
socket.on("notification-read", (notif) => console.log("üîÑ Lue:", notif));
```

## üöÄ Extensions

- Email adapter : `EmailNotifierAdapter`
- Push mobile : `PushNotifierAdapter`
- Pr√©f√©rences utilisateur : `NotificationPreferencesService`
- Retry automatique : `ReliableNotificationService`
- Groupage : `NotificationGroupingService`
