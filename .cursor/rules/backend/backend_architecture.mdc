---
description: Ceci donnes une documentation de la clean architecture utilisÃ© et de sa logique. Elle met du contexte quand on parle de notre clean architecture et de comment integrer de nouvelles choses si necessaire
globs: 
alwaysApply: false
---
# ğŸ—ï¸ Architecture du Monorepo et Configuration Docker Compose

## Vue d'ensemble du Monorepo

Le projet est structurÃ© en monorepo pour faciliter la gestion des diffÃ©rentes applications et packages partagÃ©s. Cela permet une meilleure organisation, une gestion centralisÃ©e des dÃ©pendances, et une optimisation des builds.

## Services Principaux

### Base de DonnÃ©es MÃ©tier (PostgreSQL)

- **Port** : 5433
- **Objectif** : Stockage des donnÃ©es principales de l'application

### Base de DonnÃ©es SuperTokens (PostgreSQL)

- **Port** : 5432
- **Objectif** : Stockage des donnÃ©es d'authentification

### SuperTokens Core

- **Port** : 3567
- **Objectif** : Service d'authentification

### Backend (NestJS)

- **Port** : 4000
- **Objectif** : Serveur API

### Frontend (Next.js)

- **Port** : 3000
- **Objectif** : Application web

## Configuration Docker Compose

- **Isolation des Services** : Chaque service est conteneurisÃ©, assurant une isolation complÃ¨te et une communication via un rÃ©seau Docker personnalisÃ©.
- **Volumes** : Utilisation de volumes pour la persistance des donnÃ©es et le rechargement Ã  chaud des applications.
- **VÃ©rifications de SantÃ©** : ImplÃ©mentation de vÃ©rifications de santÃ© pour garantir le bon dÃ©marrage et la disponibilitÃ© des services.
- **DÃ©pendances** : Utilisation de `depends_on` pour assurer l'ordre de dÃ©marrage correct des services.

## Avantages de cette Configuration

- **DÃ©veloppement SimplifiÃ©** : Hot reload et gestion centralisÃ©e des dÃ©pendances.
- **ScalabilitÃ©** : FacilitÃ© d'ajout de nouveaux services ou de mise Ã  jour des existants.
- **Maintenance** : Structure claire et modulaire facilitant la maintenance et l'Ã©volution du projet.

---

# ğŸ§± Architecture Backend â€” Clean Architecture SimplifiÃ©e + CQRS avec NestJS

## ğŸ—ï¸ Vue d'ensemble

Le projet suit les principes de **Clean Architecture**, en sÃ©parant clairement les responsabilitÃ©s entre les couches :

- **Domain** : Le cÅ“ur mÃ©tier pur contenant les invariants mÃ©tier (entity, value object, factory)
- **Use Cases** : Contient la logique mÃ©tier applicative sous forme de Use Cases suivant le pattern CQRS
- **Infrastructure** : Contient tout ce qui est librairie externe, implÃ©mentation concrÃ¨te des ports/interfaces (ORM, API tiers, services, contrÃ´leurs)

Le pattern **CQRS (Command Query Responsibility Segregation)** est utilisÃ© pour sÃ©parer clairement :

- les **commands** (Ã©criture)
- les **queries** (lecture)

Chaque action utilisateur transite par cette structure, facilitant le dÃ©couplage, le test et l'Ã©volution.

---

## ğŸ“ Structure des dossiers (Nouvelle Organisation SimplifiÃ©e)

### Organisation gÃ©nÃ©rale

```
src/
â”œâ”€â”€ auth/                    # Service transversal d'authentification
â”œâ”€â”€ orm/                     # Configuration ORM (Prisma)
â”œâ”€â”€ libs/                    # Utilitaires partagÃ©s (ex: result.ts)
â”œâ”€â”€ examples/                # Templates pour nouveaux contextes
|
|___contexts/
|   |___
|       |
â”œ-----â”€â”€ user/                    # Contexte mÃ©tier
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ use-cases/
â”‚       â””â”€â”€ infrastructure/
â”œâ”€â”€------project/                 # Contexte mÃ©tier
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ use-cases/
â”‚       â””â”€â”€ infrastructure/
â”œâ”€â”€-----profile/                 # Contexte mÃ©tier
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ use-cases/
â”‚       â””â”€â”€ infrastructure/
â”œâ”€â”€-----project-role/            # Contexte mÃ©tier
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ use-cases/
â”‚       â””â”€â”€ infrastructure/
â”œâ”€â”€-----github/                  # Contexte mÃ©tier
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ use-cases/
â”‚       â””â”€â”€ infrastructure/
â”œâ”€â”€-----techstack/              # Contexte mÃ©tier
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ use-cases/
â”‚       â””â”€â”€ infrastructure/
â”œâ”€â”€-----encryption/             # Service transversal
â”‚       â”œâ”€â”€ infrastructure/
â”‚       â””â”€â”€ ports/
â”œâ”€â”€-----contexts.module.ts       # Module principal regroupant tous les contextes
â”œâ”€â”€ main.ts
â””â”€â”€ root.module.ts
```

### Avantages de cette nouvelle structure

- **Navigation simplifiÃ©e** : Chaque contexte regroupe ses 3 couches au mÃªme niveau
- **CohÃ©sion renforcÃ©e** : Toutes les prÃ©occupations d'un contexte sont proches gÃ©ographiquement
- **SÃ©paration claire** : `/auth` et `/orm` restent Ã  la racine car transversaux
- **Ã‰volutivitÃ©** : Facile d'ajouter de nouveaux contextes via le template `/examples`
- **Ã‰limination de la navigation complexe** : Plus besoin de naviguer entre `/contexts/<entity>/`, `/application/<entity>/`, `/presentation/<entity>/`

---

## ğŸ“ Structure dÃ©taillÃ©e par contexte

Chaque contexte mÃ©tier (user, project, profile, etc.) suit cette organisation :

### `src/<context_name>/domain/`

Contient la reprÃ©sentation mÃ©tier pure, indÃ©pendante de NestJS ou de toute autre lib/framework.

#### Structure du domaine :
```
domain/
â”œâ”€â”€ user.entity.ts
â”œâ”€â”€ user.entity.spec.ts      # Tests unitaires de l'entitÃ©
â”œâ”€â”€ username.vo.ts
â”œâ”€â”€ email.vo.ts
â””â”€â”€ user.factory.ts          # Optionnel selon le contexte
```

#### Exemple concret d'entitÃ© (User) :

```typescript
// user.entity.ts
import { Username } from './username.vo';
import { Email } from './email.vo';
import { Result } from '@libs/result';

export class User {
  private readonly id: string;
  private username: Username;
  private email: Email;
  private readonly createdAt?: Date;
  private readonly updatedAt?: Date;

  private constructor(props: {
    id: string;
    username: Username;
    email: Email;
    createdAt?: Date;
    updatedAt?: Date;
  }) {
    this.id = props.id;
    this.username = props.username;
    this.email = props.email;
    this.createdAt = props.createdAt ?? new Date();
    this.updatedAt = props.updatedAt ?? new Date();
  }

  public static create(props: {
    id: string;
    username: string;
    email: string;
  }): Result<User, { id?: string; username?: string; email?: string } | string> {
    const validateVO = this.validate(props);
    if (!validateVO.success) {
      return Result.fail(validateVO.error);
    }
    return Result.ok(
      new User({
        id: props.id,
        username: validateVO.value.username,
        email: validateVO.value.email,
      }),
    );
  }

  public static reconstitute(props: {
    id: string;
    username: string;
    email: string;
    createdAt: Date;
    updatedAt: Date;
  }): Result<User, { username?: string; email?: string } | string> {
    const validUser = this.validate(props);
    if (!validUser.success) {
      return Result.fail(validUser.error);
    }
    return Result.ok(
      new User({
        id: validUser.value.id,
        username: validUser.value.username,
        email: validUser.value.email,
        createdAt: props.createdAt,
        updatedAt: props.updatedAt,
      }),
    );
  }

  private static validate(props: {
    id: string;
    username: string;
    email: string;
  }): Result<
    { id: string; username: Username; email: Email },
    { id?: string; username?: string; email?: string } | string
  > {
    const error: { id?: string; username?: string; email?: string } = {};
    if (!props.id) error.id = 'User id is required';
    
    const usernameVo = Username.create(props.username);
    const emailVo = Email.create(props.email);
    
    if (!emailVo.success) error.email = emailVo.error;
    if (!usernameVo.success) error.username = usernameVo.error;
    if (!usernameVo.success || !emailVo.success) return Result.fail(error);
    
    return Result.ok({
      id: props.id,
      username: usernameVo.value,
      email: emailVo.value,
    });
  }

  public changeUsername(newUsername: string): Result<void, { username: string }> {
    const usernameVo = Username.create(newUsername);
    if (!usernameVo.success) return Result.fail({ username: usernameVo.error });
    this.username = usernameVo.value;
    return Result.ok(undefined);
  }

  public toPrimitive() {
    return {
      id: this.id,
      username: this.username.getUsername(),
      email: this.email.getEmail(),
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }
}
```

#### Exemple de Value Object :

```typescript
// username.vo.ts
import { Result } from '@libs/result';

export class Username {
  private constructor(private readonly value: string) {}

  public static create(value: string): Result<Username, string> {
    if (!value || value.trim() === '') {
      return Result.fail('Username is required');
    }
    if (value.length < 3) {
      return Result.fail('Username must be at least 3 characters');
    }
    if (value.length > 50) {
      return Result.fail('Username must be less than 50 characters');
    }
    return Result.ok(new Username(value.trim()));
  }

  public getUsername(): string {
    return this.value;
  }
}
```

#### Tests unitaires des entitÃ©s (TDD) :

```typescript
// user.entity.spec.ts
describe('Domain User Entity', () => {
  describe('create', () => {
    it('should create a user with valid properties', () => {
      const userResult = User.create({
        id: '123',
        username: 'johndoe',
        email: 'john@example.com'
      });
      
      expect(userResult.success).toBe(true);
      if (userResult.success) {
        expect(userResult.value).toBeInstanceOf(User);
      }
    });

    it.each([
      ['id', '', { id: 'User id is required' }],
      ['username', '', { username: 'Username is required' }],
      ['username', 'ab', { username: 'Username must be at least 3 characters' }],
      ['email', 'invalid-email', { email: 'Invalid email format' }],
    ])('should fail validation if %s is invalid', (field, value, expectedError) => {
      const props = { id: '123', username: 'johndoe', email: 'john@example.com' };
      props[field as keyof typeof props] = value as any;
      
      const userResult = User.create(props);
      expect(userResult.success).toBe(false);
      if (!userResult.success) {
        expect(userResult.error).toEqual(expectedError);
      }
    });
  });

  describe('reconstitute', () => {
    it('should reconstitute user from persistence', () => {
      const userResult = User.reconstitute({
        id: '123',
        username: 'johndoe',
        email: 'john@example.com',
        createdAt: new Date('2024-01-01'),
        updatedAt: new Date('2024-01-02'),
      });
      
      expect(userResult.success).toBe(true);
    });
  });
});
```

**âœ³ï¸ Convention de nommage VO :**

- Fichier : `xxx.vo.ts`
- Classe : `Email`, `Username`, etc. (pas de suffixe "Vo")

**âœ³ï¸ Principes des entitÃ©s :**

- **Constructeur privÃ©** : Force l'utilisation des mÃ©thodes statiques `create()` et `reconstitute()`
- **Validation centralisÃ©e** : Toute la logique de validation dans la mÃ©thode `validate()`
- **Result Pattern** : Retour explicite de succÃ¨s/Ã©chec avec erreurs typÃ©es
- **ImmutabilitÃ©** : PropriÃ©tÃ©s privates avec mÃ©thodes mÃ©tier pour les modifications
- **toPrimitive()** : MÃ©thode pour extraire l'Ã©tat pour la persistance ou les DTOs

### `src/<context_name>/use-cases/`

Contient la logique mÃ©tier applicative (use cases qui sont soit query, soit command) et les abstractions nÃ©cessaires pour exÃ©cuter ces cas d'usage (ports).

#### Structure des use-cases :

```
use-cases/
â”œâ”€â”€ commands/
â”‚   â”œâ”€â”€ create-user.command.ts
â”‚   â””â”€â”€ user.commands.ts
â”œâ”€â”€ queries/
â”‚   â”œâ”€â”€ find-user-by-id.query.ts
â”‚   â””â”€â”€ user.queries.ts
â”œâ”€â”€ ports/
â”‚   â””â”€â”€ user.repository.port.ts
â””â”€â”€ user.use-cases.ts
```

#### Exemple de Command :

```typescript
// create-user.command.ts
import { CommandHandler, ICommand, ICommandHandler } from '@nestjs/cqrs';
import { Inject } from '@nestjs/common';
import { Result } from '@libs/result';
import { USER_REPOSITORY_PORT, UserRepositoryPort } from '../ports/user.repository.port';

export class CreateUserCommand implements ICommand {
  constructor(
    public readonly username: string,
    public readonly email: string,
  ) {}
}

@CommandHandler(CreateUserCommand)
export class CreateUserCommandHandler implements ICommandHandler<CreateUserCommand> {
  constructor(
    @Inject(USER_REPOSITORY_PORT)
    private readonly userRepo: UserRepositoryPort,
  ) {}

  async execute(command: CreateUserCommand): Promise<Result<User, string>> {
    // logique mÃ©tier
  }
}
```

#### Exemple de Query :

```typescript
// find-user-by-id.query.ts
import { IQuery, IQueryHandler, QueryHandler } from "@nestjs/cqrs";
import { Inject } from "@nestjs/common";
import { USER_REPOSITORY_PORT, UserRepositoryPort } from "../ports/user.repository.port";

export class FindUserByIdQuery implements IQuery {
  constructor(public readonly id: string) {}
}

@QueryHandler(FindUserByIdQuery)
export class FindUserByIdQueryHandler implements IQueryHandler<FindUserByIdQuery> {
  constructor(
    @Inject(USER_REPOSITORY_PORT)
    private readonly userRepo: UserRepositoryPort,
  ) {}

  async execute(query: FindUserByIdQuery): Promise<Result<User, string>> {
    return this.userRepo.findById(query.id);
  }
}
```

#### Exemple de Port :

```typescript
// user.repository.port.ts
import { User } from "../domain/user.entity";
import { Result } from "@libs/result";

export const USER_REPOSITORY_PORT = Symbol("UserRepository");

export interface UserRepositoryPort {
  save(user: User): Promise<Result<User, string>>;
  findById(id: string): Promise<Result<User, string>>;
  findByUsername(username: string): Promise<Result<User, string>>;
  findByEmail(email: string): Promise<Result<User, string>>;
}
```

#### Container des Use Cases :

```typescript
// user.use-cases.ts
import { userQueriesContainer } from "./queries/user.queries";
import { userCommandsContainer } from "./commands/user.commands";

export const userUseCases = [
  ...userQueriesContainer,
  ...userCommandsContainer,
];
```

#### Tests des Use Cases (TDD) :

```typescript
// create-project.command.spec.ts
describe('CreateProjectCommandHandler', () => {
  let handler: CreateProjectCommandHandler;
  let projectRepo: ProjectRepositoryPort;
  let techStackRepo: TechStackRepositoryPort;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CreateProjectCommandHandler,
        {
          provide: PROJECT_REPOSITORY_PORT,
          useClass: InMemoryProjectRepository,
        },
        {
          provide: TECHSTACK_REPOSITORY_PORT,
          useClass: InMemoryTechStackRepository,
        },
      ],
    }).compile();

    handler = module.get<CreateProjectCommandHandler>(CreateProjectCommandHandler);
    projectRepo = module.get<ProjectRepositoryPort>(PROJECT_REPOSITORY_PORT);
    techStackRepo = module.get<TechStackRepositoryPort>(TECHSTACK_REPOSITORY_PORT);
  });

  describe('Success', () => {
    it('should create and save a project successfully', async () => {
      const props: ProjectPrimitive = {
        ownerId: '1',
        title: 'Test Project',
        description: 'Test Description',
        difficulty: 'easy',
        githubLink: 'https://github.com/test',
        techStacks: [
          { id: '1', name: 'react', iconUrl: 'https://reactjs.org/favicon.ico' }
        ],
        projectRoles: [
          { title: 'Developer', description: 'Frontend developer role' }
        ],
        projectMembers: [],
      };

      await setupTechStacksInMemory(techStackRepo);
      const command = new CreateProjectCommand(props);
      const result = await handler.execute(command);

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.value).toBeInstanceOf(Project);
      }
    });
  });

  describe('Failures', () => {
    it('should return error when tech stacks not found', async () => {
      const props = getProjectProps({
        techStacks: [
          { id: '999', name: 'nonexistent', iconUrl: 'https://test.com' }
        ],
      });

      const command = new CreateProjectCommand(props);
      const result = await handler.execute(command);

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBe('Tech stacks not found');
      }
    });

    it('should return error when project title already exists', async () => {
      // Arrange - Create existing project
      const existingProject = Project.create(getProjectProps({ title: 'Existing' }));
      await projectRepo.create(existingProject.value);

      // Act - Try to create project with same title
      const command = new CreateProjectCommand(getProjectProps({ title: 'Existing' }));
      const result = await handler.execute(command);

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBe('Project with this title already exists');
      }
    });
  });
});
```

**âœ³ï¸ Principes des tests TDD :**

- **Arrange-Act-Assert** : Structure claire des tests
- **Test paramÃ©trÃ©s** : `it.each()` pour tester plusieurs cas de validation
- **Mocks en mÃ©moire** : ImplÃ©mentations en mÃ©moire des repositories pour les tests
- **Setup/Teardown** : CrÃ©ation et nettoyage des donnÃ©es de test
- **Tests des Ã©checs** : Autant d'importance que les tests de succÃ¨s
- **Isolation** : Chaque test est indÃ©pendant

### `src/<context_name>/infrastructure/`

Contient les implÃ©mentations concrÃ¨tes et les contrÃ´leurs (anciennement dans `/presentation`).

```
infrastructure/
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ user.controller.ts
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ prisma.user.repository.ts
â””â”€â”€ user.infrastructure.ts
```

#### Exemple de ContrÃ´leur :

```typescript
// controllers/user.controller.ts
import { Controller, Post, Body, BadRequestException } from '@nestjs/common';
import { CommandBus, QueryBus } from '@nestjs/cqrs';
import { CreateUserCommand } from '../use-cases/commands/create-user.command';

@Controller('users')
export class UserController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Post()
  async createUser(@Body() dto: CreateUserDto) {
    const command = new CreateUserCommand(dto.username, dto.email);
    const result = await this.commandBus.execute(command);
    
    if (result.isFailure) {
      throw new BadRequestException(result.error);
    }
    
    return result.value;
  }
}
```

#### Module d'Infrastructure :

```typescript
// user.infrastructure.ts
import { Module } from '@nestjs/common';
import { userUseCases } from '../use-cases/user.use-cases';
import { UserController } from './controllers/user.controller';
import { PrismaUserRepository } from './repositories/prisma.user.repository';
import { USER_REPOSITORY_PORT } from '../use-cases/ports/user.repository.port';
import { PrismaService } from '@/orm/prisma/prisma.service';

@Module({
  imports: [],
  providers: [
    PrismaService,
    {
      provide: USER_REPOSITORY_PORT,
      useClass: PrismaUserRepository,
    },
    ...userUseCases,
  ],
  controllers: [UserController],
  exports: [...userUseCases],
})
export class UserInfrastructure {}
```

---

## ğŸ“ Services transversaux

### `src/auth/`

Service transversal d'authentification (SuperTokens) utilisÃ© par tous les contextes.

### `src/orm/`

Configuration ORM (Prisma) et migrations, utilisÃ© par tous les contextes.

### `src/libs/`

Contient tout ce qui est rÃ©utilisable globalement (anciennement `/shared`) :

- `result.ts` : ImplÃ©mentation du **Result Pattern**
- `test-utils.ts` : Utilitaires de test
- `time/` : Services de gestion du temps

### `src/examples/`

Template pour crÃ©er de nouveaux contextes en respectant les conventions :

```
examples/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ example.entity.ts
â”‚   â””â”€â”€ example.vo.ts
â”œâ”€â”€ use-cases/
â”‚   â”œâ”€â”€ commands/
â”‚   â”œâ”€â”€ queries/
â”‚   â”œâ”€â”€ ports/
â”‚   â””â”€â”€ example.use-cases.ts
â””â”€â”€ infrastructure/
    â”œâ”€â”€ controllers/
    â”œâ”€â”€ repositories/
    â””â”€â”€ example.infrastructure.ts
```

---

## ğŸ”— Module principal

### `src/contexts.module.ts`

Module principal qui remplace le systÃ¨me de wiring actuel et importe tous les contextes :

```typescript
// contexts.module.ts
import { Module } from '@nestjs/common';
import { UserInfrastructure } from './user/infrastructure/user.infrastructure';
import { ProjectInfrastructure } from './project/infrastructure/project.infrastructure';
import { ProfileInfrastructure } from './profile/infrastructure/profile.infrastructure';
import { ProjectRoleInfrastructure } from './project-role/infrastructure/project-role.infrastructure';
import { GithubInfrastructure } from './github/infrastructure/github.infrastructure';
import { TechStackInfrastructure } from './techstack/infrastructure/techstack.infrastructure';

@Module({
  imports: [
    UserInfrastructure,
    ProjectInfrastructure,
    ProfileInfrastructure,
    ProjectRoleInfrastructure,
    GithubInfrastructure,
    TechStackInfrastructure,
  ],
})
export class ContextsModule {}
```

---

## ğŸ” Flux de traitement typique

1. Le contrÃ´leur (dans `/infrastructure/controllers/`) reÃ§oit une requÃªte HTTP
2. Il utilise le `CommandBus` ou `QueryBus` pour dÃ©clencher l'action
3. Le handler CQRS (dans `/use-cases/`) intercepte la commande/query
4. Le Use Case applique la logique mÃ©tier et utilise les ports
5. L'implÃ©mentation concrÃ¨te du port (dans `/infrastructure/repositories/`) exÃ©cute l'action
6. Un objet `Result` est retournÃ© au contrÃ´leur, qui le transforme en rÃ©ponse HTTP

---

## ğŸ¯ Avantages de cette nouvelle architecture

- **Navigation simplifiÃ©e** : Toutes les prÃ©occupations d'un contexte sont regroupÃ©es
- **CohÃ©sion renforcÃ©e** : Les dÃ©veloppeurs peuvent travailler sur un contexte sans naviguer entre plusieurs dossiers Ã©loignÃ©s
- **MaintenabilitÃ©** : Ajout/suppression de contextes plus facile
- **Onboarding** : Plus facile pour de nouveaux dÃ©veloppeurs de comprendre la structure
- **Respect des principes** : Conservation de la Clean Architecture et du dÃ©couplage
- **Template** : Le dossier `/examples` facilite la crÃ©ation de nouveaux contextes en respectant les conventions

---

## ğŸ§ª Approche TDD (Test-Driven Development)

### StratÃ©gie de test par couche

#### 1. Tests unitaires du domaine
- **EntitÃ©s** : Validation des rÃ¨gles mÃ©tier, constructeurs, mÃ©thodes mÃ©tier
- **Value Objects** : Validation des contraintes, immutabilitÃ©
- **Factories** : Logique de crÃ©ation d'objets complexes

```typescript
// Exemple : project.entity.spec.ts
describe('Project Entity', () => {
  it.each([
    ['title', '', { title: 'Title is required' }],
    ['title', 'a'.repeat(101), { title: 'Title must be less than 100 characters' }],
    ['description', '', { description: 'Description is required' }],
    ['difficulty', undefined, { difficulty: 'Difficulty is required' }],
    ['techStacks', [], { techStacks: 'Tech stacks are required' }],
  ])('should fail validation if %s is invalid', (field, value, expectedError) => {
    const props = getValidProjectProps({ [field]: value });
    const result = Project.create(props);
    
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error).toEqual(expectedError);
    }
  });
});
```

#### 2. Tests d'intÃ©gration des Use Cases
- **Commands** : Logique mÃ©tier applicative, interactions avec les ports
- **Queries** : RÃ©cupÃ©ration de donnÃ©es, filtrage, pagination
- **Handlers** : Orchestration des appels, gestion d'erreurs

```typescript
// Exemple : create-project.command.spec.ts
describe('CreateProjectCommandHandler', () => {
  beforeEach(async () => {
    // Setup du module de test avec mocks
    const module = await Test.createTestingModule({
      providers: [
        CreateProjectCommandHandler,
        { provide: PROJECT_REPOSITORY_PORT, useClass: InMemoryProjectRepository },
        { provide: TECHSTACK_REPOSITORY_PORT, useClass: InMemoryTechStackRepository },
      ],
    }).compile();
  });
  
  it('should create project when all dependencies are valid', async () => {
    // Arrange
    await setupValidTechStacks();
    const command = new CreateProjectCommand(validProjectData);
    
    // Act
    const result = await handler.execute(command);
    
    // Assert
    expect(result.success).toBe(true);
    expect(result.value).toBeInstanceOf(Project);
  });
});
```

#### 3. Tests end-to-end des contrÃ´leurs
- **Endpoints** : RequÃªtes HTTP, validation des DTOs, rÃ©ponses
- **Authentification** : VÃ©rification des permissions, tokens
- **SÃ©rialisation** : Format des rÃ©ponses JSON

### Conventions et bonnes pratiques TDD

#### Nommage des tests
- **Describe** : Nom de la classe/mÃ©thode testÃ©e
- **It** : Comportement attendu en langage naturel
- **Contexte** : `describe('when user is not owner')` pour les contextes spÃ©cifiques

#### Structure AAA (Arrange-Act-Assert)
```typescript
it('should update project when user is owner', async () => {
  // Arrange - PrÃ©parer les donnÃ©es
  const existingProject = await createTestProject({ ownerId: 'user123' });
  const command = new UpdateProjectCommand({ 
    id: existingProject.id, 
    userId: 'user123',
    title: 'Updated Title' 
  });
  
  // Act - ExÃ©cuter l'action
  const result = await handler.execute(command);
  
  // Assert - VÃ©rifier le rÃ©sultat
  expect(result.success).toBe(true);
  if (result.success) {
    expect(result.value.toPrimitive().title).toBe('Updated Title');
  }
});
```

#### Helpers et builders de test
```typescript
// Builders pour crÃ©er des objets de test valides
const getValidProjectProps = (overrides = {}) => ({
  title: 'Default Project',
  description: 'Default description',
  difficulty: 'easy',
  ownerId: 'user123',
  techStacks: [{ id: '1', name: 'React', iconUrl: 'react.svg' }],
  projectRoles: [{ title: 'Developer', description: 'Dev role' }],
  ...overrides,
});

// Setup helpers pour les dÃ©pendances
const setupValidTechStacks = async () => {
  const techStack = TechStack.create({ name: 'React', iconUrl: 'react.svg' });
  await techStackRepo.create(techStack.value);
};
```

#### ImplÃ©mentations en mÃ©moire
```typescript
// InMemoryProjectRepository pour les tests
export class InMemoryProjectRepository implements ProjectRepositoryPort {
  private projects: Map<string, Project> = new Map();
  
  async create(project: Project): Promise<Result<Project, string>> {
    const id = crypto.randomUUID();
    const projectWithId = Project.reconstitute({
      ...project.toPrimitive(),
      id,
      createdAt: new Date(),
      updatedAt: new Date(),
    });
    
    if (projectWithId.success) {
      this.projects.set(id, projectWithId.value);
      return Result.ok(projectWithId.value);
    }
    
    return Result.fail('Failed to create project');
  }
  
  async findById(id: string): Promise<Result<Project, string>> {
    const project = this.projects.get(id);
    return project 
      ? Result.ok(project) 
      : Result.fail('Project not found');
  }
  
  // ... autres mÃ©thodes
}
```

### Outils de test utilisÃ©s

- **Jest** : Framework de test principal
- **@nestjs/testing** : Module de test pour NestJS avec injection de dÃ©pendances
- **Test paramÃ©trÃ©s** : `it.each()` pour Ã©viter la duplication de code
- **Mocks** : ImplÃ©mentations en mÃ©moire des repositories et services externes
- **Clock Mocking** : Pour tester les comportements liÃ©s au temps (`MockClock`)

- **@nestjs/testing** : Module de test pour NestJS avec injection de dÃ©pendances
- **Test paramÃ©trÃ©s** : `it.each()` pour Ã©viter la duplication de code
- **Mocks** : ImplÃ©mentations en mÃ©moire des repositories et services externes
- **Clock Mocking** : Pour tester les comportements liÃ©s au temps (`MockClock`)

- **@nestjs/testing** : Module de test pour NestJS avec injection de dÃ©pendances
- **Test paramÃ©trÃ©s** : `it.each()` pour Ã©viter la duplication de code
- **Mocks** : ImplÃ©mentations en mÃ©moire des repositories et services externes
- **Clock Mocking** : Pour tester les comportements liÃ©s au temps (`MockClock`)
## ğŸ“Š Statut de la migration (DerniÃ¨re MAJ: [DATE])

### âœ… **TerminÃ©**
- Migration `shared/` â†’ `libs/` 
- Correction de tous les imports (`@shared/*` â†’ `@/libs/*`)
- Structure contextes conforme Ã  l'architecture
- Module principal `contexts.module.ts` fonctionnel

### âš ï¸ **Dossiers obsolÃ¨tes Ã  nettoyer**
- `src/application/` : Contient encore des DTOs et logique obsolÃ¨te  
- `src/infrastructures/` : Contient des services API et wiring Ã  migrer

### ğŸ¯ **Prochaines Ã©tapes**
- Supprimer `/application` aprÃ¨s migration complÃ¨te des DTOs vers les contextes
- Supprimer `/infrastructures` aprÃ¨s migration des services vers les contextes appropriÃ©s
- Nettoyer `/github-temp` (dossier temporaire)
