---
description: expliques la facon dont on ajoute un nouvel evenement au systeme de notifications, comment s'en servir cotÃ© frontend et comment le systeme fonctionne cotÃ© backend. Tres
alwaysApply: false
---

# ğŸ”” SystÃ¨me de Notifications - Guide d'Utilisation

## ğŸ¯ Vue d'ensemble

SystÃ¨me de notifications temps rÃ©el utilisant WebSocket + EventEmitter2. Architecture event-driven : **Action â†’ Event â†’ Listener â†’ Notification â†’ WebSocket â†’ Client**.

## ğŸš€ Comment s'en servir cÃ´tÃ© Frontend

### 1. Connexion WebSocket

```javascript
// 1. RÃ©cupÃ©rer le token JWT
const response = await fetch("/v1/notifications/ws-token");
const { wsToken } = await response.json();

// 2. Se connecter
const socket = io("ws://localhost:4000/notifications", {
  query: { "x-ws-token": wsToken },
});
```

### 2. Ã‰couter les Ã©vÃ©nements

```javascript
// Connexion Ã©tablie
socket.on("connect", () => {
  console.log("âœ… ConnectÃ© aux notifications");
});

// Notifications non lues reÃ§ues Ã  la connexion
socket.on("unread-notifications", (notifications) => {
  displayUnreadNotifications(notifications);
});

// Nouvelles notifications en temps rÃ©el
socket.on("new-notification", (notification) => {
  showNotificationToast(notification.payload.message);
  addNotificationToList(notification);
});

// Notification marquÃ©e comme lue
socket.on("notification-read", (notification) => {
  updateNotificationStatus(notification.id, "read");
});
```

### 3. Ã‰mettre des actions

```javascript
// Marquer une notification comme lue
socket.emit("mark-read", { notificationId: "uuid-123" });

// Marquer toutes comme lues
socket.emit("mark-all-read");

// RafraÃ®chir les non lues
socket.emit("refresh-unread");
```

## â• Comment ajouter de nouveaux Ã©vÃ©nements

### 1. Ã‰mettre l'Ã©vÃ©nement dans le Command Handler

```typescript
// Dans CreateProjectCommandHandler
@CommandHandler(CreateProjectCommand)
export class CreateProjectCommandHandler {
  constructor(
    @Inject(EventEmitter2)
    private readonly eventEmitter: EventEmitter2
  ) {}

  async execute(
    command: CreateProjectCommand
  ): Promise<Result<Project, string>> {
    // ... logique mÃ©tier ...

    // ğŸ¯ Ã‰mettre l'Ã©vÃ©nement
    this.eventEmitter.emit("project.created", {
      projectId: savedProject.value.toPrimitive().id,
      projectTitle: savedProject.value.toPrimitive().title,
      ownerId: command.props.ownerId,
      ownerName: "John Doe",
    });

    return Result.ok(savedProject.value);
  }
}
```

### 2. CrÃ©er le Listener

```typescript
@Injectable()
export class ProjectNotificationsListener {
  constructor(private readonly commandBus: CommandBus) {}

  @OnEvent("project.created")
  async handleProjectCreated(event: {
    projectId: string;
    projectTitle: string;
    ownerId: string;
    ownerName: string;
  }) {
    const command = new CreateNotificationCommand({
      object: "project.created",
      receiverId: event.ownerId,
      senderId: event.ownerId,
      type: "project.created",
      payload: {
        projectId: event.projectId,
        projectTitle: event.projectTitle,
        message: `ğŸ‰ Votre projet "${event.projectTitle}" a Ã©tÃ© crÃ©Ã©.`,
      },
      channels: ["realtime"],
    });

    await this.commandBus.execute(command);
  }
}
```

### 3. Types d'Ã©vÃ©nements recommandÃ©s

```typescript
// Projets
"project.created", "project.updated", "project.deleted";

// RÃ´les et candidatures
"project.role.application.created", "project.role.application.accepted";

// Collaboration
"project.member.joined", "project.invite.sent";

// Messagerie
"message.received", "conversation.created";
```

## âš™ï¸ Comment le systÃ¨me fonctionne cÃ´tÃ© Backend

### 1. Architecture des composants

```
src/contexts/notification/
â”œâ”€â”€ domain/                    # EntitÃ©s et logique mÃ©tier
â”œâ”€â”€ use-cases/                # Commands/Queries CQRS
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ controllers/          # REST API endpoints
â”‚   â”œâ”€â”€ gateways/            # WebSocket Gateway
â”‚   â”œâ”€â”€ listeners/            # Event Listeners
â”‚   â””â”€â”€ services/            # Services mÃ©tier
```

### 2. Flux de donnÃ©es

```
Action MÃ©tier â†’ Command Handler â†’ EventEmitter.emit() â†’ @OnEvent Listener â†’
Notification Command â†’ Service â†’ RealtimeNotifierAdapter â†’ WebSocket Gateway â†’ Client
```

### 3. Authentification WebSocket

```typescript
// Dans NotificationsGateway
async handleConnection(client: AuthenticatedSocket): Promise<void> {
  // 1. Authentification JWT
  const userId = await this.webSocketAuthService.authenticateSocket(client);
  if (!userId) {
    client.disconnect();
    return;
  }

  // 2. Enregistrement connexion
  this.connectionManager.registerConnection(userId, client);

  // 3. Envoi notifications non lues
  await this.sendUnreadNotifications(userId, client);
}
```

### 4. Endpoints REST disponibles

```http
POST   /v1/notifications              # CrÃ©er notification
GET    /v1/notifications/unread       # RÃ©cupÃ©rer non lues
PATCH  /v1/notifications/{id}/read    # Marquer comme lue
PATCH  /v1/notifications/mark-all-read # Marquer toutes comme lues
GET    /v1/notifications/ws-token     # Token WebSocket
```

### 5. Configuration requise

```bash
# .env
JWT_SECRET=your-secret-key-here

# package.json
"@nestjs/websockets": "^11.1.3",
"@nestjs/platform-socket.io": "^11.1.4",
"@nestjs/event-emitter": "^3.0.1"
```

---

**Note** : Le systÃ¨me gÃ¨re automatiquement la persistance des notifications et la reconnexion des clients. Les tokens WebSocket expirent aprÃ¨s 1h.

# ğŸ”” SystÃ¨me de Notifications - Guide d'Utilisation

## ğŸ¯ Vue d'ensemble

SystÃ¨me de notifications temps rÃ©el utilisant WebSocket + EventEmitter2. Architecture event-driven : **Action â†’ Event â†’ Listener â†’ Notification â†’ WebSocket â†’ Client**.

## ğŸš€ Comment s'en servir cÃ´tÃ© Frontend

### 1. Connexion WebSocket

```javascript
// 1. RÃ©cupÃ©rer le token JWT
const response = await fetch("/v1/notifications/ws-token");
const { wsToken } = await response.json();

// 2. Se connecter
const socket = io("ws://localhost:4000/notifications", {
  query: { "x-ws-token": wsToken },
});
```

### 2. Ã‰couter les Ã©vÃ©nements

```javascript
// Connexion Ã©tablie
socket.on("connect", () => {
  console.log("âœ… ConnectÃ© aux notifications");
});

// Notifications non lues reÃ§ues Ã  la connexion
socket.on("unread-notifications", (notifications) => {
  displayUnreadNotifications(notifications);
});

// Nouvelles notifications en temps rÃ©el
socket.on("new-notification", (notification) => {
  showNotificationToast(notification.payload.message);
  addNotificationToList(notification);
});

// Notification marquÃ©e comme lue
socket.on("notification-read", (notification) => {
  updateNotificationStatus(notification.id, "read");
});
```

### 3. Ã‰mettre des actions

```javascript
// Marquer une notification comme lue
socket.emit("mark-read", { notificationId: "uuid-123" });

// Marquer toutes comme lues
socket.emit("mark-all-read");

// RafraÃ®chir les non lues
socket.emit("refresh-unread");
```

## â• Comment ajouter de nouveaux Ã©vÃ©nements

### 1. Ã‰mettre l'Ã©vÃ©nement dans le Command Handler

```typescript
// Dans CreateProjectCommandHandler
@CommandHandler(CreateProjectCommand)
export class CreateProjectCommandHandler {
  constructor(
    @Inject(EventEmitter2)
    private readonly eventEmitter: EventEmitter2
  ) {}

  async execute(
    command: CreateProjectCommand
  ): Promise<Result<Project, string>> {
    // ... logique mÃ©tier ...

    // ğŸ¯ Ã‰mettre l'Ã©vÃ©nement
    this.eventEmitter.emit("project.created", {
      projectId: savedProject.value.toPrimitive().id,
      projectTitle: savedProject.value.toPrimitive().title,
      ownerId: command.props.ownerId,
      ownerName: "John Doe",
    });

    return Result.ok(savedProject.value);
  }
}
```

### 2. CrÃ©er le Listener

```typescript
@Injectable()
export class ProjectNotificationsListener {
  constructor(private readonly commandBus: CommandBus) {}

  @OnEvent("project.created")
  async handleProjectCreated(event: {
    projectId: string;
    projectTitle: string;
    ownerId: string;
    ownerName: string;
  }) {
    const command = new CreateNotificationCommand({
      object: "project.created",
      receiverId: event.ownerId,
      senderId: event.ownerId,
      type: "project.created",
      payload: {
        projectId: event.projectId,
        projectTitle: event.projectTitle,
        message: `ğŸ‰ Votre projet "${event.projectTitle}" a Ã©tÃ© crÃ©Ã©.`,
      },
      channels: ["realtime"],
    });

    await this.commandBus.execute(command);
  }
}
```

### 3. Types d'Ã©vÃ©nements recommandÃ©s

```typescript
// Projets
"project.created", "project.updated", "project.deleted";

// RÃ´les et candidatures
"project.role.application.created", "project.role.application.accepted";

// Collaboration
"project.member.joined", "project.invite.sent";

// Messagerie
"message.received", "conversation.created";
```

## âš™ï¸ Comment le systÃ¨me fonctionne cÃ´tÃ© Backend

### 1. Architecture des composants

```
src/contexts/notification/
â”œâ”€â”€ domain/                    # EntitÃ©s et logique mÃ©tier
â”œâ”€â”€ use-cases/                # Commands/Queries CQRS
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ controllers/          # REST API endpoints
â”‚   â”œâ”€â”€ gateways/            # WebSocket Gateway
â”‚   â”œâ”€â”€ listeners/            # Event Listeners
â”‚   â””â”€â”€ services/            # Services mÃ©tier
```

### 2. Flux de donnÃ©es

```
Action MÃ©tier â†’ Command Handler â†’ EventEmitter.emit() â†’ @OnEvent Listener â†’
Notification Command â†’ Service â†’ RealtimeNotifierAdapter â†’ WebSocket Gateway â†’ Client
```

### 3. Authentification WebSocket

```typescript
// Dans NotificationsGateway
async handleConnection(client: AuthenticatedSocket): Promise<void> {
  // 1. Authentification JWT
  const userId = await this.webSocketAuthService.authenticateSocket(client);
  if (!userId) {
    client.disconnect();
    return;
  }

  // 2. Enregistrement connexion
  this.connectionManager.registerConnection(userId, client);

  // 3. Envoi notifications non lues
  await this.sendUnreadNotifications(userId, client);
}
```

### 4. Endpoints REST disponibles

```http
POST   /v1/notifications              # CrÃ©er notification
GET    /v1/notifications/unread       # RÃ©cupÃ©rer non lues
PATCH  /v1/notifications/{id}/read    # Marquer comme lue
PATCH  /v1/notifications/mark-all-read # Marquer toutes comme lues
GET    /v1/notifications/ws-token     # Token WebSocket
```

### 5. Configuration requise

```bash
# .env
JWT_SECRET=your-secret-key-here

# package.json
"@nestjs/websockets": "^11.1.3",
"@nestjs/platform-socket.io": "^11.1.4",
"@nestjs/event-emitter": "^3.0.1"
```

---

**Note** : Le systÃ¨me gÃ¨re automatiquement la persistance des notifications et la reconnexion des clients. Les tokens WebSocket expirent aprÃ¨s 1h.
