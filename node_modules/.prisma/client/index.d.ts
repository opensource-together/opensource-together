
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model UserGitHubCredentials
 * 
 */
export type UserGitHubCredentials = $Result.DefaultSelection<Prisma.$UserGitHubCredentialsPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectExternalLink
 * 
 */
export type ProjectExternalLink = $Result.DefaultSelection<Prisma.$ProjectExternalLinkPayload>
/**
 * Model TechStack
 * 
 */
export type TechStack = $Result.DefaultSelection<Prisma.$TechStackPayload>
/**
 * Model teamMember
 * 
 */
export type teamMember = $Result.DefaultSelection<Prisma.$teamMemberPayload>
/**
 * Model ProjectRole
 * 
 */
export type ProjectRole = $Result.DefaultSelection<Prisma.$ProjectRolePayload>
/**
 * Model ProjectRoleApplication
 * 
 */
export type ProjectRoleApplication = $Result.DefaultSelection<Prisma.$ProjectRoleApplicationPayload>
/**
 * Model UserSocialLink
 * 
 */
export type UserSocialLink = $Result.DefaultSelection<Prisma.$UserSocialLinkPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model KeyFeature
 * 
 */
export type KeyFeature = $Result.DefaultSelection<Prisma.$KeyFeaturePayload>
/**
 * Model ProjectGoal
 * 
 */
export type ProjectGoal = $Result.DefaultSelection<Prisma.$ProjectGoalPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Difficulty: {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD'
};

export type Difficulty = (typeof Difficulty)[keyof typeof Difficulty]


export const TechStackType: {
  LANGUAGE: 'LANGUAGE',
  TECH: 'TECH'
};

export type TechStackType = (typeof TechStackType)[keyof typeof TechStackType]

}

export type Difficulty = $Enums.Difficulty

export const Difficulty: typeof $Enums.Difficulty

export type TechStackType = $Enums.TechStackType

export const TechStackType: typeof $Enums.TechStackType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGitHubCredentials`: Exposes CRUD operations for the **UserGitHubCredentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGitHubCredentials
    * const userGitHubCredentials = await prisma.userGitHubCredentials.findMany()
    * ```
    */
  get userGitHubCredentials(): Prisma.UserGitHubCredentialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectExternalLink`: Exposes CRUD operations for the **ProjectExternalLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectExternalLinks
    * const projectExternalLinks = await prisma.projectExternalLink.findMany()
    * ```
    */
  get projectExternalLink(): Prisma.ProjectExternalLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.techStack`: Exposes CRUD operations for the **TechStack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechStacks
    * const techStacks = await prisma.techStack.findMany()
    * ```
    */
  get techStack(): Prisma.TechStackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **teamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.teamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectRole`: Exposes CRUD operations for the **ProjectRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectRoles
    * const projectRoles = await prisma.projectRole.findMany()
    * ```
    */
  get projectRole(): Prisma.ProjectRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectRoleApplication`: Exposes CRUD operations for the **ProjectRoleApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectRoleApplications
    * const projectRoleApplications = await prisma.projectRoleApplication.findMany()
    * ```
    */
  get projectRoleApplication(): Prisma.ProjectRoleApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSocialLink`: Exposes CRUD operations for the **UserSocialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSocialLinks
    * const userSocialLinks = await prisma.userSocialLink.findMany()
    * ```
    */
  get userSocialLink(): Prisma.UserSocialLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyFeature`: Exposes CRUD operations for the **KeyFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeyFeatures
    * const keyFeatures = await prisma.keyFeature.findMany()
    * ```
    */
  get keyFeature(): Prisma.KeyFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectGoal`: Exposes CRUD operations for the **ProjectGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectGoals
    * const projectGoals = await prisma.projectGoal.findMany()
    * ```
    */
  get projectGoal(): Prisma.ProjectGoalDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    UserGitHubCredentials: 'UserGitHubCredentials',
    Project: 'Project',
    ProjectExternalLink: 'ProjectExternalLink',
    TechStack: 'TechStack',
    teamMember: 'teamMember',
    ProjectRole: 'ProjectRole',
    ProjectRoleApplication: 'ProjectRoleApplication',
    UserSocialLink: 'UserSocialLink',
    Category: 'Category',
    KeyFeature: 'KeyFeature',
    ProjectGoal: 'ProjectGoal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "profile" | "userGitHubCredentials" | "project" | "projectExternalLink" | "techStack" | "teamMember" | "projectRole" | "projectRoleApplication" | "userSocialLink" | "category" | "keyFeature" | "projectGoal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      UserGitHubCredentials: {
        payload: Prisma.$UserGitHubCredentialsPayload<ExtArgs>
        fields: Prisma.UserGitHubCredentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGitHubCredentialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGitHubCredentialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>
          }
          findFirst: {
            args: Prisma.UserGitHubCredentialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGitHubCredentialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>
          }
          findMany: {
            args: Prisma.UserGitHubCredentialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>[]
          }
          create: {
            args: Prisma.UserGitHubCredentialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>
          }
          createMany: {
            args: Prisma.UserGitHubCredentialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGitHubCredentialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>[]
          }
          delete: {
            args: Prisma.UserGitHubCredentialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>
          }
          update: {
            args: Prisma.UserGitHubCredentialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>
          }
          deleteMany: {
            args: Prisma.UserGitHubCredentialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGitHubCredentialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserGitHubCredentialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>[]
          }
          upsert: {
            args: Prisma.UserGitHubCredentialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGitHubCredentialsPayload>
          }
          aggregate: {
            args: Prisma.UserGitHubCredentialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGitHubCredentials>
          }
          groupBy: {
            args: Prisma.UserGitHubCredentialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGitHubCredentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGitHubCredentialsCountArgs<ExtArgs>
            result: $Utils.Optional<UserGitHubCredentialsCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectExternalLink: {
        payload: Prisma.$ProjectExternalLinkPayload<ExtArgs>
        fields: Prisma.ProjectExternalLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectExternalLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectExternalLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>
          }
          findFirst: {
            args: Prisma.ProjectExternalLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectExternalLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>
          }
          findMany: {
            args: Prisma.ProjectExternalLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>[]
          }
          create: {
            args: Prisma.ProjectExternalLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>
          }
          createMany: {
            args: Prisma.ProjectExternalLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectExternalLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>[]
          }
          delete: {
            args: Prisma.ProjectExternalLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>
          }
          update: {
            args: Prisma.ProjectExternalLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>
          }
          deleteMany: {
            args: Prisma.ProjectExternalLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectExternalLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectExternalLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>[]
          }
          upsert: {
            args: Prisma.ProjectExternalLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectExternalLinkPayload>
          }
          aggregate: {
            args: Prisma.ProjectExternalLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectExternalLink>
          }
          groupBy: {
            args: Prisma.ProjectExternalLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectExternalLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectExternalLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectExternalLinkCountAggregateOutputType> | number
          }
        }
      }
      TechStack: {
        payload: Prisma.$TechStackPayload<ExtArgs>
        fields: Prisma.TechStackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechStackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechStackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>
          }
          findFirst: {
            args: Prisma.TechStackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechStackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>
          }
          findMany: {
            args: Prisma.TechStackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>[]
          }
          create: {
            args: Prisma.TechStackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>
          }
          createMany: {
            args: Prisma.TechStackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechStackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>[]
          }
          delete: {
            args: Prisma.TechStackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>
          }
          update: {
            args: Prisma.TechStackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>
          }
          deleteMany: {
            args: Prisma.TechStackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechStackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechStackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>[]
          }
          upsert: {
            args: Prisma.TechStackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechStackPayload>
          }
          aggregate: {
            args: Prisma.TechStackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechStack>
          }
          groupBy: {
            args: Prisma.TechStackGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechStackGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechStackCountArgs<ExtArgs>
            result: $Utils.Optional<TechStackCountAggregateOutputType> | number
          }
        }
      }
      teamMember: {
        payload: Prisma.$teamMemberPayload<ExtArgs>
        fields: Prisma.teamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>
          }
          findFirst: {
            args: Prisma.teamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>
          }
          findMany: {
            args: Prisma.teamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>[]
          }
          create: {
            args: Prisma.teamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>
          }
          createMany: {
            args: Prisma.teamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>[]
          }
          delete: {
            args: Prisma.teamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>
          }
          update: {
            args: Prisma.teamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>
          }
          deleteMany: {
            args: Prisma.teamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>[]
          }
          upsert: {
            args: Prisma.teamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.teamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      ProjectRole: {
        payload: Prisma.$ProjectRolePayload<ExtArgs>
        fields: Prisma.ProjectRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          findFirst: {
            args: Prisma.ProjectRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          findMany: {
            args: Prisma.ProjectRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>[]
          }
          create: {
            args: Prisma.ProjectRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          createMany: {
            args: Prisma.ProjectRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>[]
          }
          delete: {
            args: Prisma.ProjectRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          update: {
            args: Prisma.ProjectRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          deleteMany: {
            args: Prisma.ProjectRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>[]
          }
          upsert: {
            args: Prisma.ProjectRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          aggregate: {
            args: Prisma.ProjectRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectRole>
          }
          groupBy: {
            args: Prisma.ProjectRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectRoleCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectRoleCountAggregateOutputType> | number
          }
        }
      }
      ProjectRoleApplication: {
        payload: Prisma.$ProjectRoleApplicationPayload<ExtArgs>
        fields: Prisma.ProjectRoleApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectRoleApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectRoleApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>
          }
          findFirst: {
            args: Prisma.ProjectRoleApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectRoleApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>
          }
          findMany: {
            args: Prisma.ProjectRoleApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>[]
          }
          create: {
            args: Prisma.ProjectRoleApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>
          }
          createMany: {
            args: Prisma.ProjectRoleApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectRoleApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>[]
          }
          delete: {
            args: Prisma.ProjectRoleApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>
          }
          update: {
            args: Prisma.ProjectRoleApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectRoleApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectRoleApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectRoleApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>[]
          }
          upsert: {
            args: Prisma.ProjectRoleApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRoleApplicationPayload>
          }
          aggregate: {
            args: Prisma.ProjectRoleApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectRoleApplication>
          }
          groupBy: {
            args: Prisma.ProjectRoleApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectRoleApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectRoleApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectRoleApplicationCountAggregateOutputType> | number
          }
        }
      }
      UserSocialLink: {
        payload: Prisma.$UserSocialLinkPayload<ExtArgs>
        fields: Prisma.UserSocialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSocialLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSocialLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
          }
          findFirst: {
            args: Prisma.UserSocialLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSocialLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
          }
          findMany: {
            args: Prisma.UserSocialLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>[]
          }
          create: {
            args: Prisma.UserSocialLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
          }
          createMany: {
            args: Prisma.UserSocialLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSocialLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>[]
          }
          delete: {
            args: Prisma.UserSocialLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
          }
          update: {
            args: Prisma.UserSocialLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
          }
          deleteMany: {
            args: Prisma.UserSocialLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSocialLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSocialLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>[]
          }
          upsert: {
            args: Prisma.UserSocialLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
          }
          aggregate: {
            args: Prisma.UserSocialLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSocialLink>
          }
          groupBy: {
            args: Prisma.UserSocialLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSocialLinkCountArgs<ExtArgs>
            result: $Utils.Optional<UserSocialLinkCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      KeyFeature: {
        payload: Prisma.$KeyFeaturePayload<ExtArgs>
        fields: Prisma.KeyFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>
          }
          findFirst: {
            args: Prisma.KeyFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>
          }
          findMany: {
            args: Prisma.KeyFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>[]
          }
          create: {
            args: Prisma.KeyFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>
          }
          createMany: {
            args: Prisma.KeyFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeyFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>[]
          }
          delete: {
            args: Prisma.KeyFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>
          }
          update: {
            args: Prisma.KeyFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>
          }
          deleteMany: {
            args: Prisma.KeyFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeyFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeyFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>[]
          }
          upsert: {
            args: Prisma.KeyFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyFeaturePayload>
          }
          aggregate: {
            args: Prisma.KeyFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyFeature>
          }
          groupBy: {
            args: Prisma.KeyFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeyFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeyFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<KeyFeatureCountAggregateOutputType> | number
          }
        }
      }
      ProjectGoal: {
        payload: Prisma.$ProjectGoalPayload<ExtArgs>
        fields: Prisma.ProjectGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>
          }
          findFirst: {
            args: Prisma.ProjectGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>
          }
          findMany: {
            args: Prisma.ProjectGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>[]
          }
          create: {
            args: Prisma.ProjectGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>
          }
          createMany: {
            args: Prisma.ProjectGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>[]
          }
          delete: {
            args: Prisma.ProjectGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>
          }
          update: {
            args: Prisma.ProjectGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>
          }
          deleteMany: {
            args: Prisma.ProjectGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>[]
          }
          upsert: {
            args: Prisma.ProjectGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGoalPayload>
          }
          aggregate: {
            args: Prisma.ProjectGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectGoal>
          }
          groupBy: {
            args: Prisma.ProjectGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectGoalCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectGoalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profile?: ProfileOmit
    userGitHubCredentials?: UserGitHubCredentialsOmit
    project?: ProjectOmit
    projectExternalLink?: ProjectExternalLinkOmit
    techStack?: TechStackOmit
    teamMember?: teamMemberOmit
    projectRole?: ProjectRoleOmit
    projectRoleApplication?: ProjectRoleApplicationOmit
    userSocialLink?: UserSocialLinkOmit
    category?: CategoryOmit
    keyFeature?: KeyFeatureOmit
    projectGoal?: ProjectGoalOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    socialLinks: number
    projects: number
    projectRoleApplication: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socialLinks?: boolean | ProfileCountOutputTypeCountSocialLinksArgs
    projects?: boolean | ProfileCountOutputTypeCountProjectsArgs
    projectRoleApplication?: boolean | ProfileCountOutputTypeCountProjectRoleApplicationArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountSocialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialLinkWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountProjectRoleApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleApplicationWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    externalLinks: number
    techStacks: number
    projectMembers: number
    projectRoles: number
    categories: number
    keyFeatures: number
    projectGoals: number
    projectRoleApplication: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externalLinks?: boolean | ProjectCountOutputTypeCountExternalLinksArgs
    techStacks?: boolean | ProjectCountOutputTypeCountTechStacksArgs
    projectMembers?: boolean | ProjectCountOutputTypeCountProjectMembersArgs
    projectRoles?: boolean | ProjectCountOutputTypeCountProjectRolesArgs
    categories?: boolean | ProjectCountOutputTypeCountCategoriesArgs
    keyFeatures?: boolean | ProjectCountOutputTypeCountKeyFeaturesArgs
    projectGoals?: boolean | ProjectCountOutputTypeCountProjectGoalsArgs
    projectRoleApplication?: boolean | ProjectCountOutputTypeCountProjectRoleApplicationArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountExternalLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectExternalLinkWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTechStacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechStackWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountKeyFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyFeatureWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGoalWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectRoleApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleApplicationWhereInput
  }


  /**
   * Count Type TechStackCountOutputType
   */

  export type TechStackCountOutputType = {
    projects: number
    projectRoles: number
  }

  export type TechStackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | TechStackCountOutputTypeCountProjectsArgs
    projectRoles?: boolean | TechStackCountOutputTypeCountProjectRolesArgs
  }

  // Custom InputTypes
  /**
   * TechStackCountOutputType without action
   */
  export type TechStackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStackCountOutputType
     */
    select?: TechStackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TechStackCountOutputType without action
   */
  export type TechStackCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * TechStackCountOutputType without action
   */
  export type TechStackCountOutputTypeCountProjectRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleWhereInput
  }


  /**
   * Count Type TeamMemberCountOutputType
   */

  export type TeamMemberCountOutputType = {
    projectRole: number
  }

  export type TeamMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectRole?: boolean | TeamMemberCountOutputTypeCountProjectRoleArgs
  }

  // Custom InputTypes
  /**
   * TeamMemberCountOutputType without action
   */
  export type TeamMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMemberCountOutputType
     */
    select?: TeamMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamMemberCountOutputType without action
   */
  export type TeamMemberCountOutputTypeCountProjectRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleWhereInput
  }


  /**
   * Count Type ProjectRoleCountOutputType
   */

  export type ProjectRoleCountOutputType = {
    techStacks: number
    teamMember: number
    projectRoleApplication: number
  }

  export type ProjectRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    techStacks?: boolean | ProjectRoleCountOutputTypeCountTechStacksArgs
    teamMember?: boolean | ProjectRoleCountOutputTypeCountTeamMemberArgs
    projectRoleApplication?: boolean | ProjectRoleCountOutputTypeCountProjectRoleApplicationArgs
  }

  // Custom InputTypes
  /**
   * ProjectRoleCountOutputType without action
   */
  export type ProjectRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleCountOutputType
     */
    select?: ProjectRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectRoleCountOutputType without action
   */
  export type ProjectRoleCountOutputTypeCountTechStacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechStackWhereInput
  }

  /**
   * ProjectRoleCountOutputType without action
   */
  export type ProjectRoleCountOutputTypeCountTeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamMemberWhereInput
  }

  /**
   * ProjectRoleCountOutputType without action
   */
  export type ProjectRoleCountOutputTypeCountProjectRoleApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleApplicationWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    projects: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | CategoryCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    githubCredentials?: boolean | User$githubCredentialsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    githubCredentials?: boolean | User$githubCredentialsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      githubCredentials: Prisma.$UserGitHubCredentialsPayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    githubCredentials<T extends User$githubCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$githubCredentialsArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.githubCredentials
   */
  export type User$githubCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    where?: UserGitHubCredentialsWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    userId: string | null
    name: string | null
    login: string | null
    avatarUrl: string | null
    location: string | null
    company: string | null
    bio: string | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    userId: string | null
    name: string | null
    login: string | null
    avatarUrl: string | null
    location: string | null
    company: string | null
    bio: string | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    userId: number
    name: number
    login: number
    avatarUrl: number
    location: number
    company: number
    bio: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    userId?: true
    name?: true
    login?: true
    avatarUrl?: true
    location?: true
    company?: true
    bio?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    userId?: true
    name?: true
    login?: true
    avatarUrl?: true
    location?: true
    company?: true
    bio?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    userId?: true
    name?: true
    login?: true
    avatarUrl?: true
    location?: true
    company?: true
    bio?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    userId: string
    name: string
    login: string
    avatarUrl: string | null
    location: string | null
    company: string | null
    bio: string | null
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    name?: boolean
    login?: boolean
    avatarUrl?: boolean
    location?: boolean
    company?: boolean
    bio?: boolean
    updatedAt?: boolean
    user?: boolean | Profile$userArgs<ExtArgs>
    socialLinks?: boolean | Profile$socialLinksArgs<ExtArgs>
    projects?: boolean | Profile$projectsArgs<ExtArgs>
    projectRoleApplication?: boolean | Profile$projectRoleApplicationArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    name?: boolean
    login?: boolean
    avatarUrl?: boolean
    location?: boolean
    company?: boolean
    bio?: boolean
    updatedAt?: boolean
    user?: boolean | Profile$userArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    name?: boolean
    login?: boolean
    avatarUrl?: boolean
    location?: boolean
    company?: boolean
    bio?: boolean
    updatedAt?: boolean
    user?: boolean | Profile$userArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    userId?: boolean
    name?: boolean
    login?: boolean
    avatarUrl?: boolean
    location?: boolean
    company?: boolean
    bio?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "name" | "login" | "avatarUrl" | "location" | "company" | "bio" | "updatedAt", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Profile$userArgs<ExtArgs>
    socialLinks?: boolean | Profile$socialLinksArgs<ExtArgs>
    projects?: boolean | Profile$projectsArgs<ExtArgs>
    projectRoleApplication?: boolean | Profile$projectRoleApplicationArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Profile$userArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Profile$userArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      socialLinks: Prisma.$UserSocialLinkPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      projectRoleApplication: Prisma.$ProjectRoleApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      name: string
      login: string
      avatarUrl: string | null
      location: string | null
      company: string | null
      bio: string | null
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const profileWithUserIdOnly = await prisma.profile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `userId`
     * const profileWithUserIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `userId`
     * const profileWithUserIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Profile$userArgs<ExtArgs> = {}>(args?: Subset<T, Profile$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    socialLinks<T extends Profile$socialLinksArgs<ExtArgs> = {}>(args?: Subset<T, Profile$socialLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Profile$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectRoleApplication<T extends Profile$projectRoleApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Profile$projectRoleApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly userId: FieldRef<"Profile", 'String'>
    readonly name: FieldRef<"Profile", 'String'>
    readonly login: FieldRef<"Profile", 'String'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly company: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.user
   */
  export type Profile$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Profile.socialLinks
   */
  export type Profile$socialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    where?: UserSocialLinkWhereInput
    orderBy?: UserSocialLinkOrderByWithRelationInput | UserSocialLinkOrderByWithRelationInput[]
    cursor?: UserSocialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSocialLinkScalarFieldEnum | UserSocialLinkScalarFieldEnum[]
  }

  /**
   * Profile.projects
   */
  export type Profile$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Profile.projectRoleApplication
   */
  export type Profile$projectRoleApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    where?: ProjectRoleApplicationWhereInput
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    cursor?: ProjectRoleApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleApplicationScalarFieldEnum | ProjectRoleApplicationScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserGitHubCredentials
   */

  export type AggregateUserGitHubCredentials = {
    _count: UserGitHubCredentialsCountAggregateOutputType | null
    _min: UserGitHubCredentialsMinAggregateOutputType | null
    _max: UserGitHubCredentialsMaxAggregateOutputType | null
  }

  export type UserGitHubCredentialsMinAggregateOutputType = {
    userId: string | null
    githubAccessToken: string | null
    githubUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGitHubCredentialsMaxAggregateOutputType = {
    userId: string | null
    githubAccessToken: string | null
    githubUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGitHubCredentialsCountAggregateOutputType = {
    userId: number
    githubAccessToken: number
    githubUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserGitHubCredentialsMinAggregateInputType = {
    userId?: true
    githubAccessToken?: true
    githubUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGitHubCredentialsMaxAggregateInputType = {
    userId?: true
    githubAccessToken?: true
    githubUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGitHubCredentialsCountAggregateInputType = {
    userId?: true
    githubAccessToken?: true
    githubUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserGitHubCredentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGitHubCredentials to aggregate.
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGitHubCredentials to fetch.
     */
    orderBy?: UserGitHubCredentialsOrderByWithRelationInput | UserGitHubCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGitHubCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGitHubCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGitHubCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGitHubCredentials
    **/
    _count?: true | UserGitHubCredentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGitHubCredentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGitHubCredentialsMaxAggregateInputType
  }

  export type GetUserGitHubCredentialsAggregateType<T extends UserGitHubCredentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGitHubCredentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGitHubCredentials[P]>
      : GetScalarType<T[P], AggregateUserGitHubCredentials[P]>
  }




  export type UserGitHubCredentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGitHubCredentialsWhereInput
    orderBy?: UserGitHubCredentialsOrderByWithAggregationInput | UserGitHubCredentialsOrderByWithAggregationInput[]
    by: UserGitHubCredentialsScalarFieldEnum[] | UserGitHubCredentialsScalarFieldEnum
    having?: UserGitHubCredentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGitHubCredentialsCountAggregateInputType | true
    _min?: UserGitHubCredentialsMinAggregateInputType
    _max?: UserGitHubCredentialsMaxAggregateInputType
  }

  export type UserGitHubCredentialsGroupByOutputType = {
    userId: string
    githubAccessToken: string | null
    githubUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserGitHubCredentialsCountAggregateOutputType | null
    _min: UserGitHubCredentialsMinAggregateOutputType | null
    _max: UserGitHubCredentialsMaxAggregateOutputType | null
  }

  type GetUserGitHubCredentialsGroupByPayload<T extends UserGitHubCredentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGitHubCredentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGitHubCredentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGitHubCredentialsGroupByOutputType[P]>
            : GetScalarType<T[P], UserGitHubCredentialsGroupByOutputType[P]>
        }
      >
    >


  export type UserGitHubCredentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    githubAccessToken?: boolean
    githubUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserGitHubCredentials$userArgs<ExtArgs>
  }, ExtArgs["result"]["userGitHubCredentials"]>

  export type UserGitHubCredentialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    githubAccessToken?: boolean
    githubUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserGitHubCredentials$userArgs<ExtArgs>
  }, ExtArgs["result"]["userGitHubCredentials"]>

  export type UserGitHubCredentialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    githubAccessToken?: boolean
    githubUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserGitHubCredentials$userArgs<ExtArgs>
  }, ExtArgs["result"]["userGitHubCredentials"]>

  export type UserGitHubCredentialsSelectScalar = {
    userId?: boolean
    githubAccessToken?: boolean
    githubUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserGitHubCredentialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "githubAccessToken" | "githubUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["userGitHubCredentials"]>
  export type UserGitHubCredentialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserGitHubCredentials$userArgs<ExtArgs>
  }
  export type UserGitHubCredentialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserGitHubCredentials$userArgs<ExtArgs>
  }
  export type UserGitHubCredentialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserGitHubCredentials$userArgs<ExtArgs>
  }

  export type $UserGitHubCredentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGitHubCredentials"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      githubAccessToken: string | null
      githubUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userGitHubCredentials"]>
    composites: {}
  }

  type UserGitHubCredentialsGetPayload<S extends boolean | null | undefined | UserGitHubCredentialsDefaultArgs> = $Result.GetResult<Prisma.$UserGitHubCredentialsPayload, S>

  type UserGitHubCredentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGitHubCredentialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGitHubCredentialsCountAggregateInputType | true
    }

  export interface UserGitHubCredentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGitHubCredentials'], meta: { name: 'UserGitHubCredentials' } }
    /**
     * Find zero or one UserGitHubCredentials that matches the filter.
     * @param {UserGitHubCredentialsFindUniqueArgs} args - Arguments to find a UserGitHubCredentials
     * @example
     * // Get one UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGitHubCredentialsFindUniqueArgs>(args: SelectSubset<T, UserGitHubCredentialsFindUniqueArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGitHubCredentials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGitHubCredentialsFindUniqueOrThrowArgs} args - Arguments to find a UserGitHubCredentials
     * @example
     * // Get one UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGitHubCredentialsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGitHubCredentialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGitHubCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsFindFirstArgs} args - Arguments to find a UserGitHubCredentials
     * @example
     * // Get one UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGitHubCredentialsFindFirstArgs>(args?: SelectSubset<T, UserGitHubCredentialsFindFirstArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGitHubCredentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsFindFirstOrThrowArgs} args - Arguments to find a UserGitHubCredentials
     * @example
     * // Get one UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGitHubCredentialsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGitHubCredentialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGitHubCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.findMany()
     * 
     * // Get first 10 UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userGitHubCredentialsWithUserIdOnly = await prisma.userGitHubCredentials.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserGitHubCredentialsFindManyArgs>(args?: SelectSubset<T, UserGitHubCredentialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGitHubCredentials.
     * @param {UserGitHubCredentialsCreateArgs} args - Arguments to create a UserGitHubCredentials.
     * @example
     * // Create one UserGitHubCredentials
     * const UserGitHubCredentials = await prisma.userGitHubCredentials.create({
     *   data: {
     *     // ... data to create a UserGitHubCredentials
     *   }
     * })
     * 
     */
    create<T extends UserGitHubCredentialsCreateArgs>(args: SelectSubset<T, UserGitHubCredentialsCreateArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGitHubCredentials.
     * @param {UserGitHubCredentialsCreateManyArgs} args - Arguments to create many UserGitHubCredentials.
     * @example
     * // Create many UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGitHubCredentialsCreateManyArgs>(args?: SelectSubset<T, UserGitHubCredentialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGitHubCredentials and returns the data saved in the database.
     * @param {UserGitHubCredentialsCreateManyAndReturnArgs} args - Arguments to create many UserGitHubCredentials.
     * @example
     * // Create many UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGitHubCredentials and only return the `userId`
     * const userGitHubCredentialsWithUserIdOnly = await prisma.userGitHubCredentials.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGitHubCredentialsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGitHubCredentialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGitHubCredentials.
     * @param {UserGitHubCredentialsDeleteArgs} args - Arguments to delete one UserGitHubCredentials.
     * @example
     * // Delete one UserGitHubCredentials
     * const UserGitHubCredentials = await prisma.userGitHubCredentials.delete({
     *   where: {
     *     // ... filter to delete one UserGitHubCredentials
     *   }
     * })
     * 
     */
    delete<T extends UserGitHubCredentialsDeleteArgs>(args: SelectSubset<T, UserGitHubCredentialsDeleteArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGitHubCredentials.
     * @param {UserGitHubCredentialsUpdateArgs} args - Arguments to update one UserGitHubCredentials.
     * @example
     * // Update one UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGitHubCredentialsUpdateArgs>(args: SelectSubset<T, UserGitHubCredentialsUpdateArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGitHubCredentials.
     * @param {UserGitHubCredentialsDeleteManyArgs} args - Arguments to filter UserGitHubCredentials to delete.
     * @example
     * // Delete a few UserGitHubCredentials
     * const { count } = await prisma.userGitHubCredentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGitHubCredentialsDeleteManyArgs>(args?: SelectSubset<T, UserGitHubCredentialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGitHubCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGitHubCredentialsUpdateManyArgs>(args: SelectSubset<T, UserGitHubCredentialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGitHubCredentials and returns the data updated in the database.
     * @param {UserGitHubCredentialsUpdateManyAndReturnArgs} args - Arguments to update many UserGitHubCredentials.
     * @example
     * // Update many UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGitHubCredentials and only return the `userId`
     * const userGitHubCredentialsWithUserIdOnly = await prisma.userGitHubCredentials.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserGitHubCredentialsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserGitHubCredentialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGitHubCredentials.
     * @param {UserGitHubCredentialsUpsertArgs} args - Arguments to update or create a UserGitHubCredentials.
     * @example
     * // Update or create a UserGitHubCredentials
     * const userGitHubCredentials = await prisma.userGitHubCredentials.upsert({
     *   create: {
     *     // ... data to create a UserGitHubCredentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGitHubCredentials we want to update
     *   }
     * })
     */
    upsert<T extends UserGitHubCredentialsUpsertArgs>(args: SelectSubset<T, UserGitHubCredentialsUpsertArgs<ExtArgs>>): Prisma__UserGitHubCredentialsClient<$Result.GetResult<Prisma.$UserGitHubCredentialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGitHubCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsCountArgs} args - Arguments to filter UserGitHubCredentials to count.
     * @example
     * // Count the number of UserGitHubCredentials
     * const count = await prisma.userGitHubCredentials.count({
     *   where: {
     *     // ... the filter for the UserGitHubCredentials we want to count
     *   }
     * })
    **/
    count<T extends UserGitHubCredentialsCountArgs>(
      args?: Subset<T, UserGitHubCredentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGitHubCredentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGitHubCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGitHubCredentialsAggregateArgs>(args: Subset<T, UserGitHubCredentialsAggregateArgs>): Prisma.PrismaPromise<GetUserGitHubCredentialsAggregateType<T>>

    /**
     * Group by UserGitHubCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGitHubCredentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGitHubCredentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGitHubCredentialsGroupByArgs['orderBy'] }
        : { orderBy?: UserGitHubCredentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGitHubCredentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGitHubCredentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGitHubCredentials model
   */
  readonly fields: UserGitHubCredentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGitHubCredentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGitHubCredentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserGitHubCredentials$userArgs<ExtArgs> = {}>(args?: Subset<T, UserGitHubCredentials$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGitHubCredentials model
   */
  interface UserGitHubCredentialsFieldRefs {
    readonly userId: FieldRef<"UserGitHubCredentials", 'String'>
    readonly githubAccessToken: FieldRef<"UserGitHubCredentials", 'String'>
    readonly githubUserId: FieldRef<"UserGitHubCredentials", 'String'>
    readonly createdAt: FieldRef<"UserGitHubCredentials", 'DateTime'>
    readonly updatedAt: FieldRef<"UserGitHubCredentials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserGitHubCredentials findUnique
   */
  export type UserGitHubCredentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which UserGitHubCredentials to fetch.
     */
    where: UserGitHubCredentialsWhereUniqueInput
  }

  /**
   * UserGitHubCredentials findUniqueOrThrow
   */
  export type UserGitHubCredentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which UserGitHubCredentials to fetch.
     */
    where: UserGitHubCredentialsWhereUniqueInput
  }

  /**
   * UserGitHubCredentials findFirst
   */
  export type UserGitHubCredentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which UserGitHubCredentials to fetch.
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGitHubCredentials to fetch.
     */
    orderBy?: UserGitHubCredentialsOrderByWithRelationInput | UserGitHubCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGitHubCredentials.
     */
    cursor?: UserGitHubCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGitHubCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGitHubCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGitHubCredentials.
     */
    distinct?: UserGitHubCredentialsScalarFieldEnum | UserGitHubCredentialsScalarFieldEnum[]
  }

  /**
   * UserGitHubCredentials findFirstOrThrow
   */
  export type UserGitHubCredentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which UserGitHubCredentials to fetch.
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGitHubCredentials to fetch.
     */
    orderBy?: UserGitHubCredentialsOrderByWithRelationInput | UserGitHubCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGitHubCredentials.
     */
    cursor?: UserGitHubCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGitHubCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGitHubCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGitHubCredentials.
     */
    distinct?: UserGitHubCredentialsScalarFieldEnum | UserGitHubCredentialsScalarFieldEnum[]
  }

  /**
   * UserGitHubCredentials findMany
   */
  export type UserGitHubCredentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which UserGitHubCredentials to fetch.
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGitHubCredentials to fetch.
     */
    orderBy?: UserGitHubCredentialsOrderByWithRelationInput | UserGitHubCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGitHubCredentials.
     */
    cursor?: UserGitHubCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGitHubCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGitHubCredentials.
     */
    skip?: number
    distinct?: UserGitHubCredentialsScalarFieldEnum | UserGitHubCredentialsScalarFieldEnum[]
  }

  /**
   * UserGitHubCredentials create
   */
  export type UserGitHubCredentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGitHubCredentials.
     */
    data: XOR<UserGitHubCredentialsCreateInput, UserGitHubCredentialsUncheckedCreateInput>
  }

  /**
   * UserGitHubCredentials createMany
   */
  export type UserGitHubCredentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGitHubCredentials.
     */
    data: UserGitHubCredentialsCreateManyInput | UserGitHubCredentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGitHubCredentials createManyAndReturn
   */
  export type UserGitHubCredentialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * The data used to create many UserGitHubCredentials.
     */
    data: UserGitHubCredentialsCreateManyInput | UserGitHubCredentialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGitHubCredentials update
   */
  export type UserGitHubCredentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGitHubCredentials.
     */
    data: XOR<UserGitHubCredentialsUpdateInput, UserGitHubCredentialsUncheckedUpdateInput>
    /**
     * Choose, which UserGitHubCredentials to update.
     */
    where: UserGitHubCredentialsWhereUniqueInput
  }

  /**
   * UserGitHubCredentials updateMany
   */
  export type UserGitHubCredentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGitHubCredentials.
     */
    data: XOR<UserGitHubCredentialsUpdateManyMutationInput, UserGitHubCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which UserGitHubCredentials to update
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * Limit how many UserGitHubCredentials to update.
     */
    limit?: number
  }

  /**
   * UserGitHubCredentials updateManyAndReturn
   */
  export type UserGitHubCredentialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * The data used to update UserGitHubCredentials.
     */
    data: XOR<UserGitHubCredentialsUpdateManyMutationInput, UserGitHubCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which UserGitHubCredentials to update
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * Limit how many UserGitHubCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGitHubCredentials upsert
   */
  export type UserGitHubCredentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGitHubCredentials to update in case it exists.
     */
    where: UserGitHubCredentialsWhereUniqueInput
    /**
     * In case the UserGitHubCredentials found by the `where` argument doesn't exist, create a new UserGitHubCredentials with this data.
     */
    create: XOR<UserGitHubCredentialsCreateInput, UserGitHubCredentialsUncheckedCreateInput>
    /**
     * In case the UserGitHubCredentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGitHubCredentialsUpdateInput, UserGitHubCredentialsUncheckedUpdateInput>
  }

  /**
   * UserGitHubCredentials delete
   */
  export type UserGitHubCredentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
    /**
     * Filter which UserGitHubCredentials to delete.
     */
    where: UserGitHubCredentialsWhereUniqueInput
  }

  /**
   * UserGitHubCredentials deleteMany
   */
  export type UserGitHubCredentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGitHubCredentials to delete
     */
    where?: UserGitHubCredentialsWhereInput
    /**
     * Limit how many UserGitHubCredentials to delete.
     */
    limit?: number
  }

  /**
   * UserGitHubCredentials.user
   */
  export type UserGitHubCredentials$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserGitHubCredentials without action
   */
  export type UserGitHubCredentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGitHubCredentials
     */
    select?: UserGitHubCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGitHubCredentials
     */
    omit?: UserGitHubCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGitHubCredentialsInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    shortDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
    image: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    shortDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
    image: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    ownerId: number
    title: number
    description: number
    shortDescription: number
    createdAt: number
    updatedAt: number
    profileId: number
    image: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    shortDescription?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    image?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    shortDescription?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    image?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    shortDescription?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    image?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt: Date
    updatedAt: Date
    profileId: string | null
    image: string | null
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    image?: boolean
    externalLinks?: boolean | Project$externalLinksArgs<ExtArgs>
    techStacks?: boolean | Project$techStacksArgs<ExtArgs>
    projectMembers?: boolean | Project$projectMembersArgs<ExtArgs>
    projectRoles?: boolean | Project$projectRolesArgs<ExtArgs>
    categories?: boolean | Project$categoriesArgs<ExtArgs>
    keyFeatures?: boolean | Project$keyFeaturesArgs<ExtArgs>
    projectGoals?: boolean | Project$projectGoalsArgs<ExtArgs>
    projectRoleApplication?: boolean | Project$projectRoleApplicationArgs<ExtArgs>
    profile?: boolean | Project$profileArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    image?: boolean
    profile?: boolean | Project$profileArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    image?: boolean
    profile?: boolean | Project$profileArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    shortDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    image?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "title" | "description" | "shortDescription" | "createdAt" | "updatedAt" | "profileId" | "image", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externalLinks?: boolean | Project$externalLinksArgs<ExtArgs>
    techStacks?: boolean | Project$techStacksArgs<ExtArgs>
    projectMembers?: boolean | Project$projectMembersArgs<ExtArgs>
    projectRoles?: boolean | Project$projectRolesArgs<ExtArgs>
    categories?: boolean | Project$categoriesArgs<ExtArgs>
    keyFeatures?: boolean | Project$keyFeaturesArgs<ExtArgs>
    projectGoals?: boolean | Project$projectGoalsArgs<ExtArgs>
    projectRoleApplication?: boolean | Project$projectRoleApplicationArgs<ExtArgs>
    profile?: boolean | Project$profileArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | Project$profileArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | Project$profileArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      externalLinks: Prisma.$ProjectExternalLinkPayload<ExtArgs>[]
      techStacks: Prisma.$TechStackPayload<ExtArgs>[]
      projectMembers: Prisma.$teamMemberPayload<ExtArgs>[]
      projectRoles: Prisma.$ProjectRolePayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      keyFeatures: Prisma.$KeyFeaturePayload<ExtArgs>[]
      projectGoals: Prisma.$ProjectGoalPayload<ExtArgs>[]
      projectRoleApplication: Prisma.$ProjectRoleApplicationPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      title: string
      description: string
      shortDescription: string
      createdAt: Date
      updatedAt: Date
      profileId: string | null
      image: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    externalLinks<T extends Project$externalLinksArgs<ExtArgs> = {}>(args?: Subset<T, Project$externalLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    techStacks<T extends Project$techStacksArgs<ExtArgs> = {}>(args?: Subset<T, Project$techStacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMembers<T extends Project$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectRoles<T extends Project$projectRolesArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Project$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    keyFeatures<T extends Project$keyFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Project$keyFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectGoals<T extends Project$projectGoalsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectRoleApplication<T extends Project$projectRoleApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectRoleApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile<T extends Project$profileArgs<ExtArgs> = {}>(args?: Subset<T, Project$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly ownerId: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly shortDescription: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly profileId: FieldRef<"Project", 'String'>
    readonly image: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.externalLinks
   */
  export type Project$externalLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    where?: ProjectExternalLinkWhereInput
    orderBy?: ProjectExternalLinkOrderByWithRelationInput | ProjectExternalLinkOrderByWithRelationInput[]
    cursor?: ProjectExternalLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectExternalLinkScalarFieldEnum | ProjectExternalLinkScalarFieldEnum[]
  }

  /**
   * Project.techStacks
   */
  export type Project$techStacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    where?: TechStackWhereInput
    orderBy?: TechStackOrderByWithRelationInput | TechStackOrderByWithRelationInput[]
    cursor?: TechStackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechStackScalarFieldEnum | TechStackScalarFieldEnum[]
  }

  /**
   * Project.projectMembers
   */
  export type Project$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    where?: teamMemberWhereInput
    orderBy?: teamMemberOrderByWithRelationInput | teamMemberOrderByWithRelationInput[]
    cursor?: teamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Project.projectRoles
   */
  export type Project$projectRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    where?: ProjectRoleWhereInput
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    cursor?: ProjectRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * Project.categories
   */
  export type Project$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Project.keyFeatures
   */
  export type Project$keyFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    where?: KeyFeatureWhereInput
    orderBy?: KeyFeatureOrderByWithRelationInput | KeyFeatureOrderByWithRelationInput[]
    cursor?: KeyFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeyFeatureScalarFieldEnum | KeyFeatureScalarFieldEnum[]
  }

  /**
   * Project.projectGoals
   */
  export type Project$projectGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    where?: ProjectGoalWhereInput
    orderBy?: ProjectGoalOrderByWithRelationInput | ProjectGoalOrderByWithRelationInput[]
    cursor?: ProjectGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectGoalScalarFieldEnum | ProjectGoalScalarFieldEnum[]
  }

  /**
   * Project.projectRoleApplication
   */
  export type Project$projectRoleApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    where?: ProjectRoleApplicationWhereInput
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    cursor?: ProjectRoleApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleApplicationScalarFieldEnum | ProjectRoleApplicationScalarFieldEnum[]
  }

  /**
   * Project.profile
   */
  export type Project$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectExternalLink
   */

  export type AggregateProjectExternalLink = {
    _count: ProjectExternalLinkCountAggregateOutputType | null
    _min: ProjectExternalLinkMinAggregateOutputType | null
    _max: ProjectExternalLinkMaxAggregateOutputType | null
  }

  export type ProjectExternalLinkMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    type: string | null
    url: string | null
  }

  export type ProjectExternalLinkMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    type: string | null
    url: string | null
  }

  export type ProjectExternalLinkCountAggregateOutputType = {
    id: number
    projectId: number
    type: number
    url: number
    _all: number
  }


  export type ProjectExternalLinkMinAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    url?: true
  }

  export type ProjectExternalLinkMaxAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    url?: true
  }

  export type ProjectExternalLinkCountAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    url?: true
    _all?: true
  }

  export type ProjectExternalLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectExternalLink to aggregate.
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectExternalLinks to fetch.
     */
    orderBy?: ProjectExternalLinkOrderByWithRelationInput | ProjectExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectExternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectExternalLinks
    **/
    _count?: true | ProjectExternalLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectExternalLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectExternalLinkMaxAggregateInputType
  }

  export type GetProjectExternalLinkAggregateType<T extends ProjectExternalLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectExternalLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectExternalLink[P]>
      : GetScalarType<T[P], AggregateProjectExternalLink[P]>
  }




  export type ProjectExternalLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectExternalLinkWhereInput
    orderBy?: ProjectExternalLinkOrderByWithAggregationInput | ProjectExternalLinkOrderByWithAggregationInput[]
    by: ProjectExternalLinkScalarFieldEnum[] | ProjectExternalLinkScalarFieldEnum
    having?: ProjectExternalLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectExternalLinkCountAggregateInputType | true
    _min?: ProjectExternalLinkMinAggregateInputType
    _max?: ProjectExternalLinkMaxAggregateInputType
  }

  export type ProjectExternalLinkGroupByOutputType = {
    id: string
    projectId: string
    type: string
    url: string
    _count: ProjectExternalLinkCountAggregateOutputType | null
    _min: ProjectExternalLinkMinAggregateOutputType | null
    _max: ProjectExternalLinkMaxAggregateOutputType | null
  }

  type GetProjectExternalLinkGroupByPayload<T extends ProjectExternalLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectExternalLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectExternalLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectExternalLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectExternalLinkGroupByOutputType[P]>
        }
      >
    >


  export type ProjectExternalLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectExternalLink"]>

  export type ProjectExternalLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectExternalLink"]>

  export type ProjectExternalLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectExternalLink"]>

  export type ProjectExternalLinkSelectScalar = {
    id?: boolean
    projectId?: boolean
    type?: boolean
    url?: boolean
  }

  export type ProjectExternalLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "type" | "url", ExtArgs["result"]["projectExternalLink"]>
  export type ProjectExternalLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectExternalLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectExternalLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectExternalLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectExternalLink"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      type: string
      url: string
    }, ExtArgs["result"]["projectExternalLink"]>
    composites: {}
  }

  type ProjectExternalLinkGetPayload<S extends boolean | null | undefined | ProjectExternalLinkDefaultArgs> = $Result.GetResult<Prisma.$ProjectExternalLinkPayload, S>

  type ProjectExternalLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectExternalLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectExternalLinkCountAggregateInputType | true
    }

  export interface ProjectExternalLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectExternalLink'], meta: { name: 'ProjectExternalLink' } }
    /**
     * Find zero or one ProjectExternalLink that matches the filter.
     * @param {ProjectExternalLinkFindUniqueArgs} args - Arguments to find a ProjectExternalLink
     * @example
     * // Get one ProjectExternalLink
     * const projectExternalLink = await prisma.projectExternalLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectExternalLinkFindUniqueArgs>(args: SelectSubset<T, ProjectExternalLinkFindUniqueArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectExternalLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectExternalLinkFindUniqueOrThrowArgs} args - Arguments to find a ProjectExternalLink
     * @example
     * // Get one ProjectExternalLink
     * const projectExternalLink = await prisma.projectExternalLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectExternalLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectExternalLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectExternalLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkFindFirstArgs} args - Arguments to find a ProjectExternalLink
     * @example
     * // Get one ProjectExternalLink
     * const projectExternalLink = await prisma.projectExternalLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectExternalLinkFindFirstArgs>(args?: SelectSubset<T, ProjectExternalLinkFindFirstArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectExternalLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkFindFirstOrThrowArgs} args - Arguments to find a ProjectExternalLink
     * @example
     * // Get one ProjectExternalLink
     * const projectExternalLink = await prisma.projectExternalLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectExternalLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectExternalLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectExternalLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectExternalLinks
     * const projectExternalLinks = await prisma.projectExternalLink.findMany()
     * 
     * // Get first 10 ProjectExternalLinks
     * const projectExternalLinks = await prisma.projectExternalLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectExternalLinkWithIdOnly = await prisma.projectExternalLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectExternalLinkFindManyArgs>(args?: SelectSubset<T, ProjectExternalLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectExternalLink.
     * @param {ProjectExternalLinkCreateArgs} args - Arguments to create a ProjectExternalLink.
     * @example
     * // Create one ProjectExternalLink
     * const ProjectExternalLink = await prisma.projectExternalLink.create({
     *   data: {
     *     // ... data to create a ProjectExternalLink
     *   }
     * })
     * 
     */
    create<T extends ProjectExternalLinkCreateArgs>(args: SelectSubset<T, ProjectExternalLinkCreateArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectExternalLinks.
     * @param {ProjectExternalLinkCreateManyArgs} args - Arguments to create many ProjectExternalLinks.
     * @example
     * // Create many ProjectExternalLinks
     * const projectExternalLink = await prisma.projectExternalLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectExternalLinkCreateManyArgs>(args?: SelectSubset<T, ProjectExternalLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectExternalLinks and returns the data saved in the database.
     * @param {ProjectExternalLinkCreateManyAndReturnArgs} args - Arguments to create many ProjectExternalLinks.
     * @example
     * // Create many ProjectExternalLinks
     * const projectExternalLink = await prisma.projectExternalLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectExternalLinks and only return the `id`
     * const projectExternalLinkWithIdOnly = await prisma.projectExternalLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectExternalLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectExternalLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectExternalLink.
     * @param {ProjectExternalLinkDeleteArgs} args - Arguments to delete one ProjectExternalLink.
     * @example
     * // Delete one ProjectExternalLink
     * const ProjectExternalLink = await prisma.projectExternalLink.delete({
     *   where: {
     *     // ... filter to delete one ProjectExternalLink
     *   }
     * })
     * 
     */
    delete<T extends ProjectExternalLinkDeleteArgs>(args: SelectSubset<T, ProjectExternalLinkDeleteArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectExternalLink.
     * @param {ProjectExternalLinkUpdateArgs} args - Arguments to update one ProjectExternalLink.
     * @example
     * // Update one ProjectExternalLink
     * const projectExternalLink = await prisma.projectExternalLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectExternalLinkUpdateArgs>(args: SelectSubset<T, ProjectExternalLinkUpdateArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectExternalLinks.
     * @param {ProjectExternalLinkDeleteManyArgs} args - Arguments to filter ProjectExternalLinks to delete.
     * @example
     * // Delete a few ProjectExternalLinks
     * const { count } = await prisma.projectExternalLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectExternalLinkDeleteManyArgs>(args?: SelectSubset<T, ProjectExternalLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectExternalLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectExternalLinks
     * const projectExternalLink = await prisma.projectExternalLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectExternalLinkUpdateManyArgs>(args: SelectSubset<T, ProjectExternalLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectExternalLinks and returns the data updated in the database.
     * @param {ProjectExternalLinkUpdateManyAndReturnArgs} args - Arguments to update many ProjectExternalLinks.
     * @example
     * // Update many ProjectExternalLinks
     * const projectExternalLink = await prisma.projectExternalLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectExternalLinks and only return the `id`
     * const projectExternalLinkWithIdOnly = await prisma.projectExternalLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectExternalLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectExternalLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectExternalLink.
     * @param {ProjectExternalLinkUpsertArgs} args - Arguments to update or create a ProjectExternalLink.
     * @example
     * // Update or create a ProjectExternalLink
     * const projectExternalLink = await prisma.projectExternalLink.upsert({
     *   create: {
     *     // ... data to create a ProjectExternalLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectExternalLink we want to update
     *   }
     * })
     */
    upsert<T extends ProjectExternalLinkUpsertArgs>(args: SelectSubset<T, ProjectExternalLinkUpsertArgs<ExtArgs>>): Prisma__ProjectExternalLinkClient<$Result.GetResult<Prisma.$ProjectExternalLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectExternalLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkCountArgs} args - Arguments to filter ProjectExternalLinks to count.
     * @example
     * // Count the number of ProjectExternalLinks
     * const count = await prisma.projectExternalLink.count({
     *   where: {
     *     // ... the filter for the ProjectExternalLinks we want to count
     *   }
     * })
    **/
    count<T extends ProjectExternalLinkCountArgs>(
      args?: Subset<T, ProjectExternalLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectExternalLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectExternalLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectExternalLinkAggregateArgs>(args: Subset<T, ProjectExternalLinkAggregateArgs>): Prisma.PrismaPromise<GetProjectExternalLinkAggregateType<T>>

    /**
     * Group by ProjectExternalLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectExternalLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectExternalLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectExternalLinkGroupByArgs['orderBy'] }
        : { orderBy?: ProjectExternalLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectExternalLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectExternalLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectExternalLink model
   */
  readonly fields: ProjectExternalLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectExternalLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectExternalLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectExternalLink model
   */
  interface ProjectExternalLinkFieldRefs {
    readonly id: FieldRef<"ProjectExternalLink", 'String'>
    readonly projectId: FieldRef<"ProjectExternalLink", 'String'>
    readonly type: FieldRef<"ProjectExternalLink", 'String'>
    readonly url: FieldRef<"ProjectExternalLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectExternalLink findUnique
   */
  export type ProjectExternalLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ProjectExternalLink to fetch.
     */
    where: ProjectExternalLinkWhereUniqueInput
  }

  /**
   * ProjectExternalLink findUniqueOrThrow
   */
  export type ProjectExternalLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ProjectExternalLink to fetch.
     */
    where: ProjectExternalLinkWhereUniqueInput
  }

  /**
   * ProjectExternalLink findFirst
   */
  export type ProjectExternalLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ProjectExternalLink to fetch.
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectExternalLinks to fetch.
     */
    orderBy?: ProjectExternalLinkOrderByWithRelationInput | ProjectExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectExternalLinks.
     */
    cursor?: ProjectExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectExternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectExternalLinks.
     */
    distinct?: ProjectExternalLinkScalarFieldEnum | ProjectExternalLinkScalarFieldEnum[]
  }

  /**
   * ProjectExternalLink findFirstOrThrow
   */
  export type ProjectExternalLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ProjectExternalLink to fetch.
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectExternalLinks to fetch.
     */
    orderBy?: ProjectExternalLinkOrderByWithRelationInput | ProjectExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectExternalLinks.
     */
    cursor?: ProjectExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectExternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectExternalLinks.
     */
    distinct?: ProjectExternalLinkScalarFieldEnum | ProjectExternalLinkScalarFieldEnum[]
  }

  /**
   * ProjectExternalLink findMany
   */
  export type ProjectExternalLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ProjectExternalLinks to fetch.
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectExternalLinks to fetch.
     */
    orderBy?: ProjectExternalLinkOrderByWithRelationInput | ProjectExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectExternalLinks.
     */
    cursor?: ProjectExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectExternalLinks.
     */
    skip?: number
    distinct?: ProjectExternalLinkScalarFieldEnum | ProjectExternalLinkScalarFieldEnum[]
  }

  /**
   * ProjectExternalLink create
   */
  export type ProjectExternalLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectExternalLink.
     */
    data: XOR<ProjectExternalLinkCreateInput, ProjectExternalLinkUncheckedCreateInput>
  }

  /**
   * ProjectExternalLink createMany
   */
  export type ProjectExternalLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectExternalLinks.
     */
    data: ProjectExternalLinkCreateManyInput | ProjectExternalLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectExternalLink createManyAndReturn
   */
  export type ProjectExternalLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectExternalLinks.
     */
    data: ProjectExternalLinkCreateManyInput | ProjectExternalLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectExternalLink update
   */
  export type ProjectExternalLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectExternalLink.
     */
    data: XOR<ProjectExternalLinkUpdateInput, ProjectExternalLinkUncheckedUpdateInput>
    /**
     * Choose, which ProjectExternalLink to update.
     */
    where: ProjectExternalLinkWhereUniqueInput
  }

  /**
   * ProjectExternalLink updateMany
   */
  export type ProjectExternalLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectExternalLinks.
     */
    data: XOR<ProjectExternalLinkUpdateManyMutationInput, ProjectExternalLinkUncheckedUpdateManyInput>
    /**
     * Filter which ProjectExternalLinks to update
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * Limit how many ProjectExternalLinks to update.
     */
    limit?: number
  }

  /**
   * ProjectExternalLink updateManyAndReturn
   */
  export type ProjectExternalLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * The data used to update ProjectExternalLinks.
     */
    data: XOR<ProjectExternalLinkUpdateManyMutationInput, ProjectExternalLinkUncheckedUpdateManyInput>
    /**
     * Filter which ProjectExternalLinks to update
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * Limit how many ProjectExternalLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectExternalLink upsert
   */
  export type ProjectExternalLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectExternalLink to update in case it exists.
     */
    where: ProjectExternalLinkWhereUniqueInput
    /**
     * In case the ProjectExternalLink found by the `where` argument doesn't exist, create a new ProjectExternalLink with this data.
     */
    create: XOR<ProjectExternalLinkCreateInput, ProjectExternalLinkUncheckedCreateInput>
    /**
     * In case the ProjectExternalLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectExternalLinkUpdateInput, ProjectExternalLinkUncheckedUpdateInput>
  }

  /**
   * ProjectExternalLink delete
   */
  export type ProjectExternalLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
    /**
     * Filter which ProjectExternalLink to delete.
     */
    where: ProjectExternalLinkWhereUniqueInput
  }

  /**
   * ProjectExternalLink deleteMany
   */
  export type ProjectExternalLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectExternalLinks to delete
     */
    where?: ProjectExternalLinkWhereInput
    /**
     * Limit how many ProjectExternalLinks to delete.
     */
    limit?: number
  }

  /**
   * ProjectExternalLink without action
   */
  export type ProjectExternalLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectExternalLink
     */
    select?: ProjectExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectExternalLink
     */
    omit?: ProjectExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectExternalLinkInclude<ExtArgs> | null
  }


  /**
   * Model TechStack
   */

  export type AggregateTechStack = {
    _count: TechStackCountAggregateOutputType | null
    _min: TechStackMinAggregateOutputType | null
    _max: TechStackMaxAggregateOutputType | null
  }

  export type TechStackMinAggregateOutputType = {
    id: string | null
    name: string | null
    iconUrl: string | null
    type: $Enums.TechStackType | null
  }

  export type TechStackMaxAggregateOutputType = {
    id: string | null
    name: string | null
    iconUrl: string | null
    type: $Enums.TechStackType | null
  }

  export type TechStackCountAggregateOutputType = {
    id: number
    name: number
    iconUrl: number
    type: number
    _all: number
  }


  export type TechStackMinAggregateInputType = {
    id?: true
    name?: true
    iconUrl?: true
    type?: true
  }

  export type TechStackMaxAggregateInputType = {
    id?: true
    name?: true
    iconUrl?: true
    type?: true
  }

  export type TechStackCountAggregateInputType = {
    id?: true
    name?: true
    iconUrl?: true
    type?: true
    _all?: true
  }

  export type TechStackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechStack to aggregate.
     */
    where?: TechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechStacks to fetch.
     */
    orderBy?: TechStackOrderByWithRelationInput | TechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechStacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechStacks
    **/
    _count?: true | TechStackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechStackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechStackMaxAggregateInputType
  }

  export type GetTechStackAggregateType<T extends TechStackAggregateArgs> = {
        [P in keyof T & keyof AggregateTechStack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechStack[P]>
      : GetScalarType<T[P], AggregateTechStack[P]>
  }




  export type TechStackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechStackWhereInput
    orderBy?: TechStackOrderByWithAggregationInput | TechStackOrderByWithAggregationInput[]
    by: TechStackScalarFieldEnum[] | TechStackScalarFieldEnum
    having?: TechStackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechStackCountAggregateInputType | true
    _min?: TechStackMinAggregateInputType
    _max?: TechStackMaxAggregateInputType
  }

  export type TechStackGroupByOutputType = {
    id: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    _count: TechStackCountAggregateOutputType | null
    _min: TechStackMinAggregateOutputType | null
    _max: TechStackMaxAggregateOutputType | null
  }

  type GetTechStackGroupByPayload<T extends TechStackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechStackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechStackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechStackGroupByOutputType[P]>
            : GetScalarType<T[P], TechStackGroupByOutputType[P]>
        }
      >
    >


  export type TechStackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iconUrl?: boolean
    type?: boolean
    projects?: boolean | TechStack$projectsArgs<ExtArgs>
    projectRoles?: boolean | TechStack$projectRolesArgs<ExtArgs>
    _count?: boolean | TechStackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["techStack"]>

  export type TechStackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iconUrl?: boolean
    type?: boolean
  }, ExtArgs["result"]["techStack"]>

  export type TechStackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iconUrl?: boolean
    type?: boolean
  }, ExtArgs["result"]["techStack"]>

  export type TechStackSelectScalar = {
    id?: boolean
    name?: boolean
    iconUrl?: boolean
    type?: boolean
  }

  export type TechStackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "iconUrl" | "type", ExtArgs["result"]["techStack"]>
  export type TechStackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | TechStack$projectsArgs<ExtArgs>
    projectRoles?: boolean | TechStack$projectRolesArgs<ExtArgs>
    _count?: boolean | TechStackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TechStackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TechStackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TechStackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechStack"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      projectRoles: Prisma.$ProjectRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      iconUrl: string
      type: $Enums.TechStackType
    }, ExtArgs["result"]["techStack"]>
    composites: {}
  }

  type TechStackGetPayload<S extends boolean | null | undefined | TechStackDefaultArgs> = $Result.GetResult<Prisma.$TechStackPayload, S>

  type TechStackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechStackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechStackCountAggregateInputType | true
    }

  export interface TechStackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechStack'], meta: { name: 'TechStack' } }
    /**
     * Find zero or one TechStack that matches the filter.
     * @param {TechStackFindUniqueArgs} args - Arguments to find a TechStack
     * @example
     * // Get one TechStack
     * const techStack = await prisma.techStack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechStackFindUniqueArgs>(args: SelectSubset<T, TechStackFindUniqueArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechStack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechStackFindUniqueOrThrowArgs} args - Arguments to find a TechStack
     * @example
     * // Get one TechStack
     * const techStack = await prisma.techStack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechStackFindUniqueOrThrowArgs>(args: SelectSubset<T, TechStackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechStack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackFindFirstArgs} args - Arguments to find a TechStack
     * @example
     * // Get one TechStack
     * const techStack = await prisma.techStack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechStackFindFirstArgs>(args?: SelectSubset<T, TechStackFindFirstArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechStack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackFindFirstOrThrowArgs} args - Arguments to find a TechStack
     * @example
     * // Get one TechStack
     * const techStack = await prisma.techStack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechStackFindFirstOrThrowArgs>(args?: SelectSubset<T, TechStackFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechStacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechStacks
     * const techStacks = await prisma.techStack.findMany()
     * 
     * // Get first 10 TechStacks
     * const techStacks = await prisma.techStack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const techStackWithIdOnly = await prisma.techStack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechStackFindManyArgs>(args?: SelectSubset<T, TechStackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechStack.
     * @param {TechStackCreateArgs} args - Arguments to create a TechStack.
     * @example
     * // Create one TechStack
     * const TechStack = await prisma.techStack.create({
     *   data: {
     *     // ... data to create a TechStack
     *   }
     * })
     * 
     */
    create<T extends TechStackCreateArgs>(args: SelectSubset<T, TechStackCreateArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechStacks.
     * @param {TechStackCreateManyArgs} args - Arguments to create many TechStacks.
     * @example
     * // Create many TechStacks
     * const techStack = await prisma.techStack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechStackCreateManyArgs>(args?: SelectSubset<T, TechStackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechStacks and returns the data saved in the database.
     * @param {TechStackCreateManyAndReturnArgs} args - Arguments to create many TechStacks.
     * @example
     * // Create many TechStacks
     * const techStack = await prisma.techStack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechStacks and only return the `id`
     * const techStackWithIdOnly = await prisma.techStack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechStackCreateManyAndReturnArgs>(args?: SelectSubset<T, TechStackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechStack.
     * @param {TechStackDeleteArgs} args - Arguments to delete one TechStack.
     * @example
     * // Delete one TechStack
     * const TechStack = await prisma.techStack.delete({
     *   where: {
     *     // ... filter to delete one TechStack
     *   }
     * })
     * 
     */
    delete<T extends TechStackDeleteArgs>(args: SelectSubset<T, TechStackDeleteArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechStack.
     * @param {TechStackUpdateArgs} args - Arguments to update one TechStack.
     * @example
     * // Update one TechStack
     * const techStack = await prisma.techStack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechStackUpdateArgs>(args: SelectSubset<T, TechStackUpdateArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechStacks.
     * @param {TechStackDeleteManyArgs} args - Arguments to filter TechStacks to delete.
     * @example
     * // Delete a few TechStacks
     * const { count } = await prisma.techStack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechStackDeleteManyArgs>(args?: SelectSubset<T, TechStackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechStacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechStacks
     * const techStack = await prisma.techStack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechStackUpdateManyArgs>(args: SelectSubset<T, TechStackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechStacks and returns the data updated in the database.
     * @param {TechStackUpdateManyAndReturnArgs} args - Arguments to update many TechStacks.
     * @example
     * // Update many TechStacks
     * const techStack = await prisma.techStack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechStacks and only return the `id`
     * const techStackWithIdOnly = await prisma.techStack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechStackUpdateManyAndReturnArgs>(args: SelectSubset<T, TechStackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechStack.
     * @param {TechStackUpsertArgs} args - Arguments to update or create a TechStack.
     * @example
     * // Update or create a TechStack
     * const techStack = await prisma.techStack.upsert({
     *   create: {
     *     // ... data to create a TechStack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechStack we want to update
     *   }
     * })
     */
    upsert<T extends TechStackUpsertArgs>(args: SelectSubset<T, TechStackUpsertArgs<ExtArgs>>): Prisma__TechStackClient<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechStacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackCountArgs} args - Arguments to filter TechStacks to count.
     * @example
     * // Count the number of TechStacks
     * const count = await prisma.techStack.count({
     *   where: {
     *     // ... the filter for the TechStacks we want to count
     *   }
     * })
    **/
    count<T extends TechStackCountArgs>(
      args?: Subset<T, TechStackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechStackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechStack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechStackAggregateArgs>(args: Subset<T, TechStackAggregateArgs>): Prisma.PrismaPromise<GetTechStackAggregateType<T>>

    /**
     * Group by TechStack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechStackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechStackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechStackGroupByArgs['orderBy'] }
        : { orderBy?: TechStackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechStackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechStackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechStack model
   */
  readonly fields: TechStackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechStack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechStackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends TechStack$projectsArgs<ExtArgs> = {}>(args?: Subset<T, TechStack$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectRoles<T extends TechStack$projectRolesArgs<ExtArgs> = {}>(args?: Subset<T, TechStack$projectRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechStack model
   */
  interface TechStackFieldRefs {
    readonly id: FieldRef<"TechStack", 'String'>
    readonly name: FieldRef<"TechStack", 'String'>
    readonly iconUrl: FieldRef<"TechStack", 'String'>
    readonly type: FieldRef<"TechStack", 'TechStackType'>
  }
    

  // Custom InputTypes
  /**
   * TechStack findUnique
   */
  export type TechStackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * Filter, which TechStack to fetch.
     */
    where: TechStackWhereUniqueInput
  }

  /**
   * TechStack findUniqueOrThrow
   */
  export type TechStackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * Filter, which TechStack to fetch.
     */
    where: TechStackWhereUniqueInput
  }

  /**
   * TechStack findFirst
   */
  export type TechStackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * Filter, which TechStack to fetch.
     */
    where?: TechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechStacks to fetch.
     */
    orderBy?: TechStackOrderByWithRelationInput | TechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechStacks.
     */
    cursor?: TechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechStacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechStacks.
     */
    distinct?: TechStackScalarFieldEnum | TechStackScalarFieldEnum[]
  }

  /**
   * TechStack findFirstOrThrow
   */
  export type TechStackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * Filter, which TechStack to fetch.
     */
    where?: TechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechStacks to fetch.
     */
    orderBy?: TechStackOrderByWithRelationInput | TechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechStacks.
     */
    cursor?: TechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechStacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechStacks.
     */
    distinct?: TechStackScalarFieldEnum | TechStackScalarFieldEnum[]
  }

  /**
   * TechStack findMany
   */
  export type TechStackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * Filter, which TechStacks to fetch.
     */
    where?: TechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechStacks to fetch.
     */
    orderBy?: TechStackOrderByWithRelationInput | TechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechStacks.
     */
    cursor?: TechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechStacks.
     */
    skip?: number
    distinct?: TechStackScalarFieldEnum | TechStackScalarFieldEnum[]
  }

  /**
   * TechStack create
   */
  export type TechStackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * The data needed to create a TechStack.
     */
    data: XOR<TechStackCreateInput, TechStackUncheckedCreateInput>
  }

  /**
   * TechStack createMany
   */
  export type TechStackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechStacks.
     */
    data: TechStackCreateManyInput | TechStackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechStack createManyAndReturn
   */
  export type TechStackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * The data used to create many TechStacks.
     */
    data: TechStackCreateManyInput | TechStackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechStack update
   */
  export type TechStackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * The data needed to update a TechStack.
     */
    data: XOR<TechStackUpdateInput, TechStackUncheckedUpdateInput>
    /**
     * Choose, which TechStack to update.
     */
    where: TechStackWhereUniqueInput
  }

  /**
   * TechStack updateMany
   */
  export type TechStackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechStacks.
     */
    data: XOR<TechStackUpdateManyMutationInput, TechStackUncheckedUpdateManyInput>
    /**
     * Filter which TechStacks to update
     */
    where?: TechStackWhereInput
    /**
     * Limit how many TechStacks to update.
     */
    limit?: number
  }

  /**
   * TechStack updateManyAndReturn
   */
  export type TechStackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * The data used to update TechStacks.
     */
    data: XOR<TechStackUpdateManyMutationInput, TechStackUncheckedUpdateManyInput>
    /**
     * Filter which TechStacks to update
     */
    where?: TechStackWhereInput
    /**
     * Limit how many TechStacks to update.
     */
    limit?: number
  }

  /**
   * TechStack upsert
   */
  export type TechStackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * The filter to search for the TechStack to update in case it exists.
     */
    where: TechStackWhereUniqueInput
    /**
     * In case the TechStack found by the `where` argument doesn't exist, create a new TechStack with this data.
     */
    create: XOR<TechStackCreateInput, TechStackUncheckedCreateInput>
    /**
     * In case the TechStack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechStackUpdateInput, TechStackUncheckedUpdateInput>
  }

  /**
   * TechStack delete
   */
  export type TechStackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    /**
     * Filter which TechStack to delete.
     */
    where: TechStackWhereUniqueInput
  }

  /**
   * TechStack deleteMany
   */
  export type TechStackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechStacks to delete
     */
    where?: TechStackWhereInput
    /**
     * Limit how many TechStacks to delete.
     */
    limit?: number
  }

  /**
   * TechStack.projects
   */
  export type TechStack$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * TechStack.projectRoles
   */
  export type TechStack$projectRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    where?: ProjectRoleWhereInput
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    cursor?: ProjectRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * TechStack without action
   */
  export type TechStackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
  }


  /**
   * Model teamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teamMember to aggregate.
     */
    where?: teamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamMembers to fetch.
     */
    orderBy?: teamMemberOrderByWithRelationInput | teamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type teamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamMemberWhereInput
    orderBy?: teamMemberOrderByWithAggregationInput | teamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: teamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    userId: string
    projectId: string
    joinedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends teamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type teamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    joinedAt?: boolean
    projectRole?: boolean | teamMember$projectRoleArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | TeamMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type teamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type teamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type teamMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    joinedAt?: boolean
  }

  export type teamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "projectId" | "joinedAt", ExtArgs["result"]["teamMember"]>
  export type teamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectRole?: boolean | teamMember$projectRoleArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | TeamMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type teamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $teamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teamMember"
    objects: {
      projectRole: Prisma.$ProjectRolePayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      projectId: string
      joinedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type teamMemberGetPayload<S extends boolean | null | undefined | teamMemberDefaultArgs> = $Result.GetResult<Prisma.$teamMemberPayload, S>

  type teamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface teamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teamMember'], meta: { name: 'teamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {teamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamMemberFindUniqueArgs>(args: SelectSubset<T, teamMemberFindUniqueArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, teamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamMemberFindFirstArgs>(args?: SelectSubset<T, teamMemberFindFirstArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, teamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teamMemberFindManyArgs>(args?: SelectSubset<T, teamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {teamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends teamMemberCreateArgs>(args: SelectSubset<T, teamMemberCreateArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {teamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamMemberCreateManyArgs>(args?: SelectSubset<T, teamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {teamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, teamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {teamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends teamMemberDeleteArgs>(args: SelectSubset<T, teamMemberDeleteArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {teamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamMemberUpdateArgs>(args: SelectSubset<T, teamMemberUpdateArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {teamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamMemberDeleteManyArgs>(args?: SelectSubset<T, teamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamMemberUpdateManyArgs>(args: SelectSubset<T, teamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {teamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, teamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {teamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends teamMemberUpsertArgs>(args: SelectSubset<T, teamMemberUpsertArgs<ExtArgs>>): Prisma__teamMemberClient<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends teamMemberCountArgs>(
      args?: Subset<T, teamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamMemberGroupByArgs['orderBy'] }
        : { orderBy?: teamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teamMember model
   */
  readonly fields: teamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectRole<T extends teamMember$projectRoleArgs<ExtArgs> = {}>(args?: Subset<T, teamMember$projectRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teamMember model
   */
  interface teamMemberFieldRefs {
    readonly id: FieldRef<"teamMember", 'String'>
    readonly userId: FieldRef<"teamMember", 'String'>
    readonly projectId: FieldRef<"teamMember", 'String'>
    readonly joinedAt: FieldRef<"teamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teamMember findUnique
   */
  export type teamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * Filter, which teamMember to fetch.
     */
    where: teamMemberWhereUniqueInput
  }

  /**
   * teamMember findUniqueOrThrow
   */
  export type teamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * Filter, which teamMember to fetch.
     */
    where: teamMemberWhereUniqueInput
  }

  /**
   * teamMember findFirst
   */
  export type teamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * Filter, which teamMember to fetch.
     */
    where?: teamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamMembers to fetch.
     */
    orderBy?: teamMemberOrderByWithRelationInput | teamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teamMembers.
     */
    cursor?: teamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * teamMember findFirstOrThrow
   */
  export type teamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * Filter, which teamMember to fetch.
     */
    where?: teamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamMembers to fetch.
     */
    orderBy?: teamMemberOrderByWithRelationInput | teamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teamMembers.
     */
    cursor?: teamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * teamMember findMany
   */
  export type teamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * Filter, which teamMembers to fetch.
     */
    where?: teamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamMembers to fetch.
     */
    orderBy?: teamMemberOrderByWithRelationInput | teamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teamMembers.
     */
    cursor?: teamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * teamMember create
   */
  export type teamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a teamMember.
     */
    data: XOR<teamMemberCreateInput, teamMemberUncheckedCreateInput>
  }

  /**
   * teamMember createMany
   */
  export type teamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teamMembers.
     */
    data: teamMemberCreateManyInput | teamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teamMember createManyAndReturn
   */
  export type teamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many teamMembers.
     */
    data: teamMemberCreateManyInput | teamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teamMember update
   */
  export type teamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a teamMember.
     */
    data: XOR<teamMemberUpdateInput, teamMemberUncheckedUpdateInput>
    /**
     * Choose, which teamMember to update.
     */
    where: teamMemberWhereUniqueInput
  }

  /**
   * teamMember updateMany
   */
  export type teamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teamMembers.
     */
    data: XOR<teamMemberUpdateManyMutationInput, teamMemberUncheckedUpdateManyInput>
    /**
     * Filter which teamMembers to update
     */
    where?: teamMemberWhereInput
    /**
     * Limit how many teamMembers to update.
     */
    limit?: number
  }

  /**
   * teamMember updateManyAndReturn
   */
  export type teamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * The data used to update teamMembers.
     */
    data: XOR<teamMemberUpdateManyMutationInput, teamMemberUncheckedUpdateManyInput>
    /**
     * Filter which teamMembers to update
     */
    where?: teamMemberWhereInput
    /**
     * Limit how many teamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teamMember upsert
   */
  export type teamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the teamMember to update in case it exists.
     */
    where: teamMemberWhereUniqueInput
    /**
     * In case the teamMember found by the `where` argument doesn't exist, create a new teamMember with this data.
     */
    create: XOR<teamMemberCreateInput, teamMemberUncheckedCreateInput>
    /**
     * In case the teamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamMemberUpdateInput, teamMemberUncheckedUpdateInput>
  }

  /**
   * teamMember delete
   */
  export type teamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    /**
     * Filter which teamMember to delete.
     */
    where: teamMemberWhereUniqueInput
  }

  /**
   * teamMember deleteMany
   */
  export type teamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teamMembers to delete
     */
    where?: teamMemberWhereInput
    /**
     * Limit how many teamMembers to delete.
     */
    limit?: number
  }

  /**
   * teamMember.projectRole
   */
  export type teamMember$projectRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    where?: ProjectRoleWhereInput
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    cursor?: ProjectRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * teamMember without action
   */
  export type teamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
  }


  /**
   * Model ProjectRole
   */

  export type AggregateProjectRole = {
    _count: ProjectRoleCountAggregateOutputType | null
    _min: ProjectRoleMinAggregateOutputType | null
    _max: ProjectRoleMaxAggregateOutputType | null
  }

  export type ProjectRoleMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    isFilled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectRoleMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    isFilled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectRoleCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    isFilled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectRoleMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    isFilled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectRoleMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    isFilled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectRoleCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    isFilled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRole to aggregate.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectRoles
    **/
    _count?: true | ProjectRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectRoleMaxAggregateInputType
  }

  export type GetProjectRoleAggregateType<T extends ProjectRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectRole[P]>
      : GetScalarType<T[P], AggregateProjectRole[P]>
  }




  export type ProjectRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleWhereInput
    orderBy?: ProjectRoleOrderByWithAggregationInput | ProjectRoleOrderByWithAggregationInput[]
    by: ProjectRoleScalarFieldEnum[] | ProjectRoleScalarFieldEnum
    having?: ProjectRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectRoleCountAggregateInputType | true
    _min?: ProjectRoleMinAggregateInputType
    _max?: ProjectRoleMaxAggregateInputType
  }

  export type ProjectRoleGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string
    isFilled: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProjectRoleCountAggregateOutputType | null
    _min: ProjectRoleMinAggregateOutputType | null
    _max: ProjectRoleMaxAggregateOutputType | null
  }

  type GetProjectRoleGroupByPayload<T extends ProjectRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectRoleGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectRoleGroupByOutputType[P]>
        }
      >
    >


  export type ProjectRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    isFilled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    techStacks?: boolean | ProjectRole$techStacksArgs<ExtArgs>
    teamMember?: boolean | ProjectRole$teamMemberArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectRoleApplication?: boolean | ProjectRole$projectRoleApplicationArgs<ExtArgs>
    _count?: boolean | ProjectRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRole"]>

  export type ProjectRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    isFilled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRole"]>

  export type ProjectRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    isFilled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRole"]>

  export type ProjectRoleSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    isFilled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "description" | "isFilled" | "createdAt" | "updatedAt", ExtArgs["result"]["projectRole"]>
  export type ProjectRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    techStacks?: boolean | ProjectRole$techStacksArgs<ExtArgs>
    teamMember?: boolean | ProjectRole$teamMemberArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectRoleApplication?: boolean | ProjectRole$projectRoleApplicationArgs<ExtArgs>
    _count?: boolean | ProjectRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectRole"
    objects: {
      techStacks: Prisma.$TechStackPayload<ExtArgs>[]
      teamMember: Prisma.$teamMemberPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
      projectRoleApplication: Prisma.$ProjectRoleApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string
      isFilled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectRole"]>
    composites: {}
  }

  type ProjectRoleGetPayload<S extends boolean | null | undefined | ProjectRoleDefaultArgs> = $Result.GetResult<Prisma.$ProjectRolePayload, S>

  type ProjectRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectRoleCountAggregateInputType | true
    }

  export interface ProjectRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectRole'], meta: { name: 'ProjectRole' } }
    /**
     * Find zero or one ProjectRole that matches the filter.
     * @param {ProjectRoleFindUniqueArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectRoleFindUniqueArgs>(args: SelectSubset<T, ProjectRoleFindUniqueArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectRoleFindUniqueOrThrowArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleFindFirstArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectRoleFindFirstArgs>(args?: SelectSubset<T, ProjectRoleFindFirstArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleFindFirstOrThrowArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectRoles
     * const projectRoles = await prisma.projectRole.findMany()
     * 
     * // Get first 10 ProjectRoles
     * const projectRoles = await prisma.projectRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectRoleWithIdOnly = await prisma.projectRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectRoleFindManyArgs>(args?: SelectSubset<T, ProjectRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectRole.
     * @param {ProjectRoleCreateArgs} args - Arguments to create a ProjectRole.
     * @example
     * // Create one ProjectRole
     * const ProjectRole = await prisma.projectRole.create({
     *   data: {
     *     // ... data to create a ProjectRole
     *   }
     * })
     * 
     */
    create<T extends ProjectRoleCreateArgs>(args: SelectSubset<T, ProjectRoleCreateArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectRoles.
     * @param {ProjectRoleCreateManyArgs} args - Arguments to create many ProjectRoles.
     * @example
     * // Create many ProjectRoles
     * const projectRole = await prisma.projectRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectRoleCreateManyArgs>(args?: SelectSubset<T, ProjectRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectRoles and returns the data saved in the database.
     * @param {ProjectRoleCreateManyAndReturnArgs} args - Arguments to create many ProjectRoles.
     * @example
     * // Create many ProjectRoles
     * const projectRole = await prisma.projectRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectRoles and only return the `id`
     * const projectRoleWithIdOnly = await prisma.projectRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectRole.
     * @param {ProjectRoleDeleteArgs} args - Arguments to delete one ProjectRole.
     * @example
     * // Delete one ProjectRole
     * const ProjectRole = await prisma.projectRole.delete({
     *   where: {
     *     // ... filter to delete one ProjectRole
     *   }
     * })
     * 
     */
    delete<T extends ProjectRoleDeleteArgs>(args: SelectSubset<T, ProjectRoleDeleteArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectRole.
     * @param {ProjectRoleUpdateArgs} args - Arguments to update one ProjectRole.
     * @example
     * // Update one ProjectRole
     * const projectRole = await prisma.projectRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectRoleUpdateArgs>(args: SelectSubset<T, ProjectRoleUpdateArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectRoles.
     * @param {ProjectRoleDeleteManyArgs} args - Arguments to filter ProjectRoles to delete.
     * @example
     * // Delete a few ProjectRoles
     * const { count } = await prisma.projectRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectRoleDeleteManyArgs>(args?: SelectSubset<T, ProjectRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectRoles
     * const projectRole = await prisma.projectRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectRoleUpdateManyArgs>(args: SelectSubset<T, ProjectRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRoles and returns the data updated in the database.
     * @param {ProjectRoleUpdateManyAndReturnArgs} args - Arguments to update many ProjectRoles.
     * @example
     * // Update many ProjectRoles
     * const projectRole = await prisma.projectRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectRoles and only return the `id`
     * const projectRoleWithIdOnly = await prisma.projectRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectRole.
     * @param {ProjectRoleUpsertArgs} args - Arguments to update or create a ProjectRole.
     * @example
     * // Update or create a ProjectRole
     * const projectRole = await prisma.projectRole.upsert({
     *   create: {
     *     // ... data to create a ProjectRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectRole we want to update
     *   }
     * })
     */
    upsert<T extends ProjectRoleUpsertArgs>(args: SelectSubset<T, ProjectRoleUpsertArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleCountArgs} args - Arguments to filter ProjectRoles to count.
     * @example
     * // Count the number of ProjectRoles
     * const count = await prisma.projectRole.count({
     *   where: {
     *     // ... the filter for the ProjectRoles we want to count
     *   }
     * })
    **/
    count<T extends ProjectRoleCountArgs>(
      args?: Subset<T, ProjectRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectRoleAggregateArgs>(args: Subset<T, ProjectRoleAggregateArgs>): Prisma.PrismaPromise<GetProjectRoleAggregateType<T>>

    /**
     * Group by ProjectRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectRoleGroupByArgs['orderBy'] }
        : { orderBy?: ProjectRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectRole model
   */
  readonly fields: ProjectRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    techStacks<T extends ProjectRole$techStacksArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRole$techStacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechStackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMember<T extends ProjectRole$teamMemberArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRole$teamMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectRoleApplication<T extends ProjectRole$projectRoleApplicationArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRole$projectRoleApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectRole model
   */
  interface ProjectRoleFieldRefs {
    readonly id: FieldRef<"ProjectRole", 'String'>
    readonly projectId: FieldRef<"ProjectRole", 'String'>
    readonly title: FieldRef<"ProjectRole", 'String'>
    readonly description: FieldRef<"ProjectRole", 'String'>
    readonly isFilled: FieldRef<"ProjectRole", 'Boolean'>
    readonly createdAt: FieldRef<"ProjectRole", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectRole findUnique
   */
  export type ProjectRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole findUniqueOrThrow
   */
  export type ProjectRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole findFirst
   */
  export type ProjectRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRoles.
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRoles.
     */
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * ProjectRole findFirstOrThrow
   */
  export type ProjectRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRoles.
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRoles.
     */
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * ProjectRole findMany
   */
  export type ProjectRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoles to fetch.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectRoles.
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * ProjectRole create
   */
  export type ProjectRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectRole.
     */
    data: XOR<ProjectRoleCreateInput, ProjectRoleUncheckedCreateInput>
  }

  /**
   * ProjectRole createMany
   */
  export type ProjectRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectRoles.
     */
    data: ProjectRoleCreateManyInput | ProjectRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectRole createManyAndReturn
   */
  export type ProjectRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectRoles.
     */
    data: ProjectRoleCreateManyInput | ProjectRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectRole update
   */
  export type ProjectRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectRole.
     */
    data: XOR<ProjectRoleUpdateInput, ProjectRoleUncheckedUpdateInput>
    /**
     * Choose, which ProjectRole to update.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole updateMany
   */
  export type ProjectRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectRoles.
     */
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRoles to update
     */
    where?: ProjectRoleWhereInput
    /**
     * Limit how many ProjectRoles to update.
     */
    limit?: number
  }

  /**
   * ProjectRole updateManyAndReturn
   */
  export type ProjectRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * The data used to update ProjectRoles.
     */
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRoles to update
     */
    where?: ProjectRoleWhereInput
    /**
     * Limit how many ProjectRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectRole upsert
   */
  export type ProjectRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectRole to update in case it exists.
     */
    where: ProjectRoleWhereUniqueInput
    /**
     * In case the ProjectRole found by the `where` argument doesn't exist, create a new ProjectRole with this data.
     */
    create: XOR<ProjectRoleCreateInput, ProjectRoleUncheckedCreateInput>
    /**
     * In case the ProjectRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectRoleUpdateInput, ProjectRoleUncheckedUpdateInput>
  }

  /**
   * ProjectRole delete
   */
  export type ProjectRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter which ProjectRole to delete.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole deleteMany
   */
  export type ProjectRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRoles to delete
     */
    where?: ProjectRoleWhereInput
    /**
     * Limit how many ProjectRoles to delete.
     */
    limit?: number
  }

  /**
   * ProjectRole.techStacks
   */
  export type ProjectRole$techStacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechStack
     */
    select?: TechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechStack
     */
    omit?: TechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechStackInclude<ExtArgs> | null
    where?: TechStackWhereInput
    orderBy?: TechStackOrderByWithRelationInput | TechStackOrderByWithRelationInput[]
    cursor?: TechStackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechStackScalarFieldEnum | TechStackScalarFieldEnum[]
  }

  /**
   * ProjectRole.teamMember
   */
  export type ProjectRole$teamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamMember
     */
    select?: teamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamMember
     */
    omit?: teamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamMemberInclude<ExtArgs> | null
    where?: teamMemberWhereInput
    orderBy?: teamMemberOrderByWithRelationInput | teamMemberOrderByWithRelationInput[]
    cursor?: teamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * ProjectRole.projectRoleApplication
   */
  export type ProjectRole$projectRoleApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    where?: ProjectRoleApplicationWhereInput
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    cursor?: ProjectRoleApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleApplicationScalarFieldEnum | ProjectRoleApplicationScalarFieldEnum[]
  }

  /**
   * ProjectRole without action
   */
  export type ProjectRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
  }


  /**
   * Model ProjectRoleApplication
   */

  export type AggregateProjectRoleApplication = {
    _count: ProjectRoleApplicationCountAggregateOutputType | null
    _min: ProjectRoleApplicationMinAggregateOutputType | null
    _max: ProjectRoleApplicationMaxAggregateOutputType | null
  }

  export type ProjectRoleApplicationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    projectRoleId: string | null
    projectRoleTitle: string | null
    status: string | null
    motivationLetter: string | null
    rejectionReason: string | null
    appliedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type ProjectRoleApplicationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    projectRoleId: string | null
    projectRoleTitle: string | null
    status: string | null
    motivationLetter: string | null
    rejectionReason: string | null
    appliedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type ProjectRoleApplicationCountAggregateOutputType = {
    id: number
    projectId: number
    projectRoleId: number
    projectRoleTitle: number
    status: number
    motivationLetter: number
    selectedKeyFeatures: number
    selectedProjectGoals: number
    rejectionReason: number
    appliedAt: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type ProjectRoleApplicationMinAggregateInputType = {
    id?: true
    projectId?: true
    projectRoleId?: true
    projectRoleTitle?: true
    status?: true
    motivationLetter?: true
    rejectionReason?: true
    appliedAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type ProjectRoleApplicationMaxAggregateInputType = {
    id?: true
    projectId?: true
    projectRoleId?: true
    projectRoleTitle?: true
    status?: true
    motivationLetter?: true
    rejectionReason?: true
    appliedAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type ProjectRoleApplicationCountAggregateInputType = {
    id?: true
    projectId?: true
    projectRoleId?: true
    projectRoleTitle?: true
    status?: true
    motivationLetter?: true
    selectedKeyFeatures?: true
    selectedProjectGoals?: true
    rejectionReason?: true
    appliedAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type ProjectRoleApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRoleApplication to aggregate.
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoleApplications to fetch.
     */
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectRoleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoleApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectRoleApplications
    **/
    _count?: true | ProjectRoleApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectRoleApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectRoleApplicationMaxAggregateInputType
  }

  export type GetProjectRoleApplicationAggregateType<T extends ProjectRoleApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectRoleApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectRoleApplication[P]>
      : GetScalarType<T[P], AggregateProjectRoleApplication[P]>
  }




  export type ProjectRoleApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleApplicationWhereInput
    orderBy?: ProjectRoleApplicationOrderByWithAggregationInput | ProjectRoleApplicationOrderByWithAggregationInput[]
    by: ProjectRoleApplicationScalarFieldEnum[] | ProjectRoleApplicationScalarFieldEnum
    having?: ProjectRoleApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectRoleApplicationCountAggregateInputType | true
    _min?: ProjectRoleApplicationMinAggregateInputType
    _max?: ProjectRoleApplicationMaxAggregateInputType
  }

  export type ProjectRoleApplicationGroupByOutputType = {
    id: string
    projectId: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter: string | null
    selectedKeyFeatures: string[]
    selectedProjectGoals: string[]
    rejectionReason: string | null
    appliedAt: Date
    createdAt: Date
    updatedAt: Date
    profileId: string
    _count: ProjectRoleApplicationCountAggregateOutputType | null
    _min: ProjectRoleApplicationMinAggregateOutputType | null
    _max: ProjectRoleApplicationMaxAggregateOutputType | null
  }

  type GetProjectRoleApplicationGroupByPayload<T extends ProjectRoleApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectRoleApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectRoleApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectRoleApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectRoleApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectRoleApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    projectRoleId?: boolean
    projectRoleTitle?: boolean
    status?: boolean
    motivationLetter?: boolean
    selectedKeyFeatures?: boolean
    selectedProjectGoals?: boolean
    rejectionReason?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRoleApplication"]>

  export type ProjectRoleApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    projectRoleId?: boolean
    projectRoleTitle?: boolean
    status?: boolean
    motivationLetter?: boolean
    selectedKeyFeatures?: boolean
    selectedProjectGoals?: boolean
    rejectionReason?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRoleApplication"]>

  export type ProjectRoleApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    projectRoleId?: boolean
    projectRoleTitle?: boolean
    status?: boolean
    motivationLetter?: boolean
    selectedKeyFeatures?: boolean
    selectedProjectGoals?: boolean
    rejectionReason?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRoleApplication"]>

  export type ProjectRoleApplicationSelectScalar = {
    id?: boolean
    projectId?: boolean
    projectRoleId?: boolean
    projectRoleTitle?: boolean
    status?: boolean
    motivationLetter?: boolean
    selectedKeyFeatures?: boolean
    selectedProjectGoals?: boolean
    rejectionReason?: boolean
    appliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type ProjectRoleApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "projectRoleId" | "projectRoleTitle" | "status" | "motivationLetter" | "selectedKeyFeatures" | "selectedProjectGoals" | "rejectionReason" | "appliedAt" | "createdAt" | "updatedAt" | "profileId", ExtArgs["result"]["projectRoleApplication"]>
  export type ProjectRoleApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectRoleApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectRoleApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectRoleApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectRoleApplication"
    objects: {
      projectRole: Prisma.$ProjectRolePayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      projectRoleId: string
      projectRoleTitle: string
      status: string
      motivationLetter: string | null
      selectedKeyFeatures: string[]
      selectedProjectGoals: string[]
      rejectionReason: string | null
      appliedAt: Date
      createdAt: Date
      updatedAt: Date
      profileId: string
    }, ExtArgs["result"]["projectRoleApplication"]>
    composites: {}
  }

  type ProjectRoleApplicationGetPayload<S extends boolean | null | undefined | ProjectRoleApplicationDefaultArgs> = $Result.GetResult<Prisma.$ProjectRoleApplicationPayload, S>

  type ProjectRoleApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectRoleApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectRoleApplicationCountAggregateInputType | true
    }

  export interface ProjectRoleApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectRoleApplication'], meta: { name: 'ProjectRoleApplication' } }
    /**
     * Find zero or one ProjectRoleApplication that matches the filter.
     * @param {ProjectRoleApplicationFindUniqueArgs} args - Arguments to find a ProjectRoleApplication
     * @example
     * // Get one ProjectRoleApplication
     * const projectRoleApplication = await prisma.projectRoleApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectRoleApplicationFindUniqueArgs>(args: SelectSubset<T, ProjectRoleApplicationFindUniqueArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectRoleApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectRoleApplicationFindUniqueOrThrowArgs} args - Arguments to find a ProjectRoleApplication
     * @example
     * // Get one ProjectRoleApplication
     * const projectRoleApplication = await prisma.projectRoleApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectRoleApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectRoleApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectRoleApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationFindFirstArgs} args - Arguments to find a ProjectRoleApplication
     * @example
     * // Get one ProjectRoleApplication
     * const projectRoleApplication = await prisma.projectRoleApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectRoleApplicationFindFirstArgs>(args?: SelectSubset<T, ProjectRoleApplicationFindFirstArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectRoleApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationFindFirstOrThrowArgs} args - Arguments to find a ProjectRoleApplication
     * @example
     * // Get one ProjectRoleApplication
     * const projectRoleApplication = await prisma.projectRoleApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectRoleApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectRoleApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectRoleApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectRoleApplications
     * const projectRoleApplications = await prisma.projectRoleApplication.findMany()
     * 
     * // Get first 10 ProjectRoleApplications
     * const projectRoleApplications = await prisma.projectRoleApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectRoleApplicationWithIdOnly = await prisma.projectRoleApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectRoleApplicationFindManyArgs>(args?: SelectSubset<T, ProjectRoleApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectRoleApplication.
     * @param {ProjectRoleApplicationCreateArgs} args - Arguments to create a ProjectRoleApplication.
     * @example
     * // Create one ProjectRoleApplication
     * const ProjectRoleApplication = await prisma.projectRoleApplication.create({
     *   data: {
     *     // ... data to create a ProjectRoleApplication
     *   }
     * })
     * 
     */
    create<T extends ProjectRoleApplicationCreateArgs>(args: SelectSubset<T, ProjectRoleApplicationCreateArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectRoleApplications.
     * @param {ProjectRoleApplicationCreateManyArgs} args - Arguments to create many ProjectRoleApplications.
     * @example
     * // Create many ProjectRoleApplications
     * const projectRoleApplication = await prisma.projectRoleApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectRoleApplicationCreateManyArgs>(args?: SelectSubset<T, ProjectRoleApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectRoleApplications and returns the data saved in the database.
     * @param {ProjectRoleApplicationCreateManyAndReturnArgs} args - Arguments to create many ProjectRoleApplications.
     * @example
     * // Create many ProjectRoleApplications
     * const projectRoleApplication = await prisma.projectRoleApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectRoleApplications and only return the `id`
     * const projectRoleApplicationWithIdOnly = await prisma.projectRoleApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectRoleApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectRoleApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectRoleApplication.
     * @param {ProjectRoleApplicationDeleteArgs} args - Arguments to delete one ProjectRoleApplication.
     * @example
     * // Delete one ProjectRoleApplication
     * const ProjectRoleApplication = await prisma.projectRoleApplication.delete({
     *   where: {
     *     // ... filter to delete one ProjectRoleApplication
     *   }
     * })
     * 
     */
    delete<T extends ProjectRoleApplicationDeleteArgs>(args: SelectSubset<T, ProjectRoleApplicationDeleteArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectRoleApplication.
     * @param {ProjectRoleApplicationUpdateArgs} args - Arguments to update one ProjectRoleApplication.
     * @example
     * // Update one ProjectRoleApplication
     * const projectRoleApplication = await prisma.projectRoleApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectRoleApplicationUpdateArgs>(args: SelectSubset<T, ProjectRoleApplicationUpdateArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectRoleApplications.
     * @param {ProjectRoleApplicationDeleteManyArgs} args - Arguments to filter ProjectRoleApplications to delete.
     * @example
     * // Delete a few ProjectRoleApplications
     * const { count } = await prisma.projectRoleApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectRoleApplicationDeleteManyArgs>(args?: SelectSubset<T, ProjectRoleApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRoleApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectRoleApplications
     * const projectRoleApplication = await prisma.projectRoleApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectRoleApplicationUpdateManyArgs>(args: SelectSubset<T, ProjectRoleApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRoleApplications and returns the data updated in the database.
     * @param {ProjectRoleApplicationUpdateManyAndReturnArgs} args - Arguments to update many ProjectRoleApplications.
     * @example
     * // Update many ProjectRoleApplications
     * const projectRoleApplication = await prisma.projectRoleApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectRoleApplications and only return the `id`
     * const projectRoleApplicationWithIdOnly = await prisma.projectRoleApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectRoleApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectRoleApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectRoleApplication.
     * @param {ProjectRoleApplicationUpsertArgs} args - Arguments to update or create a ProjectRoleApplication.
     * @example
     * // Update or create a ProjectRoleApplication
     * const projectRoleApplication = await prisma.projectRoleApplication.upsert({
     *   create: {
     *     // ... data to create a ProjectRoleApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectRoleApplication we want to update
     *   }
     * })
     */
    upsert<T extends ProjectRoleApplicationUpsertArgs>(args: SelectSubset<T, ProjectRoleApplicationUpsertArgs<ExtArgs>>): Prisma__ProjectRoleApplicationClient<$Result.GetResult<Prisma.$ProjectRoleApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectRoleApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationCountArgs} args - Arguments to filter ProjectRoleApplications to count.
     * @example
     * // Count the number of ProjectRoleApplications
     * const count = await prisma.projectRoleApplication.count({
     *   where: {
     *     // ... the filter for the ProjectRoleApplications we want to count
     *   }
     * })
    **/
    count<T extends ProjectRoleApplicationCountArgs>(
      args?: Subset<T, ProjectRoleApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectRoleApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectRoleApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectRoleApplicationAggregateArgs>(args: Subset<T, ProjectRoleApplicationAggregateArgs>): Prisma.PrismaPromise<GetProjectRoleApplicationAggregateType<T>>

    /**
     * Group by ProjectRoleApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectRoleApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectRoleApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectRoleApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectRoleApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectRoleApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectRoleApplication model
   */
  readonly fields: ProjectRoleApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectRoleApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectRoleApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectRole<T extends ProjectRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRoleDefaultArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectRoleApplication model
   */
  interface ProjectRoleApplicationFieldRefs {
    readonly id: FieldRef<"ProjectRoleApplication", 'String'>
    readonly projectId: FieldRef<"ProjectRoleApplication", 'String'>
    readonly projectRoleId: FieldRef<"ProjectRoleApplication", 'String'>
    readonly projectRoleTitle: FieldRef<"ProjectRoleApplication", 'String'>
    readonly status: FieldRef<"ProjectRoleApplication", 'String'>
    readonly motivationLetter: FieldRef<"ProjectRoleApplication", 'String'>
    readonly selectedKeyFeatures: FieldRef<"ProjectRoleApplication", 'String[]'>
    readonly selectedProjectGoals: FieldRef<"ProjectRoleApplication", 'String[]'>
    readonly rejectionReason: FieldRef<"ProjectRoleApplication", 'String'>
    readonly appliedAt: FieldRef<"ProjectRoleApplication", 'DateTime'>
    readonly createdAt: FieldRef<"ProjectRoleApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectRoleApplication", 'DateTime'>
    readonly profileId: FieldRef<"ProjectRoleApplication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectRoleApplication findUnique
   */
  export type ProjectRoleApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoleApplication to fetch.
     */
    where: ProjectRoleApplicationWhereUniqueInput
  }

  /**
   * ProjectRoleApplication findUniqueOrThrow
   */
  export type ProjectRoleApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoleApplication to fetch.
     */
    where: ProjectRoleApplicationWhereUniqueInput
  }

  /**
   * ProjectRoleApplication findFirst
   */
  export type ProjectRoleApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoleApplication to fetch.
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoleApplications to fetch.
     */
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRoleApplications.
     */
    cursor?: ProjectRoleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoleApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRoleApplications.
     */
    distinct?: ProjectRoleApplicationScalarFieldEnum | ProjectRoleApplicationScalarFieldEnum[]
  }

  /**
   * ProjectRoleApplication findFirstOrThrow
   */
  export type ProjectRoleApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoleApplication to fetch.
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoleApplications to fetch.
     */
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRoleApplications.
     */
    cursor?: ProjectRoleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoleApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRoleApplications.
     */
    distinct?: ProjectRoleApplicationScalarFieldEnum | ProjectRoleApplicationScalarFieldEnum[]
  }

  /**
   * ProjectRoleApplication findMany
   */
  export type ProjectRoleApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoleApplications to fetch.
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoleApplications to fetch.
     */
    orderBy?: ProjectRoleApplicationOrderByWithRelationInput | ProjectRoleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectRoleApplications.
     */
    cursor?: ProjectRoleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoleApplications.
     */
    skip?: number
    distinct?: ProjectRoleApplicationScalarFieldEnum | ProjectRoleApplicationScalarFieldEnum[]
  }

  /**
   * ProjectRoleApplication create
   */
  export type ProjectRoleApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectRoleApplication.
     */
    data: XOR<ProjectRoleApplicationCreateInput, ProjectRoleApplicationUncheckedCreateInput>
  }

  /**
   * ProjectRoleApplication createMany
   */
  export type ProjectRoleApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectRoleApplications.
     */
    data: ProjectRoleApplicationCreateManyInput | ProjectRoleApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectRoleApplication createManyAndReturn
   */
  export type ProjectRoleApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectRoleApplications.
     */
    data: ProjectRoleApplicationCreateManyInput | ProjectRoleApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectRoleApplication update
   */
  export type ProjectRoleApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectRoleApplication.
     */
    data: XOR<ProjectRoleApplicationUpdateInput, ProjectRoleApplicationUncheckedUpdateInput>
    /**
     * Choose, which ProjectRoleApplication to update.
     */
    where: ProjectRoleApplicationWhereUniqueInput
  }

  /**
   * ProjectRoleApplication updateMany
   */
  export type ProjectRoleApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectRoleApplications.
     */
    data: XOR<ProjectRoleApplicationUpdateManyMutationInput, ProjectRoleApplicationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRoleApplications to update
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * Limit how many ProjectRoleApplications to update.
     */
    limit?: number
  }

  /**
   * ProjectRoleApplication updateManyAndReturn
   */
  export type ProjectRoleApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * The data used to update ProjectRoleApplications.
     */
    data: XOR<ProjectRoleApplicationUpdateManyMutationInput, ProjectRoleApplicationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRoleApplications to update
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * Limit how many ProjectRoleApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectRoleApplication upsert
   */
  export type ProjectRoleApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectRoleApplication to update in case it exists.
     */
    where: ProjectRoleApplicationWhereUniqueInput
    /**
     * In case the ProjectRoleApplication found by the `where` argument doesn't exist, create a new ProjectRoleApplication with this data.
     */
    create: XOR<ProjectRoleApplicationCreateInput, ProjectRoleApplicationUncheckedCreateInput>
    /**
     * In case the ProjectRoleApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectRoleApplicationUpdateInput, ProjectRoleApplicationUncheckedUpdateInput>
  }

  /**
   * ProjectRoleApplication delete
   */
  export type ProjectRoleApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
    /**
     * Filter which ProjectRoleApplication to delete.
     */
    where: ProjectRoleApplicationWhereUniqueInput
  }

  /**
   * ProjectRoleApplication deleteMany
   */
  export type ProjectRoleApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRoleApplications to delete
     */
    where?: ProjectRoleApplicationWhereInput
    /**
     * Limit how many ProjectRoleApplications to delete.
     */
    limit?: number
  }

  /**
   * ProjectRoleApplication without action
   */
  export type ProjectRoleApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleApplication
     */
    select?: ProjectRoleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRoleApplication
     */
    omit?: ProjectRoleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleApplicationInclude<ExtArgs> | null
  }


  /**
   * Model UserSocialLink
   */

  export type AggregateUserSocialLink = {
    _count: UserSocialLinkCountAggregateOutputType | null
    _min: UserSocialLinkMinAggregateOutputType | null
    _max: UserSocialLinkMaxAggregateOutputType | null
  }

  export type UserSocialLinkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
  }

  export type UserSocialLinkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
  }

  export type UserSocialLinkCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    url: number
    createdAt: number
    _all: number
  }


  export type UserSocialLinkMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    url?: true
    createdAt?: true
  }

  export type UserSocialLinkMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    url?: true
    createdAt?: true
  }

  export type UserSocialLinkCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    url?: true
    createdAt?: true
    _all?: true
  }

  export type UserSocialLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocialLink to aggregate.
     */
    where?: UserSocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialLinks to fetch.
     */
    orderBy?: UserSocialLinkOrderByWithRelationInput | UserSocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSocialLinks
    **/
    _count?: true | UserSocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSocialLinkMaxAggregateInputType
  }

  export type GetUserSocialLinkAggregateType<T extends UserSocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSocialLink[P]>
      : GetScalarType<T[P], AggregateUserSocialLink[P]>
  }




  export type UserSocialLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialLinkWhereInput
    orderBy?: UserSocialLinkOrderByWithAggregationInput | UserSocialLinkOrderByWithAggregationInput[]
    by: UserSocialLinkScalarFieldEnum[] | UserSocialLinkScalarFieldEnum
    having?: UserSocialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSocialLinkCountAggregateInputType | true
    _min?: UserSocialLinkMinAggregateInputType
    _max?: UserSocialLinkMaxAggregateInputType
  }

  export type UserSocialLinkGroupByOutputType = {
    id: string
    userId: string
    type: string
    url: string
    createdAt: Date
    _count: UserSocialLinkCountAggregateOutputType | null
    _min: UserSocialLinkMinAggregateOutputType | null
    _max: UserSocialLinkMaxAggregateOutputType | null
  }

  type GetUserSocialLinkGroupByPayload<T extends UserSocialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], UserSocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type UserSocialLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocialLink"]>

  export type UserSocialLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocialLink"]>

  export type UserSocialLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocialLink"]>

  export type UserSocialLinkSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
  }

  export type UserSocialLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "url" | "createdAt", ExtArgs["result"]["userSocialLink"]>
  export type UserSocialLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type UserSocialLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type UserSocialLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $UserSocialLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSocialLink"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      url: string
      createdAt: Date
    }, ExtArgs["result"]["userSocialLink"]>
    composites: {}
  }

  type UserSocialLinkGetPayload<S extends boolean | null | undefined | UserSocialLinkDefaultArgs> = $Result.GetResult<Prisma.$UserSocialLinkPayload, S>

  type UserSocialLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSocialLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSocialLinkCountAggregateInputType | true
    }

  export interface UserSocialLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSocialLink'], meta: { name: 'UserSocialLink' } }
    /**
     * Find zero or one UserSocialLink that matches the filter.
     * @param {UserSocialLinkFindUniqueArgs} args - Arguments to find a UserSocialLink
     * @example
     * // Get one UserSocialLink
     * const userSocialLink = await prisma.userSocialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSocialLinkFindUniqueArgs>(args: SelectSubset<T, UserSocialLinkFindUniqueArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSocialLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSocialLinkFindUniqueOrThrowArgs} args - Arguments to find a UserSocialLink
     * @example
     * // Get one UserSocialLink
     * const userSocialLink = await prisma.userSocialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSocialLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSocialLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkFindFirstArgs} args - Arguments to find a UserSocialLink
     * @example
     * // Get one UserSocialLink
     * const userSocialLink = await prisma.userSocialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSocialLinkFindFirstArgs>(args?: SelectSubset<T, UserSocialLinkFindFirstArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkFindFirstOrThrowArgs} args - Arguments to find a UserSocialLink
     * @example
     * // Get one UserSocialLink
     * const userSocialLink = await prisma.userSocialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSocialLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSocialLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSocialLinks
     * const userSocialLinks = await prisma.userSocialLink.findMany()
     * 
     * // Get first 10 UserSocialLinks
     * const userSocialLinks = await prisma.userSocialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSocialLinkWithIdOnly = await prisma.userSocialLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSocialLinkFindManyArgs>(args?: SelectSubset<T, UserSocialLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSocialLink.
     * @param {UserSocialLinkCreateArgs} args - Arguments to create a UserSocialLink.
     * @example
     * // Create one UserSocialLink
     * const UserSocialLink = await prisma.userSocialLink.create({
     *   data: {
     *     // ... data to create a UserSocialLink
     *   }
     * })
     * 
     */
    create<T extends UserSocialLinkCreateArgs>(args: SelectSubset<T, UserSocialLinkCreateArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSocialLinks.
     * @param {UserSocialLinkCreateManyArgs} args - Arguments to create many UserSocialLinks.
     * @example
     * // Create many UserSocialLinks
     * const userSocialLink = await prisma.userSocialLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSocialLinkCreateManyArgs>(args?: SelectSubset<T, UserSocialLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSocialLinks and returns the data saved in the database.
     * @param {UserSocialLinkCreateManyAndReturnArgs} args - Arguments to create many UserSocialLinks.
     * @example
     * // Create many UserSocialLinks
     * const userSocialLink = await prisma.userSocialLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSocialLinks and only return the `id`
     * const userSocialLinkWithIdOnly = await prisma.userSocialLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSocialLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSocialLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSocialLink.
     * @param {UserSocialLinkDeleteArgs} args - Arguments to delete one UserSocialLink.
     * @example
     * // Delete one UserSocialLink
     * const UserSocialLink = await prisma.userSocialLink.delete({
     *   where: {
     *     // ... filter to delete one UserSocialLink
     *   }
     * })
     * 
     */
    delete<T extends UserSocialLinkDeleteArgs>(args: SelectSubset<T, UserSocialLinkDeleteArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSocialLink.
     * @param {UserSocialLinkUpdateArgs} args - Arguments to update one UserSocialLink.
     * @example
     * // Update one UserSocialLink
     * const userSocialLink = await prisma.userSocialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSocialLinkUpdateArgs>(args: SelectSubset<T, UserSocialLinkUpdateArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSocialLinks.
     * @param {UserSocialLinkDeleteManyArgs} args - Arguments to filter UserSocialLinks to delete.
     * @example
     * // Delete a few UserSocialLinks
     * const { count } = await prisma.userSocialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSocialLinkDeleteManyArgs>(args?: SelectSubset<T, UserSocialLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSocialLinks
     * const userSocialLink = await prisma.userSocialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSocialLinkUpdateManyArgs>(args: SelectSubset<T, UserSocialLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocialLinks and returns the data updated in the database.
     * @param {UserSocialLinkUpdateManyAndReturnArgs} args - Arguments to update many UserSocialLinks.
     * @example
     * // Update many UserSocialLinks
     * const userSocialLink = await prisma.userSocialLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSocialLinks and only return the `id`
     * const userSocialLinkWithIdOnly = await prisma.userSocialLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSocialLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSocialLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSocialLink.
     * @param {UserSocialLinkUpsertArgs} args - Arguments to update or create a UserSocialLink.
     * @example
     * // Update or create a UserSocialLink
     * const userSocialLink = await prisma.userSocialLink.upsert({
     *   create: {
     *     // ... data to create a UserSocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSocialLink we want to update
     *   }
     * })
     */
    upsert<T extends UserSocialLinkUpsertArgs>(args: SelectSubset<T, UserSocialLinkUpsertArgs<ExtArgs>>): Prisma__UserSocialLinkClient<$Result.GetResult<Prisma.$UserSocialLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkCountArgs} args - Arguments to filter UserSocialLinks to count.
     * @example
     * // Count the number of UserSocialLinks
     * const count = await prisma.userSocialLink.count({
     *   where: {
     *     // ... the filter for the UserSocialLinks we want to count
     *   }
     * })
    **/
    count<T extends UserSocialLinkCountArgs>(
      args?: Subset<T, UserSocialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSocialLinkAggregateArgs>(args: Subset<T, UserSocialLinkAggregateArgs>): Prisma.PrismaPromise<GetUserSocialLinkAggregateType<T>>

    /**
     * Group by UserSocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSocialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSocialLinkGroupByArgs['orderBy'] }
        : { orderBy?: UserSocialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSocialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSocialLink model
   */
  readonly fields: UserSocialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSocialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSocialLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSocialLink model
   */
  interface UserSocialLinkFieldRefs {
    readonly id: FieldRef<"UserSocialLink", 'String'>
    readonly userId: FieldRef<"UserSocialLink", 'String'>
    readonly type: FieldRef<"UserSocialLink", 'String'>
    readonly url: FieldRef<"UserSocialLink", 'String'>
    readonly createdAt: FieldRef<"UserSocialLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSocialLink findUnique
   */
  export type UserSocialLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialLink to fetch.
     */
    where: UserSocialLinkWhereUniqueInput
  }

  /**
   * UserSocialLink findUniqueOrThrow
   */
  export type UserSocialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialLink to fetch.
     */
    where: UserSocialLinkWhereUniqueInput
  }

  /**
   * UserSocialLink findFirst
   */
  export type UserSocialLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialLink to fetch.
     */
    where?: UserSocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialLinks to fetch.
     */
    orderBy?: UserSocialLinkOrderByWithRelationInput | UserSocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocialLinks.
     */
    cursor?: UserSocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocialLinks.
     */
    distinct?: UserSocialLinkScalarFieldEnum | UserSocialLinkScalarFieldEnum[]
  }

  /**
   * UserSocialLink findFirstOrThrow
   */
  export type UserSocialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialLink to fetch.
     */
    where?: UserSocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialLinks to fetch.
     */
    orderBy?: UserSocialLinkOrderByWithRelationInput | UserSocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocialLinks.
     */
    cursor?: UserSocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocialLinks.
     */
    distinct?: UserSocialLinkScalarFieldEnum | UserSocialLinkScalarFieldEnum[]
  }

  /**
   * UserSocialLink findMany
   */
  export type UserSocialLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialLinks to fetch.
     */
    where?: UserSocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialLinks to fetch.
     */
    orderBy?: UserSocialLinkOrderByWithRelationInput | UserSocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSocialLinks.
     */
    cursor?: UserSocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialLinks.
     */
    skip?: number
    distinct?: UserSocialLinkScalarFieldEnum | UserSocialLinkScalarFieldEnum[]
  }

  /**
   * UserSocialLink create
   */
  export type UserSocialLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSocialLink.
     */
    data: XOR<UserSocialLinkCreateInput, UserSocialLinkUncheckedCreateInput>
  }

  /**
   * UserSocialLink createMany
   */
  export type UserSocialLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSocialLinks.
     */
    data: UserSocialLinkCreateManyInput | UserSocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSocialLink createManyAndReturn
   */
  export type UserSocialLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * The data used to create many UserSocialLinks.
     */
    data: UserSocialLinkCreateManyInput | UserSocialLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSocialLink update
   */
  export type UserSocialLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSocialLink.
     */
    data: XOR<UserSocialLinkUpdateInput, UserSocialLinkUncheckedUpdateInput>
    /**
     * Choose, which UserSocialLink to update.
     */
    where: UserSocialLinkWhereUniqueInput
  }

  /**
   * UserSocialLink updateMany
   */
  export type UserSocialLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSocialLinks.
     */
    data: XOR<UserSocialLinkUpdateManyMutationInput, UserSocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which UserSocialLinks to update
     */
    where?: UserSocialLinkWhereInput
    /**
     * Limit how many UserSocialLinks to update.
     */
    limit?: number
  }

  /**
   * UserSocialLink updateManyAndReturn
   */
  export type UserSocialLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * The data used to update UserSocialLinks.
     */
    data: XOR<UserSocialLinkUpdateManyMutationInput, UserSocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which UserSocialLinks to update
     */
    where?: UserSocialLinkWhereInput
    /**
     * Limit how many UserSocialLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSocialLink upsert
   */
  export type UserSocialLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSocialLink to update in case it exists.
     */
    where: UserSocialLinkWhereUniqueInput
    /**
     * In case the UserSocialLink found by the `where` argument doesn't exist, create a new UserSocialLink with this data.
     */
    create: XOR<UserSocialLinkCreateInput, UserSocialLinkUncheckedCreateInput>
    /**
     * In case the UserSocialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSocialLinkUpdateInput, UserSocialLinkUncheckedUpdateInput>
  }

  /**
   * UserSocialLink delete
   */
  export type UserSocialLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
    /**
     * Filter which UserSocialLink to delete.
     */
    where: UserSocialLinkWhereUniqueInput
  }

  /**
   * UserSocialLink deleteMany
   */
  export type UserSocialLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocialLinks to delete
     */
    where?: UserSocialLinkWhereInput
    /**
     * Limit how many UserSocialLinks to delete.
     */
    limit?: number
  }

  /**
   * UserSocialLink without action
   */
  export type UserSocialLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialLink
     */
    select?: UserSocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialLink
     */
    omit?: UserSocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialLinkInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    projects?: boolean | Category$projectsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | Category$projectsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends Category$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Category$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.projects
   */
  export type Category$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model KeyFeature
   */

  export type AggregateKeyFeature = {
    _count: KeyFeatureCountAggregateOutputType | null
    _min: KeyFeatureMinAggregateOutputType | null
    _max: KeyFeatureMaxAggregateOutputType | null
  }

  export type KeyFeatureMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    feature: string | null
  }

  export type KeyFeatureMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    feature: string | null
  }

  export type KeyFeatureCountAggregateOutputType = {
    id: number
    projectId: number
    feature: number
    _all: number
  }


  export type KeyFeatureMinAggregateInputType = {
    id?: true
    projectId?: true
    feature?: true
  }

  export type KeyFeatureMaxAggregateInputType = {
    id?: true
    projectId?: true
    feature?: true
  }

  export type KeyFeatureCountAggregateInputType = {
    id?: true
    projectId?: true
    feature?: true
    _all?: true
  }

  export type KeyFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyFeature to aggregate.
     */
    where?: KeyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyFeatures to fetch.
     */
    orderBy?: KeyFeatureOrderByWithRelationInput | KeyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeyFeatures
    **/
    _count?: true | KeyFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyFeatureMaxAggregateInputType
  }

  export type GetKeyFeatureAggregateType<T extends KeyFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyFeature[P]>
      : GetScalarType<T[P], AggregateKeyFeature[P]>
  }




  export type KeyFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyFeatureWhereInput
    orderBy?: KeyFeatureOrderByWithAggregationInput | KeyFeatureOrderByWithAggregationInput[]
    by: KeyFeatureScalarFieldEnum[] | KeyFeatureScalarFieldEnum
    having?: KeyFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyFeatureCountAggregateInputType | true
    _min?: KeyFeatureMinAggregateInputType
    _max?: KeyFeatureMaxAggregateInputType
  }

  export type KeyFeatureGroupByOutputType = {
    id: string
    projectId: string
    feature: string
    _count: KeyFeatureCountAggregateOutputType | null
    _min: KeyFeatureMinAggregateOutputType | null
    _max: KeyFeatureMaxAggregateOutputType | null
  }

  type GetKeyFeatureGroupByPayload<T extends KeyFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], KeyFeatureGroupByOutputType[P]>
        }
      >
    >


  export type KeyFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    feature?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyFeature"]>

  export type KeyFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    feature?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyFeature"]>

  export type KeyFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    feature?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyFeature"]>

  export type KeyFeatureSelectScalar = {
    id?: boolean
    projectId?: boolean
    feature?: boolean
  }

  export type KeyFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "feature", ExtArgs["result"]["keyFeature"]>
  export type KeyFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type KeyFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type KeyFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $KeyFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeyFeature"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      feature: string
    }, ExtArgs["result"]["keyFeature"]>
    composites: {}
  }

  type KeyFeatureGetPayload<S extends boolean | null | undefined | KeyFeatureDefaultArgs> = $Result.GetResult<Prisma.$KeyFeaturePayload, S>

  type KeyFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeyFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeyFeatureCountAggregateInputType | true
    }

  export interface KeyFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeyFeature'], meta: { name: 'KeyFeature' } }
    /**
     * Find zero or one KeyFeature that matches the filter.
     * @param {KeyFeatureFindUniqueArgs} args - Arguments to find a KeyFeature
     * @example
     * // Get one KeyFeature
     * const keyFeature = await prisma.keyFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyFeatureFindUniqueArgs>(args: SelectSubset<T, KeyFeatureFindUniqueArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeyFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeyFeatureFindUniqueOrThrowArgs} args - Arguments to find a KeyFeature
     * @example
     * // Get one KeyFeature
     * const keyFeature = await prisma.keyFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, KeyFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureFindFirstArgs} args - Arguments to find a KeyFeature
     * @example
     * // Get one KeyFeature
     * const keyFeature = await prisma.keyFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyFeatureFindFirstArgs>(args?: SelectSubset<T, KeyFeatureFindFirstArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureFindFirstOrThrowArgs} args - Arguments to find a KeyFeature
     * @example
     * // Get one KeyFeature
     * const keyFeature = await prisma.keyFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, KeyFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeyFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyFeatures
     * const keyFeatures = await prisma.keyFeature.findMany()
     * 
     * // Get first 10 KeyFeatures
     * const keyFeatures = await prisma.keyFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyFeatureWithIdOnly = await prisma.keyFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeyFeatureFindManyArgs>(args?: SelectSubset<T, KeyFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeyFeature.
     * @param {KeyFeatureCreateArgs} args - Arguments to create a KeyFeature.
     * @example
     * // Create one KeyFeature
     * const KeyFeature = await prisma.keyFeature.create({
     *   data: {
     *     // ... data to create a KeyFeature
     *   }
     * })
     * 
     */
    create<T extends KeyFeatureCreateArgs>(args: SelectSubset<T, KeyFeatureCreateArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeyFeatures.
     * @param {KeyFeatureCreateManyArgs} args - Arguments to create many KeyFeatures.
     * @example
     * // Create many KeyFeatures
     * const keyFeature = await prisma.keyFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeyFeatureCreateManyArgs>(args?: SelectSubset<T, KeyFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeyFeatures and returns the data saved in the database.
     * @param {KeyFeatureCreateManyAndReturnArgs} args - Arguments to create many KeyFeatures.
     * @example
     * // Create many KeyFeatures
     * const keyFeature = await prisma.keyFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeyFeatures and only return the `id`
     * const keyFeatureWithIdOnly = await prisma.keyFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeyFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, KeyFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeyFeature.
     * @param {KeyFeatureDeleteArgs} args - Arguments to delete one KeyFeature.
     * @example
     * // Delete one KeyFeature
     * const KeyFeature = await prisma.keyFeature.delete({
     *   where: {
     *     // ... filter to delete one KeyFeature
     *   }
     * })
     * 
     */
    delete<T extends KeyFeatureDeleteArgs>(args: SelectSubset<T, KeyFeatureDeleteArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeyFeature.
     * @param {KeyFeatureUpdateArgs} args - Arguments to update one KeyFeature.
     * @example
     * // Update one KeyFeature
     * const keyFeature = await prisma.keyFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeyFeatureUpdateArgs>(args: SelectSubset<T, KeyFeatureUpdateArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeyFeatures.
     * @param {KeyFeatureDeleteManyArgs} args - Arguments to filter KeyFeatures to delete.
     * @example
     * // Delete a few KeyFeatures
     * const { count } = await prisma.keyFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeyFeatureDeleteManyArgs>(args?: SelectSubset<T, KeyFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyFeatures
     * const keyFeature = await prisma.keyFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeyFeatureUpdateManyArgs>(args: SelectSubset<T, KeyFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyFeatures and returns the data updated in the database.
     * @param {KeyFeatureUpdateManyAndReturnArgs} args - Arguments to update many KeyFeatures.
     * @example
     * // Update many KeyFeatures
     * const keyFeature = await prisma.keyFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KeyFeatures and only return the `id`
     * const keyFeatureWithIdOnly = await prisma.keyFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeyFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, KeyFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KeyFeature.
     * @param {KeyFeatureUpsertArgs} args - Arguments to update or create a KeyFeature.
     * @example
     * // Update or create a KeyFeature
     * const keyFeature = await prisma.keyFeature.upsert({
     *   create: {
     *     // ... data to create a KeyFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyFeature we want to update
     *   }
     * })
     */
    upsert<T extends KeyFeatureUpsertArgs>(args: SelectSubset<T, KeyFeatureUpsertArgs<ExtArgs>>): Prisma__KeyFeatureClient<$Result.GetResult<Prisma.$KeyFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeyFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureCountArgs} args - Arguments to filter KeyFeatures to count.
     * @example
     * // Count the number of KeyFeatures
     * const count = await prisma.keyFeature.count({
     *   where: {
     *     // ... the filter for the KeyFeatures we want to count
     *   }
     * })
    **/
    count<T extends KeyFeatureCountArgs>(
      args?: Subset<T, KeyFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyFeatureAggregateArgs>(args: Subset<T, KeyFeatureAggregateArgs>): Prisma.PrismaPromise<GetKeyFeatureAggregateType<T>>

    /**
     * Group by KeyFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyFeatureGroupByArgs['orderBy'] }
        : { orderBy?: KeyFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeyFeature model
   */
  readonly fields: KeyFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeyFeature model
   */
  interface KeyFeatureFieldRefs {
    readonly id: FieldRef<"KeyFeature", 'String'>
    readonly projectId: FieldRef<"KeyFeature", 'String'>
    readonly feature: FieldRef<"KeyFeature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KeyFeature findUnique
   */
  export type KeyFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which KeyFeature to fetch.
     */
    where: KeyFeatureWhereUniqueInput
  }

  /**
   * KeyFeature findUniqueOrThrow
   */
  export type KeyFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which KeyFeature to fetch.
     */
    where: KeyFeatureWhereUniqueInput
  }

  /**
   * KeyFeature findFirst
   */
  export type KeyFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which KeyFeature to fetch.
     */
    where?: KeyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyFeatures to fetch.
     */
    orderBy?: KeyFeatureOrderByWithRelationInput | KeyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyFeatures.
     */
    cursor?: KeyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyFeatures.
     */
    distinct?: KeyFeatureScalarFieldEnum | KeyFeatureScalarFieldEnum[]
  }

  /**
   * KeyFeature findFirstOrThrow
   */
  export type KeyFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which KeyFeature to fetch.
     */
    where?: KeyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyFeatures to fetch.
     */
    orderBy?: KeyFeatureOrderByWithRelationInput | KeyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyFeatures.
     */
    cursor?: KeyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyFeatures.
     */
    distinct?: KeyFeatureScalarFieldEnum | KeyFeatureScalarFieldEnum[]
  }

  /**
   * KeyFeature findMany
   */
  export type KeyFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which KeyFeatures to fetch.
     */
    where?: KeyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyFeatures to fetch.
     */
    orderBy?: KeyFeatureOrderByWithRelationInput | KeyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeyFeatures.
     */
    cursor?: KeyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyFeatures.
     */
    skip?: number
    distinct?: KeyFeatureScalarFieldEnum | KeyFeatureScalarFieldEnum[]
  }

  /**
   * KeyFeature create
   */
  export type KeyFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a KeyFeature.
     */
    data: XOR<KeyFeatureCreateInput, KeyFeatureUncheckedCreateInput>
  }

  /**
   * KeyFeature createMany
   */
  export type KeyFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeyFeatures.
     */
    data: KeyFeatureCreateManyInput | KeyFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeyFeature createManyAndReturn
   */
  export type KeyFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many KeyFeatures.
     */
    data: KeyFeatureCreateManyInput | KeyFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KeyFeature update
   */
  export type KeyFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a KeyFeature.
     */
    data: XOR<KeyFeatureUpdateInput, KeyFeatureUncheckedUpdateInput>
    /**
     * Choose, which KeyFeature to update.
     */
    where: KeyFeatureWhereUniqueInput
  }

  /**
   * KeyFeature updateMany
   */
  export type KeyFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeyFeatures.
     */
    data: XOR<KeyFeatureUpdateManyMutationInput, KeyFeatureUncheckedUpdateManyInput>
    /**
     * Filter which KeyFeatures to update
     */
    where?: KeyFeatureWhereInput
    /**
     * Limit how many KeyFeatures to update.
     */
    limit?: number
  }

  /**
   * KeyFeature updateManyAndReturn
   */
  export type KeyFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * The data used to update KeyFeatures.
     */
    data: XOR<KeyFeatureUpdateManyMutationInput, KeyFeatureUncheckedUpdateManyInput>
    /**
     * Filter which KeyFeatures to update
     */
    where?: KeyFeatureWhereInput
    /**
     * Limit how many KeyFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KeyFeature upsert
   */
  export type KeyFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the KeyFeature to update in case it exists.
     */
    where: KeyFeatureWhereUniqueInput
    /**
     * In case the KeyFeature found by the `where` argument doesn't exist, create a new KeyFeature with this data.
     */
    create: XOR<KeyFeatureCreateInput, KeyFeatureUncheckedCreateInput>
    /**
     * In case the KeyFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyFeatureUpdateInput, KeyFeatureUncheckedUpdateInput>
  }

  /**
   * KeyFeature delete
   */
  export type KeyFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
    /**
     * Filter which KeyFeature to delete.
     */
    where: KeyFeatureWhereUniqueInput
  }

  /**
   * KeyFeature deleteMany
   */
  export type KeyFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyFeatures to delete
     */
    where?: KeyFeatureWhereInput
    /**
     * Limit how many KeyFeatures to delete.
     */
    limit?: number
  }

  /**
   * KeyFeature without action
   */
  export type KeyFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFeature
     */
    select?: KeyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyFeature
     */
    omit?: KeyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFeatureInclude<ExtArgs> | null
  }


  /**
   * Model ProjectGoal
   */

  export type AggregateProjectGoal = {
    _count: ProjectGoalCountAggregateOutputType | null
    _min: ProjectGoalMinAggregateOutputType | null
    _max: ProjectGoalMaxAggregateOutputType | null
  }

  export type ProjectGoalMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    goal: string | null
  }

  export type ProjectGoalMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    goal: string | null
  }

  export type ProjectGoalCountAggregateOutputType = {
    id: number
    projectId: number
    goal: number
    _all: number
  }


  export type ProjectGoalMinAggregateInputType = {
    id?: true
    projectId?: true
    goal?: true
  }

  export type ProjectGoalMaxAggregateInputType = {
    id?: true
    projectId?: true
    goal?: true
  }

  export type ProjectGoalCountAggregateInputType = {
    id?: true
    projectId?: true
    goal?: true
    _all?: true
  }

  export type ProjectGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGoal to aggregate.
     */
    where?: ProjectGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGoals to fetch.
     */
    orderBy?: ProjectGoalOrderByWithRelationInput | ProjectGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectGoals
    **/
    _count?: true | ProjectGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectGoalMaxAggregateInputType
  }

  export type GetProjectGoalAggregateType<T extends ProjectGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectGoal[P]>
      : GetScalarType<T[P], AggregateProjectGoal[P]>
  }




  export type ProjectGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGoalWhereInput
    orderBy?: ProjectGoalOrderByWithAggregationInput | ProjectGoalOrderByWithAggregationInput[]
    by: ProjectGoalScalarFieldEnum[] | ProjectGoalScalarFieldEnum
    having?: ProjectGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectGoalCountAggregateInputType | true
    _min?: ProjectGoalMinAggregateInputType
    _max?: ProjectGoalMaxAggregateInputType
  }

  export type ProjectGoalGroupByOutputType = {
    id: string
    projectId: string
    goal: string
    _count: ProjectGoalCountAggregateOutputType | null
    _min: ProjectGoalMinAggregateOutputType | null
    _max: ProjectGoalMaxAggregateOutputType | null
  }

  type GetProjectGoalGroupByPayload<T extends ProjectGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGoalGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGoalGroupByOutputType[P]>
        }
      >
    >


  export type ProjectGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    goal?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGoal"]>

  export type ProjectGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    goal?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGoal"]>

  export type ProjectGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    goal?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGoal"]>

  export type ProjectGoalSelectScalar = {
    id?: boolean
    projectId?: boolean
    goal?: boolean
  }

  export type ProjectGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "goal", ExtArgs["result"]["projectGoal"]>
  export type ProjectGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectGoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectGoal"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      goal: string
    }, ExtArgs["result"]["projectGoal"]>
    composites: {}
  }

  type ProjectGoalGetPayload<S extends boolean | null | undefined | ProjectGoalDefaultArgs> = $Result.GetResult<Prisma.$ProjectGoalPayload, S>

  type ProjectGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectGoalCountAggregateInputType | true
    }

  export interface ProjectGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectGoal'], meta: { name: 'ProjectGoal' } }
    /**
     * Find zero or one ProjectGoal that matches the filter.
     * @param {ProjectGoalFindUniqueArgs} args - Arguments to find a ProjectGoal
     * @example
     * // Get one ProjectGoal
     * const projectGoal = await prisma.projectGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectGoalFindUniqueArgs>(args: SelectSubset<T, ProjectGoalFindUniqueArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectGoalFindUniqueOrThrowArgs} args - Arguments to find a ProjectGoal
     * @example
     * // Get one ProjectGoal
     * const projectGoal = await prisma.projectGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalFindFirstArgs} args - Arguments to find a ProjectGoal
     * @example
     * // Get one ProjectGoal
     * const projectGoal = await prisma.projectGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectGoalFindFirstArgs>(args?: SelectSubset<T, ProjectGoalFindFirstArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalFindFirstOrThrowArgs} args - Arguments to find a ProjectGoal
     * @example
     * // Get one ProjectGoal
     * const projectGoal = await prisma.projectGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectGoals
     * const projectGoals = await prisma.projectGoal.findMany()
     * 
     * // Get first 10 ProjectGoals
     * const projectGoals = await prisma.projectGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectGoalWithIdOnly = await prisma.projectGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectGoalFindManyArgs>(args?: SelectSubset<T, ProjectGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectGoal.
     * @param {ProjectGoalCreateArgs} args - Arguments to create a ProjectGoal.
     * @example
     * // Create one ProjectGoal
     * const ProjectGoal = await prisma.projectGoal.create({
     *   data: {
     *     // ... data to create a ProjectGoal
     *   }
     * })
     * 
     */
    create<T extends ProjectGoalCreateArgs>(args: SelectSubset<T, ProjectGoalCreateArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectGoals.
     * @param {ProjectGoalCreateManyArgs} args - Arguments to create many ProjectGoals.
     * @example
     * // Create many ProjectGoals
     * const projectGoal = await prisma.projectGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectGoalCreateManyArgs>(args?: SelectSubset<T, ProjectGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectGoals and returns the data saved in the database.
     * @param {ProjectGoalCreateManyAndReturnArgs} args - Arguments to create many ProjectGoals.
     * @example
     * // Create many ProjectGoals
     * const projectGoal = await prisma.projectGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectGoals and only return the `id`
     * const projectGoalWithIdOnly = await prisma.projectGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectGoal.
     * @param {ProjectGoalDeleteArgs} args - Arguments to delete one ProjectGoal.
     * @example
     * // Delete one ProjectGoal
     * const ProjectGoal = await prisma.projectGoal.delete({
     *   where: {
     *     // ... filter to delete one ProjectGoal
     *   }
     * })
     * 
     */
    delete<T extends ProjectGoalDeleteArgs>(args: SelectSubset<T, ProjectGoalDeleteArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectGoal.
     * @param {ProjectGoalUpdateArgs} args - Arguments to update one ProjectGoal.
     * @example
     * // Update one ProjectGoal
     * const projectGoal = await prisma.projectGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectGoalUpdateArgs>(args: SelectSubset<T, ProjectGoalUpdateArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectGoals.
     * @param {ProjectGoalDeleteManyArgs} args - Arguments to filter ProjectGoals to delete.
     * @example
     * // Delete a few ProjectGoals
     * const { count } = await prisma.projectGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectGoalDeleteManyArgs>(args?: SelectSubset<T, ProjectGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectGoals
     * const projectGoal = await prisma.projectGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectGoalUpdateManyArgs>(args: SelectSubset<T, ProjectGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGoals and returns the data updated in the database.
     * @param {ProjectGoalUpdateManyAndReturnArgs} args - Arguments to update many ProjectGoals.
     * @example
     * // Update many ProjectGoals
     * const projectGoal = await prisma.projectGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectGoals and only return the `id`
     * const projectGoalWithIdOnly = await prisma.projectGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectGoal.
     * @param {ProjectGoalUpsertArgs} args - Arguments to update or create a ProjectGoal.
     * @example
     * // Update or create a ProjectGoal
     * const projectGoal = await prisma.projectGoal.upsert({
     *   create: {
     *     // ... data to create a ProjectGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectGoal we want to update
     *   }
     * })
     */
    upsert<T extends ProjectGoalUpsertArgs>(args: SelectSubset<T, ProjectGoalUpsertArgs<ExtArgs>>): Prisma__ProjectGoalClient<$Result.GetResult<Prisma.$ProjectGoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalCountArgs} args - Arguments to filter ProjectGoals to count.
     * @example
     * // Count the number of ProjectGoals
     * const count = await prisma.projectGoal.count({
     *   where: {
     *     // ... the filter for the ProjectGoals we want to count
     *   }
     * })
    **/
    count<T extends ProjectGoalCountArgs>(
      args?: Subset<T, ProjectGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectGoalAggregateArgs>(args: Subset<T, ProjectGoalAggregateArgs>): Prisma.PrismaPromise<GetProjectGoalAggregateType<T>>

    /**
     * Group by ProjectGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGoalGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectGoal model
   */
  readonly fields: ProjectGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectGoal model
   */
  interface ProjectGoalFieldRefs {
    readonly id: FieldRef<"ProjectGoal", 'String'>
    readonly projectId: FieldRef<"ProjectGoal", 'String'>
    readonly goal: FieldRef<"ProjectGoal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectGoal findUnique
   */
  export type ProjectGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGoal to fetch.
     */
    where: ProjectGoalWhereUniqueInput
  }

  /**
   * ProjectGoal findUniqueOrThrow
   */
  export type ProjectGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGoal to fetch.
     */
    where: ProjectGoalWhereUniqueInput
  }

  /**
   * ProjectGoal findFirst
   */
  export type ProjectGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGoal to fetch.
     */
    where?: ProjectGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGoals to fetch.
     */
    orderBy?: ProjectGoalOrderByWithRelationInput | ProjectGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGoals.
     */
    cursor?: ProjectGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGoals.
     */
    distinct?: ProjectGoalScalarFieldEnum | ProjectGoalScalarFieldEnum[]
  }

  /**
   * ProjectGoal findFirstOrThrow
   */
  export type ProjectGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGoal to fetch.
     */
    where?: ProjectGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGoals to fetch.
     */
    orderBy?: ProjectGoalOrderByWithRelationInput | ProjectGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGoals.
     */
    cursor?: ProjectGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGoals.
     */
    distinct?: ProjectGoalScalarFieldEnum | ProjectGoalScalarFieldEnum[]
  }

  /**
   * ProjectGoal findMany
   */
  export type ProjectGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGoals to fetch.
     */
    where?: ProjectGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGoals to fetch.
     */
    orderBy?: ProjectGoalOrderByWithRelationInput | ProjectGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectGoals.
     */
    cursor?: ProjectGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGoals.
     */
    skip?: number
    distinct?: ProjectGoalScalarFieldEnum | ProjectGoalScalarFieldEnum[]
  }

  /**
   * ProjectGoal create
   */
  export type ProjectGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectGoal.
     */
    data: XOR<ProjectGoalCreateInput, ProjectGoalUncheckedCreateInput>
  }

  /**
   * ProjectGoal createMany
   */
  export type ProjectGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectGoals.
     */
    data: ProjectGoalCreateManyInput | ProjectGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectGoal createManyAndReturn
   */
  export type ProjectGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectGoals.
     */
    data: ProjectGoalCreateManyInput | ProjectGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectGoal update
   */
  export type ProjectGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectGoal.
     */
    data: XOR<ProjectGoalUpdateInput, ProjectGoalUncheckedUpdateInput>
    /**
     * Choose, which ProjectGoal to update.
     */
    where: ProjectGoalWhereUniqueInput
  }

  /**
   * ProjectGoal updateMany
   */
  export type ProjectGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectGoals.
     */
    data: XOR<ProjectGoalUpdateManyMutationInput, ProjectGoalUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGoals to update
     */
    where?: ProjectGoalWhereInput
    /**
     * Limit how many ProjectGoals to update.
     */
    limit?: number
  }

  /**
   * ProjectGoal updateManyAndReturn
   */
  export type ProjectGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * The data used to update ProjectGoals.
     */
    data: XOR<ProjectGoalUpdateManyMutationInput, ProjectGoalUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGoals to update
     */
    where?: ProjectGoalWhereInput
    /**
     * Limit how many ProjectGoals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectGoal upsert
   */
  export type ProjectGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectGoal to update in case it exists.
     */
    where: ProjectGoalWhereUniqueInput
    /**
     * In case the ProjectGoal found by the `where` argument doesn't exist, create a new ProjectGoal with this data.
     */
    create: XOR<ProjectGoalCreateInput, ProjectGoalUncheckedCreateInput>
    /**
     * In case the ProjectGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectGoalUpdateInput, ProjectGoalUncheckedUpdateInput>
  }

  /**
   * ProjectGoal delete
   */
  export type ProjectGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
    /**
     * Filter which ProjectGoal to delete.
     */
    where: ProjectGoalWhereUniqueInput
  }

  /**
   * ProjectGoal deleteMany
   */
  export type ProjectGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGoals to delete
     */
    where?: ProjectGoalWhereInput
    /**
     * Limit how many ProjectGoals to delete.
     */
    limit?: number
  }

  /**
   * ProjectGoal without action
   */
  export type ProjectGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGoal
     */
    select?: ProjectGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGoal
     */
    omit?: ProjectGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGoalInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    userId: 'userId',
    name: 'name',
    login: 'login',
    avatarUrl: 'avatarUrl',
    location: 'location',
    company: 'company',
    bio: 'bio',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const UserGitHubCredentialsScalarFieldEnum: {
    userId: 'userId',
    githubAccessToken: 'githubAccessToken',
    githubUserId: 'githubUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserGitHubCredentialsScalarFieldEnum = (typeof UserGitHubCredentialsScalarFieldEnum)[keyof typeof UserGitHubCredentialsScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    title: 'title',
    description: 'description',
    shortDescription: 'shortDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId',
    image: 'image'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectExternalLinkScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    type: 'type',
    url: 'url'
  };

  export type ProjectExternalLinkScalarFieldEnum = (typeof ProjectExternalLinkScalarFieldEnum)[keyof typeof ProjectExternalLinkScalarFieldEnum]


  export const TechStackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iconUrl: 'iconUrl',
    type: 'type'
  };

  export type TechStackScalarFieldEnum = (typeof TechStackScalarFieldEnum)[keyof typeof TechStackScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const ProjectRoleScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    isFilled: 'isFilled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectRoleScalarFieldEnum = (typeof ProjectRoleScalarFieldEnum)[keyof typeof ProjectRoleScalarFieldEnum]


  export const ProjectRoleApplicationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    projectRoleId: 'projectRoleId',
    projectRoleTitle: 'projectRoleTitle',
    status: 'status',
    motivationLetter: 'motivationLetter',
    selectedKeyFeatures: 'selectedKeyFeatures',
    selectedProjectGoals: 'selectedProjectGoals',
    rejectionReason: 'rejectionReason',
    appliedAt: 'appliedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type ProjectRoleApplicationScalarFieldEnum = (typeof ProjectRoleApplicationScalarFieldEnum)[keyof typeof ProjectRoleApplicationScalarFieldEnum]


  export const UserSocialLinkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    url: 'url',
    createdAt: 'createdAt'
  };

  export type UserSocialLinkScalarFieldEnum = (typeof UserSocialLinkScalarFieldEnum)[keyof typeof UserSocialLinkScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const KeyFeatureScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    feature: 'feature'
  };

  export type KeyFeatureScalarFieldEnum = (typeof KeyFeatureScalarFieldEnum)[keyof typeof KeyFeatureScalarFieldEnum]


  export const ProjectGoalScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    goal: 'goal'
  };

  export type ProjectGoalScalarFieldEnum = (typeof ProjectGoalScalarFieldEnum)[keyof typeof ProjectGoalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TechStackType'
   */
  export type EnumTechStackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechStackType'>
    


  /**
   * Reference to a field of type 'TechStackType[]'
   */
  export type ListEnumTechStackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechStackType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    githubCredentials?: XOR<UserGitHubCredentialsNullableScalarRelationFilter, UserGitHubCredentialsWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    githubCredentials?: UserGitHubCredentialsOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    githubCredentials?: XOR<UserGitHubCredentialsNullableScalarRelationFilter, UserGitHubCredentialsWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    userId?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    login?: StringFilter<"Profile"> | string
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    company?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    socialLinks?: UserSocialLinkListRelationFilter
    projects?: ProjectListRelationFilter
    projectRoleApplication?: ProjectRoleApplicationListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    userId?: SortOrder
    name?: SortOrder
    login?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    socialLinks?: UserSocialLinkOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    projectRoleApplication?: ProjectRoleApplicationOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    name?: StringFilter<"Profile"> | string
    login?: StringFilter<"Profile"> | string
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    company?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    socialLinks?: UserSocialLinkListRelationFilter
    projects?: ProjectListRelationFilter
    projectRoleApplication?: ProjectRoleApplicationListRelationFilter
  }, "userId" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    name?: SortOrder
    login?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Profile"> | string
    name?: StringWithAggregatesFilter<"Profile"> | string
    login?: StringWithAggregatesFilter<"Profile"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    company?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type UserGitHubCredentialsWhereInput = {
    AND?: UserGitHubCredentialsWhereInput | UserGitHubCredentialsWhereInput[]
    OR?: UserGitHubCredentialsWhereInput[]
    NOT?: UserGitHubCredentialsWhereInput | UserGitHubCredentialsWhereInput[]
    userId?: StringFilter<"UserGitHubCredentials"> | string
    githubAccessToken?: StringNullableFilter<"UserGitHubCredentials"> | string | null
    githubUserId?: StringNullableFilter<"UserGitHubCredentials"> | string | null
    createdAt?: DateTimeFilter<"UserGitHubCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"UserGitHubCredentials"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserGitHubCredentialsOrderByWithRelationInput = {
    userId?: SortOrder
    githubAccessToken?: SortOrderInput | SortOrder
    githubUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserGitHubCredentialsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserGitHubCredentialsWhereInput | UserGitHubCredentialsWhereInput[]
    OR?: UserGitHubCredentialsWhereInput[]
    NOT?: UserGitHubCredentialsWhereInput | UserGitHubCredentialsWhereInput[]
    githubAccessToken?: StringNullableFilter<"UserGitHubCredentials"> | string | null
    githubUserId?: StringNullableFilter<"UserGitHubCredentials"> | string | null
    createdAt?: DateTimeFilter<"UserGitHubCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"UserGitHubCredentials"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "userId" | "userId">

  export type UserGitHubCredentialsOrderByWithAggregationInput = {
    userId?: SortOrder
    githubAccessToken?: SortOrderInput | SortOrder
    githubUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserGitHubCredentialsCountOrderByAggregateInput
    _max?: UserGitHubCredentialsMaxOrderByAggregateInput
    _min?: UserGitHubCredentialsMinOrderByAggregateInput
  }

  export type UserGitHubCredentialsScalarWhereWithAggregatesInput = {
    AND?: UserGitHubCredentialsScalarWhereWithAggregatesInput | UserGitHubCredentialsScalarWhereWithAggregatesInput[]
    OR?: UserGitHubCredentialsScalarWhereWithAggregatesInput[]
    NOT?: UserGitHubCredentialsScalarWhereWithAggregatesInput | UserGitHubCredentialsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserGitHubCredentials"> | string
    githubAccessToken?: StringNullableWithAggregatesFilter<"UserGitHubCredentials"> | string | null
    githubUserId?: StringNullableWithAggregatesFilter<"UserGitHubCredentials"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserGitHubCredentials"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserGitHubCredentials"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    ownerId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    shortDescription?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    profileId?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    externalLinks?: ProjectExternalLinkListRelationFilter
    techStacks?: TechStackListRelationFilter
    projectMembers?: TeamMemberListRelationFilter
    projectRoles?: ProjectRoleListRelationFilter
    categories?: CategoryListRelationFilter
    keyFeatures?: KeyFeatureListRelationFilter
    projectGoals?: ProjectGoalListRelationFilter
    projectRoleApplication?: ProjectRoleApplicationListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    externalLinks?: ProjectExternalLinkOrderByRelationAggregateInput
    techStacks?: TechStackOrderByRelationAggregateInput
    projectMembers?: teamMemberOrderByRelationAggregateInput
    projectRoles?: ProjectRoleOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    keyFeatures?: KeyFeatureOrderByRelationAggregateInput
    projectGoals?: ProjectGoalOrderByRelationAggregateInput
    projectRoleApplication?: ProjectRoleApplicationOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    ownerId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    shortDescription?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    profileId?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    externalLinks?: ProjectExternalLinkListRelationFilter
    techStacks?: TechStackListRelationFilter
    projectMembers?: TeamMemberListRelationFilter
    projectRoles?: ProjectRoleListRelationFilter
    categories?: CategoryListRelationFilter
    keyFeatures?: KeyFeatureListRelationFilter
    projectGoals?: ProjectGoalListRelationFilter
    projectRoleApplication?: ProjectRoleApplicationListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    ownerId?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    shortDescription?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    profileId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    image?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type ProjectExternalLinkWhereInput = {
    AND?: ProjectExternalLinkWhereInput | ProjectExternalLinkWhereInput[]
    OR?: ProjectExternalLinkWhereInput[]
    NOT?: ProjectExternalLinkWhereInput | ProjectExternalLinkWhereInput[]
    id?: StringFilter<"ProjectExternalLink"> | string
    projectId?: StringFilter<"ProjectExternalLink"> | string
    type?: StringFilter<"ProjectExternalLink"> | string
    url?: StringFilter<"ProjectExternalLink"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectExternalLinkOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectExternalLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectExternalLinkWhereInput | ProjectExternalLinkWhereInput[]
    OR?: ProjectExternalLinkWhereInput[]
    NOT?: ProjectExternalLinkWhereInput | ProjectExternalLinkWhereInput[]
    projectId?: StringFilter<"ProjectExternalLink"> | string
    type?: StringFilter<"ProjectExternalLink"> | string
    url?: StringFilter<"ProjectExternalLink"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectExternalLinkOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    _count?: ProjectExternalLinkCountOrderByAggregateInput
    _max?: ProjectExternalLinkMaxOrderByAggregateInput
    _min?: ProjectExternalLinkMinOrderByAggregateInput
  }

  export type ProjectExternalLinkScalarWhereWithAggregatesInput = {
    AND?: ProjectExternalLinkScalarWhereWithAggregatesInput | ProjectExternalLinkScalarWhereWithAggregatesInput[]
    OR?: ProjectExternalLinkScalarWhereWithAggregatesInput[]
    NOT?: ProjectExternalLinkScalarWhereWithAggregatesInput | ProjectExternalLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectExternalLink"> | string
    projectId?: StringWithAggregatesFilter<"ProjectExternalLink"> | string
    type?: StringWithAggregatesFilter<"ProjectExternalLink"> | string
    url?: StringWithAggregatesFilter<"ProjectExternalLink"> | string
  }

  export type TechStackWhereInput = {
    AND?: TechStackWhereInput | TechStackWhereInput[]
    OR?: TechStackWhereInput[]
    NOT?: TechStackWhereInput | TechStackWhereInput[]
    id?: StringFilter<"TechStack"> | string
    name?: StringFilter<"TechStack"> | string
    iconUrl?: StringFilter<"TechStack"> | string
    type?: EnumTechStackTypeFilter<"TechStack"> | $Enums.TechStackType
    projects?: ProjectListRelationFilter
    projectRoles?: ProjectRoleListRelationFilter
  }

  export type TechStackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iconUrl?: SortOrder
    type?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    projectRoles?: ProjectRoleOrderByRelationAggregateInput
  }

  export type TechStackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TechStackWhereInput | TechStackWhereInput[]
    OR?: TechStackWhereInput[]
    NOT?: TechStackWhereInput | TechStackWhereInput[]
    name?: StringFilter<"TechStack"> | string
    iconUrl?: StringFilter<"TechStack"> | string
    type?: EnumTechStackTypeFilter<"TechStack"> | $Enums.TechStackType
    projects?: ProjectListRelationFilter
    projectRoles?: ProjectRoleListRelationFilter
  }, "id">

  export type TechStackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iconUrl?: SortOrder
    type?: SortOrder
    _count?: TechStackCountOrderByAggregateInput
    _max?: TechStackMaxOrderByAggregateInput
    _min?: TechStackMinOrderByAggregateInput
  }

  export type TechStackScalarWhereWithAggregatesInput = {
    AND?: TechStackScalarWhereWithAggregatesInput | TechStackScalarWhereWithAggregatesInput[]
    OR?: TechStackScalarWhereWithAggregatesInput[]
    NOT?: TechStackScalarWhereWithAggregatesInput | TechStackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TechStack"> | string
    name?: StringWithAggregatesFilter<"TechStack"> | string
    iconUrl?: StringWithAggregatesFilter<"TechStack"> | string
    type?: EnumTechStackTypeWithAggregatesFilter<"TechStack"> | $Enums.TechStackType
  }

  export type teamMemberWhereInput = {
    AND?: teamMemberWhereInput | teamMemberWhereInput[]
    OR?: teamMemberWhereInput[]
    NOT?: teamMemberWhereInput | teamMemberWhereInput[]
    id?: StringFilter<"teamMember"> | string
    userId?: StringFilter<"teamMember"> | string
    projectId?: StringFilter<"teamMember"> | string
    joinedAt?: DateTimeFilter<"teamMember"> | Date | string
    projectRole?: ProjectRoleListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type teamMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    joinedAt?: SortOrder
    projectRole?: ProjectRoleOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type teamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: teamMemberWhereInput | teamMemberWhereInput[]
    OR?: teamMemberWhereInput[]
    NOT?: teamMemberWhereInput | teamMemberWhereInput[]
    userId?: StringFilter<"teamMember"> | string
    projectId?: StringFilter<"teamMember"> | string
    joinedAt?: DateTimeFilter<"teamMember"> | Date | string
    projectRole?: ProjectRoleListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type teamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    joinedAt?: SortOrder
    _count?: teamMemberCountOrderByAggregateInput
    _max?: teamMemberMaxOrderByAggregateInput
    _min?: teamMemberMinOrderByAggregateInput
  }

  export type teamMemberScalarWhereWithAggregatesInput = {
    AND?: teamMemberScalarWhereWithAggregatesInput | teamMemberScalarWhereWithAggregatesInput[]
    OR?: teamMemberScalarWhereWithAggregatesInput[]
    NOT?: teamMemberScalarWhereWithAggregatesInput | teamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"teamMember"> | string
    userId?: StringWithAggregatesFilter<"teamMember"> | string
    projectId?: StringWithAggregatesFilter<"teamMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"teamMember"> | Date | string
  }

  export type ProjectRoleWhereInput = {
    AND?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    OR?: ProjectRoleWhereInput[]
    NOT?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    id?: StringFilter<"ProjectRole"> | string
    projectId?: StringFilter<"ProjectRole"> | string
    title?: StringFilter<"ProjectRole"> | string
    description?: StringFilter<"ProjectRole"> | string
    isFilled?: BoolFilter<"ProjectRole"> | boolean
    createdAt?: DateTimeFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRole"> | Date | string
    techStacks?: TechStackListRelationFilter
    teamMember?: TeamMemberListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    projectRoleApplication?: ProjectRoleApplicationListRelationFilter
  }

  export type ProjectRoleOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isFilled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    techStacks?: TechStackOrderByRelationAggregateInput
    teamMember?: teamMemberOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    projectRoleApplication?: ProjectRoleApplicationOrderByRelationAggregateInput
  }

  export type ProjectRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    OR?: ProjectRoleWhereInput[]
    NOT?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    projectId?: StringFilter<"ProjectRole"> | string
    title?: StringFilter<"ProjectRole"> | string
    description?: StringFilter<"ProjectRole"> | string
    isFilled?: BoolFilter<"ProjectRole"> | boolean
    createdAt?: DateTimeFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRole"> | Date | string
    techStacks?: TechStackListRelationFilter
    teamMember?: TeamMemberListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    projectRoleApplication?: ProjectRoleApplicationListRelationFilter
  }, "id">

  export type ProjectRoleOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isFilled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectRoleCountOrderByAggregateInput
    _max?: ProjectRoleMaxOrderByAggregateInput
    _min?: ProjectRoleMinOrderByAggregateInput
  }

  export type ProjectRoleScalarWhereWithAggregatesInput = {
    AND?: ProjectRoleScalarWhereWithAggregatesInput | ProjectRoleScalarWhereWithAggregatesInput[]
    OR?: ProjectRoleScalarWhereWithAggregatesInput[]
    NOT?: ProjectRoleScalarWhereWithAggregatesInput | ProjectRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectRole"> | string
    projectId?: StringWithAggregatesFilter<"ProjectRole"> | string
    title?: StringWithAggregatesFilter<"ProjectRole"> | string
    description?: StringWithAggregatesFilter<"ProjectRole"> | string
    isFilled?: BoolWithAggregatesFilter<"ProjectRole"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectRole"> | Date | string
  }

  export type ProjectRoleApplicationWhereInput = {
    AND?: ProjectRoleApplicationWhereInput | ProjectRoleApplicationWhereInput[]
    OR?: ProjectRoleApplicationWhereInput[]
    NOT?: ProjectRoleApplicationWhereInput | ProjectRoleApplicationWhereInput[]
    id?: StringFilter<"ProjectRoleApplication"> | string
    projectId?: StringFilter<"ProjectRoleApplication"> | string
    projectRoleId?: StringFilter<"ProjectRoleApplication"> | string
    projectRoleTitle?: StringFilter<"ProjectRoleApplication"> | string
    status?: StringFilter<"ProjectRoleApplication"> | string
    motivationLetter?: StringNullableFilter<"ProjectRoleApplication"> | string | null
    selectedKeyFeatures?: StringNullableListFilter<"ProjectRoleApplication">
    selectedProjectGoals?: StringNullableListFilter<"ProjectRoleApplication">
    rejectionReason?: StringNullableFilter<"ProjectRoleApplication"> | string | null
    appliedAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    createdAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    profileId?: StringFilter<"ProjectRoleApplication"> | string
    projectRole?: XOR<ProjectRoleScalarRelationFilter, ProjectRoleWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectRoleApplicationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectRoleId?: SortOrder
    projectRoleTitle?: SortOrder
    status?: SortOrder
    motivationLetter?: SortOrderInput | SortOrder
    selectedKeyFeatures?: SortOrder
    selectedProjectGoals?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    projectRole?: ProjectRoleOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectRoleApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectRoleApplicationWhereInput | ProjectRoleApplicationWhereInput[]
    OR?: ProjectRoleApplicationWhereInput[]
    NOT?: ProjectRoleApplicationWhereInput | ProjectRoleApplicationWhereInput[]
    projectId?: StringFilter<"ProjectRoleApplication"> | string
    projectRoleId?: StringFilter<"ProjectRoleApplication"> | string
    projectRoleTitle?: StringFilter<"ProjectRoleApplication"> | string
    status?: StringFilter<"ProjectRoleApplication"> | string
    motivationLetter?: StringNullableFilter<"ProjectRoleApplication"> | string | null
    selectedKeyFeatures?: StringNullableListFilter<"ProjectRoleApplication">
    selectedProjectGoals?: StringNullableListFilter<"ProjectRoleApplication">
    rejectionReason?: StringNullableFilter<"ProjectRoleApplication"> | string | null
    appliedAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    createdAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    profileId?: StringFilter<"ProjectRoleApplication"> | string
    projectRole?: XOR<ProjectRoleScalarRelationFilter, ProjectRoleWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectRoleApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectRoleId?: SortOrder
    projectRoleTitle?: SortOrder
    status?: SortOrder
    motivationLetter?: SortOrderInput | SortOrder
    selectedKeyFeatures?: SortOrder
    selectedProjectGoals?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    _count?: ProjectRoleApplicationCountOrderByAggregateInput
    _max?: ProjectRoleApplicationMaxOrderByAggregateInput
    _min?: ProjectRoleApplicationMinOrderByAggregateInput
  }

  export type ProjectRoleApplicationScalarWhereWithAggregatesInput = {
    AND?: ProjectRoleApplicationScalarWhereWithAggregatesInput | ProjectRoleApplicationScalarWhereWithAggregatesInput[]
    OR?: ProjectRoleApplicationScalarWhereWithAggregatesInput[]
    NOT?: ProjectRoleApplicationScalarWhereWithAggregatesInput | ProjectRoleApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectRoleApplication"> | string
    projectId?: StringWithAggregatesFilter<"ProjectRoleApplication"> | string
    projectRoleId?: StringWithAggregatesFilter<"ProjectRoleApplication"> | string
    projectRoleTitle?: StringWithAggregatesFilter<"ProjectRoleApplication"> | string
    status?: StringWithAggregatesFilter<"ProjectRoleApplication"> | string
    motivationLetter?: StringNullableWithAggregatesFilter<"ProjectRoleApplication"> | string | null
    selectedKeyFeatures?: StringNullableListFilter<"ProjectRoleApplication">
    selectedProjectGoals?: StringNullableListFilter<"ProjectRoleApplication">
    rejectionReason?: StringNullableWithAggregatesFilter<"ProjectRoleApplication"> | string | null
    appliedAt?: DateTimeWithAggregatesFilter<"ProjectRoleApplication"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectRoleApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectRoleApplication"> | Date | string
    profileId?: StringWithAggregatesFilter<"ProjectRoleApplication"> | string
  }

  export type UserSocialLinkWhereInput = {
    AND?: UserSocialLinkWhereInput | UserSocialLinkWhereInput[]
    OR?: UserSocialLinkWhereInput[]
    NOT?: UserSocialLinkWhereInput | UserSocialLinkWhereInput[]
    id?: StringFilter<"UserSocialLink"> | string
    userId?: StringFilter<"UserSocialLink"> | string
    type?: StringFilter<"UserSocialLink"> | string
    url?: StringFilter<"UserSocialLink"> | string
    createdAt?: DateTimeFilter<"UserSocialLink"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type UserSocialLinkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserSocialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_type?: UserSocialLinkUserIdTypeCompoundUniqueInput
    AND?: UserSocialLinkWhereInput | UserSocialLinkWhereInput[]
    OR?: UserSocialLinkWhereInput[]
    NOT?: UserSocialLinkWhereInput | UserSocialLinkWhereInput[]
    userId?: StringFilter<"UserSocialLink"> | string
    type?: StringFilter<"UserSocialLink"> | string
    url?: StringFilter<"UserSocialLink"> | string
    createdAt?: DateTimeFilter<"UserSocialLink"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "userId_type">

  export type UserSocialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    _count?: UserSocialLinkCountOrderByAggregateInput
    _max?: UserSocialLinkMaxOrderByAggregateInput
    _min?: UserSocialLinkMinOrderByAggregateInput
  }

  export type UserSocialLinkScalarWhereWithAggregatesInput = {
    AND?: UserSocialLinkScalarWhereWithAggregatesInput | UserSocialLinkScalarWhereWithAggregatesInput[]
    OR?: UserSocialLinkScalarWhereWithAggregatesInput[]
    NOT?: UserSocialLinkScalarWhereWithAggregatesInput | UserSocialLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSocialLink"> | string
    userId?: StringWithAggregatesFilter<"UserSocialLink"> | string
    type?: StringWithAggregatesFilter<"UserSocialLink"> | string
    url?: StringWithAggregatesFilter<"UserSocialLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSocialLink"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    projects?: ProjectListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    projects?: ProjectListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type KeyFeatureWhereInput = {
    AND?: KeyFeatureWhereInput | KeyFeatureWhereInput[]
    OR?: KeyFeatureWhereInput[]
    NOT?: KeyFeatureWhereInput | KeyFeatureWhereInput[]
    id?: StringFilter<"KeyFeature"> | string
    projectId?: StringFilter<"KeyFeature"> | string
    feature?: StringFilter<"KeyFeature"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type KeyFeatureOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type KeyFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeyFeatureWhereInput | KeyFeatureWhereInput[]
    OR?: KeyFeatureWhereInput[]
    NOT?: KeyFeatureWhereInput | KeyFeatureWhereInput[]
    projectId?: StringFilter<"KeyFeature"> | string
    feature?: StringFilter<"KeyFeature"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type KeyFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    _count?: KeyFeatureCountOrderByAggregateInput
    _max?: KeyFeatureMaxOrderByAggregateInput
    _min?: KeyFeatureMinOrderByAggregateInput
  }

  export type KeyFeatureScalarWhereWithAggregatesInput = {
    AND?: KeyFeatureScalarWhereWithAggregatesInput | KeyFeatureScalarWhereWithAggregatesInput[]
    OR?: KeyFeatureScalarWhereWithAggregatesInput[]
    NOT?: KeyFeatureScalarWhereWithAggregatesInput | KeyFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeyFeature"> | string
    projectId?: StringWithAggregatesFilter<"KeyFeature"> | string
    feature?: StringWithAggregatesFilter<"KeyFeature"> | string
  }

  export type ProjectGoalWhereInput = {
    AND?: ProjectGoalWhereInput | ProjectGoalWhereInput[]
    OR?: ProjectGoalWhereInput[]
    NOT?: ProjectGoalWhereInput | ProjectGoalWhereInput[]
    id?: StringFilter<"ProjectGoal"> | string
    projectId?: StringFilter<"ProjectGoal"> | string
    goal?: StringFilter<"ProjectGoal"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectGoalOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    goal?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectGoalWhereInput | ProjectGoalWhereInput[]
    OR?: ProjectGoalWhereInput[]
    NOT?: ProjectGoalWhereInput | ProjectGoalWhereInput[]
    projectId?: StringFilter<"ProjectGoal"> | string
    goal?: StringFilter<"ProjectGoal"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectGoalOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    goal?: SortOrder
    _count?: ProjectGoalCountOrderByAggregateInput
    _max?: ProjectGoalMaxOrderByAggregateInput
    _min?: ProjectGoalMinOrderByAggregateInput
  }

  export type ProjectGoalScalarWhereWithAggregatesInput = {
    AND?: ProjectGoalScalarWhereWithAggregatesInput | ProjectGoalScalarWhereWithAggregatesInput[]
    OR?: ProjectGoalScalarWhereWithAggregatesInput[]
    NOT?: ProjectGoalScalarWhereWithAggregatesInput | ProjectGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectGoal"> | string
    projectId?: StringWithAggregatesFilter<"ProjectGoal"> | string
    goal?: StringWithAggregatesFilter<"ProjectGoal"> | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    githubCredentials?: UserGitHubCredentialsCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    githubCredentials?: UserGitHubCredentialsUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubCredentials?: UserGitHubCredentialsUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubCredentials?: UserGitHubCredentialsUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProfileInput
    socialLinks?: UserSocialLinkCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    userId: string
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    socialLinks?: UserSocialLinkUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProfileNestedInput
    socialLinks?: UserSocialLinkUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserSocialLinkUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    userId: string
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGitHubCredentialsCreateInput = {
    githubAccessToken?: string | null
    githubUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutGithubCredentialsInput
  }

  export type UserGitHubCredentialsUncheckedCreateInput = {
    userId: string
    githubAccessToken?: string | null
    githubUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGitHubCredentialsUpdateInput = {
    githubAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGithubCredentialsNestedInput
  }

  export type UserGitHubCredentialsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    githubAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGitHubCredentialsCreateManyInput = {
    userId: string
    githubAccessToken?: string | null
    githubUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGitHubCredentialsUpdateManyMutationInput = {
    githubAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGitHubCredentialsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    githubAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectExternalLinkCreateInput = {
    id?: string
    type: string
    url: string
    project: ProjectCreateNestedOneWithoutExternalLinksInput
  }

  export type ProjectExternalLinkUncheckedCreateInput = {
    id?: string
    projectId: string
    type: string
    url: string
  }

  export type ProjectExternalLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutExternalLinksNestedInput
  }

  export type ProjectExternalLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectExternalLinkCreateManyInput = {
    id?: string
    projectId: string
    type: string
    url: string
  }

  export type ProjectExternalLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectExternalLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type TechStackCreateInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    projects?: ProjectCreateNestedManyWithoutTechStacksInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutTechStacksInput
  }

  export type TechStackUncheckedCreateInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    projects?: ProjectUncheckedCreateNestedManyWithoutTechStacksInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutTechStacksInput
  }

  export type TechStackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
    projects?: ProjectUpdateManyWithoutTechStacksNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutTechStacksNestedInput
  }

  export type TechStackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
    projects?: ProjectUncheckedUpdateManyWithoutTechStacksNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutTechStacksNestedInput
  }

  export type TechStackCreateManyInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
  }

  export type TechStackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
  }

  export type TechStackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
  }

  export type teamMemberCreateInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    projectRole?: ProjectRoleCreateNestedManyWithoutTeamMemberInput
    project: ProjectCreateNestedOneWithoutProjectMembersInput
  }

  export type teamMemberUncheckedCreateInput = {
    id?: string
    userId: string
    projectId: string
    joinedAt?: Date | string
    projectRole?: ProjectRoleUncheckedCreateNestedManyWithoutTeamMemberInput
  }

  export type teamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUpdateManyWithoutTeamMemberNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type teamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUncheckedUpdateManyWithoutTeamMemberNestedInput
  }

  export type teamMemberCreateManyInput = {
    id?: string
    userId: string
    projectId: string
    joinedAt?: Date | string
  }

  export type teamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleCreateInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackCreateNestedManyWithoutProjectRolesInput
    teamMember?: teamMemberCreateNestedManyWithoutProjectRoleInput
    project: ProjectCreateNestedOneWithoutProjectRolesInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectRolesInput
    teamMember?: teamMemberUncheckedCreateNestedManyWithoutProjectRoleInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUpdateManyWithoutProjectRolesNestedInput
    teamMember?: teamMemberUpdateManyWithoutProjectRoleNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRolesNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectRolesNestedInput
    teamMember?: teamMemberUncheckedUpdateManyWithoutProjectRoleNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleApplicationCreateInput = {
    id?: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectRole: ProjectRoleCreateNestedOneWithoutProjectRoleApplicationInput
    profile: ProfileCreateNestedOneWithoutProjectRoleApplicationInput
    project: ProjectCreateNestedOneWithoutProjectRoleApplicationInput
  }

  export type ProjectRoleApplicationUncheckedCreateInput = {
    id?: string
    projectId: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type ProjectRoleApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
    profile?: ProfileUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
  }

  export type ProjectRoleApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectRoleId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectRoleApplicationCreateManyInput = {
    id?: string
    projectId: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type ProjectRoleApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectRoleId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialLinkCreateInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutSocialLinksInput
  }

  export type UserSocialLinkUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    url: string
    createdAt?: Date | string
  }

  export type UserSocialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSocialLinksNestedInput
  }

  export type UserSocialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialLinkCreateManyInput = {
    id?: string
    userId: string
    type: string
    url: string
    createdAt?: Date | string
  }

  export type UserSocialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    projects?: ProjectCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    projects?: ProjectUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFeatureCreateInput = {
    id?: string
    feature: string
    project: ProjectCreateNestedOneWithoutKeyFeaturesInput
  }

  export type KeyFeatureUncheckedCreateInput = {
    id?: string
    projectId: string
    feature: string
  }

  export type KeyFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutKeyFeaturesNestedInput
  }

  export type KeyFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFeatureCreateManyInput = {
    id?: string
    projectId: string
    feature: string
  }

  export type KeyFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectGoalCreateInput = {
    id?: string
    goal: string
    project: ProjectCreateNestedOneWithoutProjectGoalsInput
  }

  export type ProjectGoalUncheckedCreateInput = {
    id?: string
    projectId: string
    goal: string
  }

  export type ProjectGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectGoalsNestedInput
  }

  export type ProjectGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectGoalCreateManyInput = {
    id?: string
    projectId: string
    goal: string
  }

  export type ProjectGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserGitHubCredentialsNullableScalarRelationFilter = {
    is?: UserGitHubCredentialsWhereInput | null
    isNot?: UserGitHubCredentialsWhereInput | null
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserSocialLinkListRelationFilter = {
    every?: UserSocialLinkWhereInput
    some?: UserSocialLinkWhereInput
    none?: UserSocialLinkWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectRoleApplicationListRelationFilter = {
    every?: ProjectRoleApplicationWhereInput
    some?: ProjectRoleApplicationWhereInput
    none?: ProjectRoleApplicationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserSocialLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectRoleApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    name?: SortOrder
    login?: SortOrder
    avatarUrl?: SortOrder
    location?: SortOrder
    company?: SortOrder
    bio?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    name?: SortOrder
    login?: SortOrder
    avatarUrl?: SortOrder
    location?: SortOrder
    company?: SortOrder
    bio?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    name?: SortOrder
    login?: SortOrder
    avatarUrl?: SortOrder
    location?: SortOrder
    company?: SortOrder
    bio?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserGitHubCredentialsCountOrderByAggregateInput = {
    userId?: SortOrder
    githubAccessToken?: SortOrder
    githubUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGitHubCredentialsMaxOrderByAggregateInput = {
    userId?: SortOrder
    githubAccessToken?: SortOrder
    githubUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGitHubCredentialsMinOrderByAggregateInput = {
    userId?: SortOrder
    githubAccessToken?: SortOrder
    githubUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectExternalLinkListRelationFilter = {
    every?: ProjectExternalLinkWhereInput
    some?: ProjectExternalLinkWhereInput
    none?: ProjectExternalLinkWhereInput
  }

  export type TechStackListRelationFilter = {
    every?: TechStackWhereInput
    some?: TechStackWhereInput
    none?: TechStackWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: teamMemberWhereInput
    some?: teamMemberWhereInput
    none?: teamMemberWhereInput
  }

  export type ProjectRoleListRelationFilter = {
    every?: ProjectRoleWhereInput
    some?: ProjectRoleWhereInput
    none?: ProjectRoleWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type KeyFeatureListRelationFilter = {
    every?: KeyFeatureWhereInput
    some?: KeyFeatureWhereInput
    none?: KeyFeatureWhereInput
  }

  export type ProjectGoalListRelationFilter = {
    every?: ProjectGoalWhereInput
    some?: ProjectGoalWhereInput
    none?: ProjectGoalWhereInput
  }

  export type ProjectExternalLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechStackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeyFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    image?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    image?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    image?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectExternalLinkCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
  }

  export type ProjectExternalLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
  }

  export type ProjectExternalLinkMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    url?: SortOrder
  }

  export type EnumTechStackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TechStackType | EnumTechStackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechStackTypeFilter<$PrismaModel> | $Enums.TechStackType
  }

  export type TechStackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iconUrl?: SortOrder
    type?: SortOrder
  }

  export type TechStackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iconUrl?: SortOrder
    type?: SortOrder
  }

  export type TechStackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iconUrl?: SortOrder
    type?: SortOrder
  }

  export type EnumTechStackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechStackType | EnumTechStackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechStackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TechStackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechStackTypeFilter<$PrismaModel>
    _max?: NestedEnumTechStackTypeFilter<$PrismaModel>
  }

  export type teamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    joinedAt?: SortOrder
  }

  export type teamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    joinedAt?: SortOrder
  }

  export type teamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    joinedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProjectRoleCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isFilled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isFilled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectRoleMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isFilled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProjectRoleScalarRelationFilter = {
    is?: ProjectRoleWhereInput
    isNot?: ProjectRoleWhereInput
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ProjectRoleApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectRoleId?: SortOrder
    projectRoleTitle?: SortOrder
    status?: SortOrder
    motivationLetter?: SortOrder
    selectedKeyFeatures?: SortOrder
    selectedProjectGoals?: SortOrder
    rejectionReason?: SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type ProjectRoleApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectRoleId?: SortOrder
    projectRoleTitle?: SortOrder
    status?: SortOrder
    motivationLetter?: SortOrder
    rejectionReason?: SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type ProjectRoleApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectRoleId?: SortOrder
    projectRoleTitle?: SortOrder
    status?: SortOrder
    motivationLetter?: SortOrder
    rejectionReason?: SortOrder
    appliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserSocialLinkUserIdTypeCompoundUniqueInput = {
    userId: string
    type: string
  }

  export type UserSocialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSocialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSocialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type KeyFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
  }

  export type KeyFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
  }

  export type KeyFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
  }

  export type ProjectGoalCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    goal?: SortOrder
  }

  export type ProjectGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    goal?: SortOrder
  }

  export type ProjectGoalMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    goal?: SortOrder
  }

  export type UserGitHubCredentialsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserGitHubCredentialsCreateWithoutUserInput, UserGitHubCredentialsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGitHubCredentialsCreateOrConnectWithoutUserInput
    connect?: UserGitHubCredentialsWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserGitHubCredentialsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserGitHubCredentialsCreateWithoutUserInput, UserGitHubCredentialsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGitHubCredentialsCreateOrConnectWithoutUserInput
    connect?: UserGitHubCredentialsWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserGitHubCredentialsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserGitHubCredentialsCreateWithoutUserInput, UserGitHubCredentialsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGitHubCredentialsCreateOrConnectWithoutUserInput
    upsert?: UserGitHubCredentialsUpsertWithoutUserInput
    disconnect?: UserGitHubCredentialsWhereInput | boolean
    delete?: UserGitHubCredentialsWhereInput | boolean
    connect?: UserGitHubCredentialsWhereUniqueInput
    update?: XOR<XOR<UserGitHubCredentialsUpdateToOneWithWhereWithoutUserInput, UserGitHubCredentialsUpdateWithoutUserInput>, UserGitHubCredentialsUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserGitHubCredentialsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserGitHubCredentialsCreateWithoutUserInput, UserGitHubCredentialsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGitHubCredentialsCreateOrConnectWithoutUserInput
    upsert?: UserGitHubCredentialsUpsertWithoutUserInput
    disconnect?: UserGitHubCredentialsWhereInput | boolean
    delete?: UserGitHubCredentialsWhereInput | boolean
    connect?: UserGitHubCredentialsWhereUniqueInput
    update?: XOR<XOR<UserGitHubCredentialsUpdateToOneWithWhereWithoutUserInput, UserGitHubCredentialsUpdateWithoutUserInput>, UserGitHubCredentialsUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserSocialLinkCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserSocialLinkCreateWithoutProfileInput, UserSocialLinkUncheckedCreateWithoutProfileInput> | UserSocialLinkCreateWithoutProfileInput[] | UserSocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserSocialLinkCreateOrConnectWithoutProfileInput | UserSocialLinkCreateOrConnectWithoutProfileInput[]
    createMany?: UserSocialLinkCreateManyProfileInputEnvelope
    connect?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectRoleApplicationCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProfileInput, ProjectRoleApplicationUncheckedCreateWithoutProfileInput> | ProjectRoleApplicationCreateWithoutProfileInput[] | ProjectRoleApplicationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProfileInput | ProjectRoleApplicationCreateOrConnectWithoutProfileInput[]
    createMany?: ProjectRoleApplicationCreateManyProfileInputEnvelope
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
  }

  export type UserSocialLinkUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserSocialLinkCreateWithoutProfileInput, UserSocialLinkUncheckedCreateWithoutProfileInput> | UserSocialLinkCreateWithoutProfileInput[] | UserSocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserSocialLinkCreateOrConnectWithoutProfileInput | UserSocialLinkCreateOrConnectWithoutProfileInput[]
    createMany?: UserSocialLinkCreateManyProfileInputEnvelope
    connect?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectRoleApplicationUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProfileInput, ProjectRoleApplicationUncheckedCreateWithoutProfileInput> | ProjectRoleApplicationCreateWithoutProfileInput[] | ProjectRoleApplicationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProfileInput | ProjectRoleApplicationCreateOrConnectWithoutProfileInput[]
    createMany?: ProjectRoleApplicationCreateManyProfileInputEnvelope
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserSocialLinkUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserSocialLinkCreateWithoutProfileInput, UserSocialLinkUncheckedCreateWithoutProfileInput> | UserSocialLinkCreateWithoutProfileInput[] | UserSocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserSocialLinkCreateOrConnectWithoutProfileInput | UserSocialLinkCreateOrConnectWithoutProfileInput[]
    upsert?: UserSocialLinkUpsertWithWhereUniqueWithoutProfileInput | UserSocialLinkUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserSocialLinkCreateManyProfileInputEnvelope
    set?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    disconnect?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    delete?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    connect?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    update?: UserSocialLinkUpdateWithWhereUniqueWithoutProfileInput | UserSocialLinkUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserSocialLinkUpdateManyWithWhereWithoutProfileInput | UserSocialLinkUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserSocialLinkScalarWhereInput | UserSocialLinkScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProfileInput | ProjectUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProfileInput | ProjectUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProfileInput | ProjectUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectRoleApplicationUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProfileInput, ProjectRoleApplicationUncheckedCreateWithoutProfileInput> | ProjectRoleApplicationCreateWithoutProfileInput[] | ProjectRoleApplicationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProfileInput | ProjectRoleApplicationCreateOrConnectWithoutProfileInput[]
    upsert?: ProjectRoleApplicationUpsertWithWhereUniqueWithoutProfileInput | ProjectRoleApplicationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProjectRoleApplicationCreateManyProfileInputEnvelope
    set?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    disconnect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    delete?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    update?: ProjectRoleApplicationUpdateWithWhereUniqueWithoutProfileInput | ProjectRoleApplicationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProjectRoleApplicationUpdateManyWithWhereWithoutProfileInput | ProjectRoleApplicationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
  }

  export type UserSocialLinkUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserSocialLinkCreateWithoutProfileInput, UserSocialLinkUncheckedCreateWithoutProfileInput> | UserSocialLinkCreateWithoutProfileInput[] | UserSocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserSocialLinkCreateOrConnectWithoutProfileInput | UserSocialLinkCreateOrConnectWithoutProfileInput[]
    upsert?: UserSocialLinkUpsertWithWhereUniqueWithoutProfileInput | UserSocialLinkUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserSocialLinkCreateManyProfileInputEnvelope
    set?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    disconnect?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    delete?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    connect?: UserSocialLinkWhereUniqueInput | UserSocialLinkWhereUniqueInput[]
    update?: UserSocialLinkUpdateWithWhereUniqueWithoutProfileInput | UserSocialLinkUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserSocialLinkUpdateManyWithWhereWithoutProfileInput | UserSocialLinkUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserSocialLinkScalarWhereInput | UserSocialLinkScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProfileInput | ProjectUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProfileInput | ProjectUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProfileInput | ProjectUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectRoleApplicationUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProfileInput, ProjectRoleApplicationUncheckedCreateWithoutProfileInput> | ProjectRoleApplicationCreateWithoutProfileInput[] | ProjectRoleApplicationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProfileInput | ProjectRoleApplicationCreateOrConnectWithoutProfileInput[]
    upsert?: ProjectRoleApplicationUpsertWithWhereUniqueWithoutProfileInput | ProjectRoleApplicationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProjectRoleApplicationCreateManyProfileInputEnvelope
    set?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    disconnect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    delete?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    update?: ProjectRoleApplicationUpdateWithWhereUniqueWithoutProfileInput | ProjectRoleApplicationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProjectRoleApplicationUpdateManyWithWhereWithoutProfileInput | ProjectRoleApplicationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGithubCredentialsInput = {
    create?: XOR<UserCreateWithoutGithubCredentialsInput, UserUncheckedCreateWithoutGithubCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGithubCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutGithubCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutGithubCredentialsInput, UserUncheckedCreateWithoutGithubCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGithubCredentialsInput
    upsert?: UserUpsertWithoutGithubCredentialsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGithubCredentialsInput, UserUpdateWithoutGithubCredentialsInput>, UserUncheckedUpdateWithoutGithubCredentialsInput>
  }

  export type ProjectExternalLinkCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectExternalLinkCreateWithoutProjectInput, ProjectExternalLinkUncheckedCreateWithoutProjectInput> | ProjectExternalLinkCreateWithoutProjectInput[] | ProjectExternalLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectExternalLinkCreateOrConnectWithoutProjectInput | ProjectExternalLinkCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectExternalLinkCreateManyProjectInputEnvelope
    connect?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
  }

  export type TechStackCreateNestedManyWithoutProjectsInput = {
    create?: XOR<TechStackCreateWithoutProjectsInput, TechStackUncheckedCreateWithoutProjectsInput> | TechStackCreateWithoutProjectsInput[] | TechStackUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectsInput | TechStackCreateOrConnectWithoutProjectsInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
  }

  export type teamMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<teamMemberCreateWithoutProjectInput, teamMemberUncheckedCreateWithoutProjectInput> | teamMemberCreateWithoutProjectInput[] | teamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectInput | teamMemberCreateOrConnectWithoutProjectInput[]
    createMany?: teamMemberCreateManyProjectInputEnvelope
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
  }

  export type ProjectRoleCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectInput, ProjectRoleUncheckedCreateWithoutProjectInput> | ProjectRoleCreateWithoutProjectInput[] | ProjectRoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectInput | ProjectRoleCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectRoleCreateManyProjectInputEnvelope
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutProjectsInput = {
    create?: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput> | CategoryCreateWithoutProjectsInput[] | CategoryUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectsInput | CategoryCreateOrConnectWithoutProjectsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type KeyFeatureCreateNestedManyWithoutProjectInput = {
    create?: XOR<KeyFeatureCreateWithoutProjectInput, KeyFeatureUncheckedCreateWithoutProjectInput> | KeyFeatureCreateWithoutProjectInput[] | KeyFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyFeatureCreateOrConnectWithoutProjectInput | KeyFeatureCreateOrConnectWithoutProjectInput[]
    createMany?: KeyFeatureCreateManyProjectInputEnvelope
    connect?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
  }

  export type ProjectGoalCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectGoalCreateWithoutProjectInput, ProjectGoalUncheckedCreateWithoutProjectInput> | ProjectGoalCreateWithoutProjectInput[] | ProjectGoalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGoalCreateOrConnectWithoutProjectInput | ProjectGoalCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectGoalCreateManyProjectInputEnvelope
    connect?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
  }

  export type ProjectRoleApplicationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectInput, ProjectRoleApplicationUncheckedCreateWithoutProjectInput> | ProjectRoleApplicationCreateWithoutProjectInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectInput | ProjectRoleApplicationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectInputEnvelope
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProjectsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectExternalLinkCreateWithoutProjectInput, ProjectExternalLinkUncheckedCreateWithoutProjectInput> | ProjectExternalLinkCreateWithoutProjectInput[] | ProjectExternalLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectExternalLinkCreateOrConnectWithoutProjectInput | ProjectExternalLinkCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectExternalLinkCreateManyProjectInputEnvelope
    connect?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
  }

  export type TechStackUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<TechStackCreateWithoutProjectsInput, TechStackUncheckedCreateWithoutProjectsInput> | TechStackCreateWithoutProjectsInput[] | TechStackUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectsInput | TechStackCreateOrConnectWithoutProjectsInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
  }

  export type teamMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<teamMemberCreateWithoutProjectInput, teamMemberUncheckedCreateWithoutProjectInput> | teamMemberCreateWithoutProjectInput[] | teamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectInput | teamMemberCreateOrConnectWithoutProjectInput[]
    createMany?: teamMemberCreateManyProjectInputEnvelope
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
  }

  export type ProjectRoleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectInput, ProjectRoleUncheckedCreateWithoutProjectInput> | ProjectRoleCreateWithoutProjectInput[] | ProjectRoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectInput | ProjectRoleCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectRoleCreateManyProjectInputEnvelope
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput> | CategoryCreateWithoutProjectsInput[] | CategoryUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectsInput | CategoryCreateOrConnectWithoutProjectsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type KeyFeatureUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<KeyFeatureCreateWithoutProjectInput, KeyFeatureUncheckedCreateWithoutProjectInput> | KeyFeatureCreateWithoutProjectInput[] | KeyFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyFeatureCreateOrConnectWithoutProjectInput | KeyFeatureCreateOrConnectWithoutProjectInput[]
    createMany?: KeyFeatureCreateManyProjectInputEnvelope
    connect?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
  }

  export type ProjectGoalUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectGoalCreateWithoutProjectInput, ProjectGoalUncheckedCreateWithoutProjectInput> | ProjectGoalCreateWithoutProjectInput[] | ProjectGoalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGoalCreateOrConnectWithoutProjectInput | ProjectGoalCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectGoalCreateManyProjectInputEnvelope
    connect?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
  }

  export type ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectInput, ProjectRoleApplicationUncheckedCreateWithoutProjectInput> | ProjectRoleApplicationCreateWithoutProjectInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectInput | ProjectRoleApplicationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectInputEnvelope
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
  }

  export type ProjectExternalLinkUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectExternalLinkCreateWithoutProjectInput, ProjectExternalLinkUncheckedCreateWithoutProjectInput> | ProjectExternalLinkCreateWithoutProjectInput[] | ProjectExternalLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectExternalLinkCreateOrConnectWithoutProjectInput | ProjectExternalLinkCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectExternalLinkUpsertWithWhereUniqueWithoutProjectInput | ProjectExternalLinkUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectExternalLinkCreateManyProjectInputEnvelope
    set?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    disconnect?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    delete?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    connect?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    update?: ProjectExternalLinkUpdateWithWhereUniqueWithoutProjectInput | ProjectExternalLinkUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectExternalLinkUpdateManyWithWhereWithoutProjectInput | ProjectExternalLinkUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectExternalLinkScalarWhereInput | ProjectExternalLinkScalarWhereInput[]
  }

  export type TechStackUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<TechStackCreateWithoutProjectsInput, TechStackUncheckedCreateWithoutProjectsInput> | TechStackCreateWithoutProjectsInput[] | TechStackUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectsInput | TechStackCreateOrConnectWithoutProjectsInput[]
    upsert?: TechStackUpsertWithWhereUniqueWithoutProjectsInput | TechStackUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    disconnect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    delete?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    update?: TechStackUpdateWithWhereUniqueWithoutProjectsInput | TechStackUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: TechStackUpdateManyWithWhereWithoutProjectsInput | TechStackUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: TechStackScalarWhereInput | TechStackScalarWhereInput[]
  }

  export type teamMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<teamMemberCreateWithoutProjectInput, teamMemberUncheckedCreateWithoutProjectInput> | teamMemberCreateWithoutProjectInput[] | teamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectInput | teamMemberCreateOrConnectWithoutProjectInput[]
    upsert?: teamMemberUpsertWithWhereUniqueWithoutProjectInput | teamMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: teamMemberCreateManyProjectInputEnvelope
    set?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    disconnect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    delete?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    update?: teamMemberUpdateWithWhereUniqueWithoutProjectInput | teamMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: teamMemberUpdateManyWithWhereWithoutProjectInput | teamMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: teamMemberScalarWhereInput | teamMemberScalarWhereInput[]
  }

  export type ProjectRoleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectInput, ProjectRoleUncheckedCreateWithoutProjectInput> | ProjectRoleCreateWithoutProjectInput[] | ProjectRoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectInput | ProjectRoleCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutProjectInput | ProjectRoleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectRoleCreateManyProjectInputEnvelope
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutProjectInput | ProjectRoleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutProjectInput | ProjectRoleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput> | CategoryCreateWithoutProjectsInput[] | CategoryUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectsInput | CategoryCreateOrConnectWithoutProjectsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProjectsInput | CategoryUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProjectsInput | CategoryUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProjectsInput | CategoryUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type KeyFeatureUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KeyFeatureCreateWithoutProjectInput, KeyFeatureUncheckedCreateWithoutProjectInput> | KeyFeatureCreateWithoutProjectInput[] | KeyFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyFeatureCreateOrConnectWithoutProjectInput | KeyFeatureCreateOrConnectWithoutProjectInput[]
    upsert?: KeyFeatureUpsertWithWhereUniqueWithoutProjectInput | KeyFeatureUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KeyFeatureCreateManyProjectInputEnvelope
    set?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    disconnect?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    delete?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    connect?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    update?: KeyFeatureUpdateWithWhereUniqueWithoutProjectInput | KeyFeatureUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KeyFeatureUpdateManyWithWhereWithoutProjectInput | KeyFeatureUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KeyFeatureScalarWhereInput | KeyFeatureScalarWhereInput[]
  }

  export type ProjectGoalUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectGoalCreateWithoutProjectInput, ProjectGoalUncheckedCreateWithoutProjectInput> | ProjectGoalCreateWithoutProjectInput[] | ProjectGoalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGoalCreateOrConnectWithoutProjectInput | ProjectGoalCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectGoalUpsertWithWhereUniqueWithoutProjectInput | ProjectGoalUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectGoalCreateManyProjectInputEnvelope
    set?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    disconnect?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    delete?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    connect?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    update?: ProjectGoalUpdateWithWhereUniqueWithoutProjectInput | ProjectGoalUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectGoalUpdateManyWithWhereWithoutProjectInput | ProjectGoalUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectGoalScalarWhereInput | ProjectGoalScalarWhereInput[]
  }

  export type ProjectRoleApplicationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectInput, ProjectRoleApplicationUncheckedCreateWithoutProjectInput> | ProjectRoleApplicationCreateWithoutProjectInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectInput | ProjectRoleApplicationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectInput | ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectInputEnvelope
    set?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    disconnect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    delete?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    update?: ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectInput | ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectRoleApplicationUpdateManyWithWhereWithoutProjectInput | ProjectRoleApplicationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProjectsInput
    upsert?: ProfileUpsertWithoutProjectsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutProjectsInput, ProfileUpdateWithoutProjectsInput>, ProfileUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectExternalLinkCreateWithoutProjectInput, ProjectExternalLinkUncheckedCreateWithoutProjectInput> | ProjectExternalLinkCreateWithoutProjectInput[] | ProjectExternalLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectExternalLinkCreateOrConnectWithoutProjectInput | ProjectExternalLinkCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectExternalLinkUpsertWithWhereUniqueWithoutProjectInput | ProjectExternalLinkUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectExternalLinkCreateManyProjectInputEnvelope
    set?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    disconnect?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    delete?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    connect?: ProjectExternalLinkWhereUniqueInput | ProjectExternalLinkWhereUniqueInput[]
    update?: ProjectExternalLinkUpdateWithWhereUniqueWithoutProjectInput | ProjectExternalLinkUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectExternalLinkUpdateManyWithWhereWithoutProjectInput | ProjectExternalLinkUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectExternalLinkScalarWhereInput | ProjectExternalLinkScalarWhereInput[]
  }

  export type TechStackUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<TechStackCreateWithoutProjectsInput, TechStackUncheckedCreateWithoutProjectsInput> | TechStackCreateWithoutProjectsInput[] | TechStackUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectsInput | TechStackCreateOrConnectWithoutProjectsInput[]
    upsert?: TechStackUpsertWithWhereUniqueWithoutProjectsInput | TechStackUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    disconnect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    delete?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    update?: TechStackUpdateWithWhereUniqueWithoutProjectsInput | TechStackUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: TechStackUpdateManyWithWhereWithoutProjectsInput | TechStackUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: TechStackScalarWhereInput | TechStackScalarWhereInput[]
  }

  export type teamMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<teamMemberCreateWithoutProjectInput, teamMemberUncheckedCreateWithoutProjectInput> | teamMemberCreateWithoutProjectInput[] | teamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectInput | teamMemberCreateOrConnectWithoutProjectInput[]
    upsert?: teamMemberUpsertWithWhereUniqueWithoutProjectInput | teamMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: teamMemberCreateManyProjectInputEnvelope
    set?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    disconnect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    delete?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    update?: teamMemberUpdateWithWhereUniqueWithoutProjectInput | teamMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: teamMemberUpdateManyWithWhereWithoutProjectInput | teamMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: teamMemberScalarWhereInput | teamMemberScalarWhereInput[]
  }

  export type ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectInput, ProjectRoleUncheckedCreateWithoutProjectInput> | ProjectRoleCreateWithoutProjectInput[] | ProjectRoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectInput | ProjectRoleCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutProjectInput | ProjectRoleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectRoleCreateManyProjectInputEnvelope
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutProjectInput | ProjectRoleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutProjectInput | ProjectRoleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput> | CategoryCreateWithoutProjectsInput[] | CategoryUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectsInput | CategoryCreateOrConnectWithoutProjectsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProjectsInput | CategoryUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProjectsInput | CategoryUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProjectsInput | CategoryUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KeyFeatureCreateWithoutProjectInput, KeyFeatureUncheckedCreateWithoutProjectInput> | KeyFeatureCreateWithoutProjectInput[] | KeyFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyFeatureCreateOrConnectWithoutProjectInput | KeyFeatureCreateOrConnectWithoutProjectInput[]
    upsert?: KeyFeatureUpsertWithWhereUniqueWithoutProjectInput | KeyFeatureUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KeyFeatureCreateManyProjectInputEnvelope
    set?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    disconnect?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    delete?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    connect?: KeyFeatureWhereUniqueInput | KeyFeatureWhereUniqueInput[]
    update?: KeyFeatureUpdateWithWhereUniqueWithoutProjectInput | KeyFeatureUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KeyFeatureUpdateManyWithWhereWithoutProjectInput | KeyFeatureUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KeyFeatureScalarWhereInput | KeyFeatureScalarWhereInput[]
  }

  export type ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectGoalCreateWithoutProjectInput, ProjectGoalUncheckedCreateWithoutProjectInput> | ProjectGoalCreateWithoutProjectInput[] | ProjectGoalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGoalCreateOrConnectWithoutProjectInput | ProjectGoalCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectGoalUpsertWithWhereUniqueWithoutProjectInput | ProjectGoalUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectGoalCreateManyProjectInputEnvelope
    set?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    disconnect?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    delete?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    connect?: ProjectGoalWhereUniqueInput | ProjectGoalWhereUniqueInput[]
    update?: ProjectGoalUpdateWithWhereUniqueWithoutProjectInput | ProjectGoalUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectGoalUpdateManyWithWhereWithoutProjectInput | ProjectGoalUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectGoalScalarWhereInput | ProjectGoalScalarWhereInput[]
  }

  export type ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectInput, ProjectRoleApplicationUncheckedCreateWithoutProjectInput> | ProjectRoleApplicationCreateWithoutProjectInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectInput | ProjectRoleApplicationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectInput | ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectInputEnvelope
    set?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    disconnect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    delete?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    update?: ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectInput | ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectRoleApplicationUpdateManyWithWhereWithoutProjectInput | ProjectRoleApplicationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutExternalLinksInput = {
    create?: XOR<ProjectCreateWithoutExternalLinksInput, ProjectUncheckedCreateWithoutExternalLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutExternalLinksInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutExternalLinksNestedInput = {
    create?: XOR<ProjectCreateWithoutExternalLinksInput, ProjectUncheckedCreateWithoutExternalLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutExternalLinksInput
    upsert?: ProjectUpsertWithoutExternalLinksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutExternalLinksInput, ProjectUpdateWithoutExternalLinksInput>, ProjectUncheckedUpdateWithoutExternalLinksInput>
  }

  export type ProjectCreateNestedManyWithoutTechStacksInput = {
    create?: XOR<ProjectCreateWithoutTechStacksInput, ProjectUncheckedCreateWithoutTechStacksInput> | ProjectCreateWithoutTechStacksInput[] | ProjectUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTechStacksInput | ProjectCreateOrConnectWithoutTechStacksInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectRoleCreateNestedManyWithoutTechStacksInput = {
    create?: XOR<ProjectRoleCreateWithoutTechStacksInput, ProjectRoleUncheckedCreateWithoutTechStacksInput> | ProjectRoleCreateWithoutTechStacksInput[] | ProjectRoleUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTechStacksInput | ProjectRoleCreateOrConnectWithoutTechStacksInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutTechStacksInput = {
    create?: XOR<ProjectCreateWithoutTechStacksInput, ProjectUncheckedCreateWithoutTechStacksInput> | ProjectCreateWithoutTechStacksInput[] | ProjectUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTechStacksInput | ProjectCreateOrConnectWithoutTechStacksInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectRoleUncheckedCreateNestedManyWithoutTechStacksInput = {
    create?: XOR<ProjectRoleCreateWithoutTechStacksInput, ProjectRoleUncheckedCreateWithoutTechStacksInput> | ProjectRoleCreateWithoutTechStacksInput[] | ProjectRoleUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTechStacksInput | ProjectRoleCreateOrConnectWithoutTechStacksInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type EnumTechStackTypeFieldUpdateOperationsInput = {
    set?: $Enums.TechStackType
  }

  export type ProjectUpdateManyWithoutTechStacksNestedInput = {
    create?: XOR<ProjectCreateWithoutTechStacksInput, ProjectUncheckedCreateWithoutTechStacksInput> | ProjectCreateWithoutTechStacksInput[] | ProjectUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTechStacksInput | ProjectCreateOrConnectWithoutTechStacksInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTechStacksInput | ProjectUpsertWithWhereUniqueWithoutTechStacksInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTechStacksInput | ProjectUpdateWithWhereUniqueWithoutTechStacksInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTechStacksInput | ProjectUpdateManyWithWhereWithoutTechStacksInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectRoleUpdateManyWithoutTechStacksNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutTechStacksInput, ProjectRoleUncheckedCreateWithoutTechStacksInput> | ProjectRoleCreateWithoutTechStacksInput[] | ProjectRoleUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTechStacksInput | ProjectRoleCreateOrConnectWithoutTechStacksInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutTechStacksInput | ProjectRoleUpsertWithWhereUniqueWithoutTechStacksInput[]
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutTechStacksInput | ProjectRoleUpdateWithWhereUniqueWithoutTechStacksInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutTechStacksInput | ProjectRoleUpdateManyWithWhereWithoutTechStacksInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutTechStacksNestedInput = {
    create?: XOR<ProjectCreateWithoutTechStacksInput, ProjectUncheckedCreateWithoutTechStacksInput> | ProjectCreateWithoutTechStacksInput[] | ProjectUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTechStacksInput | ProjectCreateOrConnectWithoutTechStacksInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTechStacksInput | ProjectUpsertWithWhereUniqueWithoutTechStacksInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTechStacksInput | ProjectUpdateWithWhereUniqueWithoutTechStacksInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTechStacksInput | ProjectUpdateManyWithWhereWithoutTechStacksInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectRoleUncheckedUpdateManyWithoutTechStacksNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutTechStacksInput, ProjectRoleUncheckedCreateWithoutTechStacksInput> | ProjectRoleCreateWithoutTechStacksInput[] | ProjectRoleUncheckedCreateWithoutTechStacksInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTechStacksInput | ProjectRoleCreateOrConnectWithoutTechStacksInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutTechStacksInput | ProjectRoleUpsertWithWhereUniqueWithoutTechStacksInput[]
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutTechStacksInput | ProjectRoleUpdateWithWhereUniqueWithoutTechStacksInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutTechStacksInput | ProjectRoleUpdateManyWithWhereWithoutTechStacksInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type ProjectRoleCreateNestedManyWithoutTeamMemberInput = {
    create?: XOR<ProjectRoleCreateWithoutTeamMemberInput, ProjectRoleUncheckedCreateWithoutTeamMemberInput> | ProjectRoleCreateWithoutTeamMemberInput[] | ProjectRoleUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTeamMemberInput | ProjectRoleCreateOrConnectWithoutTeamMemberInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectRoleUncheckedCreateNestedManyWithoutTeamMemberInput = {
    create?: XOR<ProjectRoleCreateWithoutTeamMemberInput, ProjectRoleUncheckedCreateWithoutTeamMemberInput> | ProjectRoleCreateWithoutTeamMemberInput[] | ProjectRoleUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTeamMemberInput | ProjectRoleCreateOrConnectWithoutTeamMemberInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type ProjectRoleUpdateManyWithoutTeamMemberNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutTeamMemberInput, ProjectRoleUncheckedCreateWithoutTeamMemberInput> | ProjectRoleCreateWithoutTeamMemberInput[] | ProjectRoleUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTeamMemberInput | ProjectRoleCreateOrConnectWithoutTeamMemberInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutTeamMemberInput | ProjectRoleUpsertWithWhereUniqueWithoutTeamMemberInput[]
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutTeamMemberInput | ProjectRoleUpdateWithWhereUniqueWithoutTeamMemberInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutTeamMemberInput | ProjectRoleUpdateManyWithWhereWithoutTeamMemberInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectMembersInput
    upsert?: ProjectUpsertWithoutProjectMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectMembersInput, ProjectUpdateWithoutProjectMembersInput>, ProjectUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectRoleUncheckedUpdateManyWithoutTeamMemberNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutTeamMemberInput, ProjectRoleUncheckedCreateWithoutTeamMemberInput> | ProjectRoleCreateWithoutTeamMemberInput[] | ProjectRoleUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutTeamMemberInput | ProjectRoleCreateOrConnectWithoutTeamMemberInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutTeamMemberInput | ProjectRoleUpsertWithWhereUniqueWithoutTeamMemberInput[]
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutTeamMemberInput | ProjectRoleUpdateWithWhereUniqueWithoutTeamMemberInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutTeamMemberInput | ProjectRoleUpdateManyWithWhereWithoutTeamMemberInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type TechStackCreateNestedManyWithoutProjectRolesInput = {
    create?: XOR<TechStackCreateWithoutProjectRolesInput, TechStackUncheckedCreateWithoutProjectRolesInput> | TechStackCreateWithoutProjectRolesInput[] | TechStackUncheckedCreateWithoutProjectRolesInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectRolesInput | TechStackCreateOrConnectWithoutProjectRolesInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
  }

  export type teamMemberCreateNestedManyWithoutProjectRoleInput = {
    create?: XOR<teamMemberCreateWithoutProjectRoleInput, teamMemberUncheckedCreateWithoutProjectRoleInput> | teamMemberCreateWithoutProjectRoleInput[] | teamMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectRoleInput | teamMemberCreateOrConnectWithoutProjectRoleInput[]
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectRolesInput = {
    create?: XOR<ProjectCreateWithoutProjectRolesInput, ProjectUncheckedCreateWithoutProjectRolesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectRolesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectRoleApplicationCreateNestedManyWithoutProjectRoleInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput> | ProjectRoleApplicationCreateWithoutProjectRoleInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput | ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectRoleInputEnvelope
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
  }

  export type TechStackUncheckedCreateNestedManyWithoutProjectRolesInput = {
    create?: XOR<TechStackCreateWithoutProjectRolesInput, TechStackUncheckedCreateWithoutProjectRolesInput> | TechStackCreateWithoutProjectRolesInput[] | TechStackUncheckedCreateWithoutProjectRolesInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectRolesInput | TechStackCreateOrConnectWithoutProjectRolesInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
  }

  export type teamMemberUncheckedCreateNestedManyWithoutProjectRoleInput = {
    create?: XOR<teamMemberCreateWithoutProjectRoleInput, teamMemberUncheckedCreateWithoutProjectRoleInput> | teamMemberCreateWithoutProjectRoleInput[] | teamMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectRoleInput | teamMemberCreateOrConnectWithoutProjectRoleInput[]
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
  }

  export type ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectRoleInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput> | ProjectRoleApplicationCreateWithoutProjectRoleInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput | ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectRoleInputEnvelope
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TechStackUpdateManyWithoutProjectRolesNestedInput = {
    create?: XOR<TechStackCreateWithoutProjectRolesInput, TechStackUncheckedCreateWithoutProjectRolesInput> | TechStackCreateWithoutProjectRolesInput[] | TechStackUncheckedCreateWithoutProjectRolesInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectRolesInput | TechStackCreateOrConnectWithoutProjectRolesInput[]
    upsert?: TechStackUpsertWithWhereUniqueWithoutProjectRolesInput | TechStackUpsertWithWhereUniqueWithoutProjectRolesInput[]
    set?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    disconnect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    delete?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    update?: TechStackUpdateWithWhereUniqueWithoutProjectRolesInput | TechStackUpdateWithWhereUniqueWithoutProjectRolesInput[]
    updateMany?: TechStackUpdateManyWithWhereWithoutProjectRolesInput | TechStackUpdateManyWithWhereWithoutProjectRolesInput[]
    deleteMany?: TechStackScalarWhereInput | TechStackScalarWhereInput[]
  }

  export type teamMemberUpdateManyWithoutProjectRoleNestedInput = {
    create?: XOR<teamMemberCreateWithoutProjectRoleInput, teamMemberUncheckedCreateWithoutProjectRoleInput> | teamMemberCreateWithoutProjectRoleInput[] | teamMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectRoleInput | teamMemberCreateOrConnectWithoutProjectRoleInput[]
    upsert?: teamMemberUpsertWithWhereUniqueWithoutProjectRoleInput | teamMemberUpsertWithWhereUniqueWithoutProjectRoleInput[]
    set?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    disconnect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    delete?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    update?: teamMemberUpdateWithWhereUniqueWithoutProjectRoleInput | teamMemberUpdateWithWhereUniqueWithoutProjectRoleInput[]
    updateMany?: teamMemberUpdateManyWithWhereWithoutProjectRoleInput | teamMemberUpdateManyWithWhereWithoutProjectRoleInput[]
    deleteMany?: teamMemberScalarWhereInput | teamMemberScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutProjectRolesNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectRolesInput, ProjectUncheckedCreateWithoutProjectRolesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectRolesInput
    upsert?: ProjectUpsertWithoutProjectRolesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectRolesInput, ProjectUpdateWithoutProjectRolesInput>, ProjectUncheckedUpdateWithoutProjectRolesInput>
  }

  export type ProjectRoleApplicationUpdateManyWithoutProjectRoleNestedInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput> | ProjectRoleApplicationCreateWithoutProjectRoleInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput | ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput[]
    upsert?: ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectRoleInput | ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectRoleInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectRoleInputEnvelope
    set?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    disconnect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    delete?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    update?: ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectRoleInput | ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectRoleInput[]
    updateMany?: ProjectRoleApplicationUpdateManyWithWhereWithoutProjectRoleInput | ProjectRoleApplicationUpdateManyWithWhereWithoutProjectRoleInput[]
    deleteMany?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
  }

  export type TechStackUncheckedUpdateManyWithoutProjectRolesNestedInput = {
    create?: XOR<TechStackCreateWithoutProjectRolesInput, TechStackUncheckedCreateWithoutProjectRolesInput> | TechStackCreateWithoutProjectRolesInput[] | TechStackUncheckedCreateWithoutProjectRolesInput[]
    connectOrCreate?: TechStackCreateOrConnectWithoutProjectRolesInput | TechStackCreateOrConnectWithoutProjectRolesInput[]
    upsert?: TechStackUpsertWithWhereUniqueWithoutProjectRolesInput | TechStackUpsertWithWhereUniqueWithoutProjectRolesInput[]
    set?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    disconnect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    delete?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    connect?: TechStackWhereUniqueInput | TechStackWhereUniqueInput[]
    update?: TechStackUpdateWithWhereUniqueWithoutProjectRolesInput | TechStackUpdateWithWhereUniqueWithoutProjectRolesInput[]
    updateMany?: TechStackUpdateManyWithWhereWithoutProjectRolesInput | TechStackUpdateManyWithWhereWithoutProjectRolesInput[]
    deleteMany?: TechStackScalarWhereInput | TechStackScalarWhereInput[]
  }

  export type teamMemberUncheckedUpdateManyWithoutProjectRoleNestedInput = {
    create?: XOR<teamMemberCreateWithoutProjectRoleInput, teamMemberUncheckedCreateWithoutProjectRoleInput> | teamMemberCreateWithoutProjectRoleInput[] | teamMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: teamMemberCreateOrConnectWithoutProjectRoleInput | teamMemberCreateOrConnectWithoutProjectRoleInput[]
    upsert?: teamMemberUpsertWithWhereUniqueWithoutProjectRoleInput | teamMemberUpsertWithWhereUniqueWithoutProjectRoleInput[]
    set?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    disconnect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    delete?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    connect?: teamMemberWhereUniqueInput | teamMemberWhereUniqueInput[]
    update?: teamMemberUpdateWithWhereUniqueWithoutProjectRoleInput | teamMemberUpdateWithWhereUniqueWithoutProjectRoleInput[]
    updateMany?: teamMemberUpdateManyWithWhereWithoutProjectRoleInput | teamMemberUpdateManyWithWhereWithoutProjectRoleInput[]
    deleteMany?: teamMemberScalarWhereInput | teamMemberScalarWhereInput[]
  }

  export type ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleNestedInput = {
    create?: XOR<ProjectRoleApplicationCreateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput> | ProjectRoleApplicationCreateWithoutProjectRoleInput[] | ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput | ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput[]
    upsert?: ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectRoleInput | ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectRoleInput[]
    createMany?: ProjectRoleApplicationCreateManyProjectRoleInputEnvelope
    set?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    disconnect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    delete?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    connect?: ProjectRoleApplicationWhereUniqueInput | ProjectRoleApplicationWhereUniqueInput[]
    update?: ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectRoleInput | ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectRoleInput[]
    updateMany?: ProjectRoleApplicationUpdateManyWithWhereWithoutProjectRoleInput | ProjectRoleApplicationUpdateManyWithWhereWithoutProjectRoleInput[]
    deleteMany?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
  }

  export type ProjectRoleApplicationCreateselectedKeyFeaturesInput = {
    set: string[]
  }

  export type ProjectRoleApplicationCreateselectedProjectGoalsInput = {
    set: string[]
  }

  export type ProjectRoleCreateNestedOneWithoutProjectRoleApplicationInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectRoleApplicationInput, ProjectRoleUncheckedCreateWithoutProjectRoleApplicationInput>
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectRoleApplicationInput
    connect?: ProjectRoleWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutProjectRoleApplicationInput = {
    create?: XOR<ProfileCreateWithoutProjectRoleApplicationInput, ProfileUncheckedCreateWithoutProjectRoleApplicationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProjectRoleApplicationInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectRoleApplicationInput = {
    create?: XOR<ProjectCreateWithoutProjectRoleApplicationInput, ProjectUncheckedCreateWithoutProjectRoleApplicationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectRoleApplicationInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectRoleApplicationUpdateselectedKeyFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectRoleApplicationUpdateselectedProjectGoalsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectRoleUpdateOneRequiredWithoutProjectRoleApplicationNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectRoleApplicationInput, ProjectRoleUncheckedCreateWithoutProjectRoleApplicationInput>
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectRoleApplicationInput
    upsert?: ProjectRoleUpsertWithoutProjectRoleApplicationInput
    connect?: ProjectRoleWhereUniqueInput
    update?: XOR<XOR<ProjectRoleUpdateToOneWithWhereWithoutProjectRoleApplicationInput, ProjectRoleUpdateWithoutProjectRoleApplicationInput>, ProjectRoleUncheckedUpdateWithoutProjectRoleApplicationInput>
  }

  export type ProfileUpdateOneRequiredWithoutProjectRoleApplicationNestedInput = {
    create?: XOR<ProfileCreateWithoutProjectRoleApplicationInput, ProfileUncheckedCreateWithoutProjectRoleApplicationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProjectRoleApplicationInput
    upsert?: ProfileUpsertWithoutProjectRoleApplicationInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutProjectRoleApplicationInput, ProfileUpdateWithoutProjectRoleApplicationInput>, ProfileUncheckedUpdateWithoutProjectRoleApplicationInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectRoleApplicationNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectRoleApplicationInput, ProjectUncheckedCreateWithoutProjectRoleApplicationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectRoleApplicationInput
    upsert?: ProjectUpsertWithoutProjectRoleApplicationInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectRoleApplicationInput, ProjectUpdateWithoutProjectRoleApplicationInput>, ProjectUncheckedUpdateWithoutProjectRoleApplicationInput>
  }

  export type ProfileCreateNestedOneWithoutSocialLinksInput = {
    create?: XOR<ProfileCreateWithoutSocialLinksInput, ProfileUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSocialLinksInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutSocialLinksNestedInput = {
    create?: XOR<ProfileCreateWithoutSocialLinksInput, ProfileUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSocialLinksInput
    upsert?: ProfileUpsertWithoutSocialLinksInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSocialLinksInput, ProfileUpdateWithoutSocialLinksInput>, ProfileUncheckedUpdateWithoutSocialLinksInput>
  }

  export type ProjectCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput> | ProjectCreateWithoutCategoriesInput[] | ProjectUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoriesInput | ProjectCreateOrConnectWithoutCategoriesInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput> | ProjectCreateWithoutCategoriesInput[] | ProjectUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoriesInput | ProjectCreateOrConnectWithoutCategoriesInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput> | ProjectCreateWithoutCategoriesInput[] | ProjectUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoriesInput | ProjectCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCategoriesInput | ProjectUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCategoriesInput | ProjectUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCategoriesInput | ProjectUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput> | ProjectCreateWithoutCategoriesInput[] | ProjectUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoriesInput | ProjectCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCategoriesInput | ProjectUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCategoriesInput | ProjectUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCategoriesInput | ProjectUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutKeyFeaturesInput = {
    create?: XOR<ProjectCreateWithoutKeyFeaturesInput, ProjectUncheckedCreateWithoutKeyFeaturesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKeyFeaturesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutKeyFeaturesNestedInput = {
    create?: XOR<ProjectCreateWithoutKeyFeaturesInput, ProjectUncheckedCreateWithoutKeyFeaturesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKeyFeaturesInput
    upsert?: ProjectUpsertWithoutKeyFeaturesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutKeyFeaturesInput, ProjectUpdateWithoutKeyFeaturesInput>, ProjectUncheckedUpdateWithoutKeyFeaturesInput>
  }

  export type ProjectCreateNestedOneWithoutProjectGoalsInput = {
    create?: XOR<ProjectCreateWithoutProjectGoalsInput, ProjectUncheckedCreateWithoutProjectGoalsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectGoalsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectGoalsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectGoalsInput, ProjectUncheckedCreateWithoutProjectGoalsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectGoalsInput
    upsert?: ProjectUpsertWithoutProjectGoalsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectGoalsInput, ProjectUpdateWithoutProjectGoalsInput>, ProjectUncheckedUpdateWithoutProjectGoalsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTechStackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TechStackType | EnumTechStackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechStackTypeFilter<$PrismaModel> | $Enums.TechStackType
  }

  export type NestedEnumTechStackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechStackType | EnumTechStackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechStackType[] | ListEnumTechStackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechStackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TechStackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechStackTypeFilter<$PrismaModel>
    _max?: NestedEnumTechStackTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserGitHubCredentialsCreateWithoutUserInput = {
    githubAccessToken?: string | null
    githubUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGitHubCredentialsUncheckedCreateWithoutUserInput = {
    githubAccessToken?: string | null
    githubUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGitHubCredentialsCreateOrConnectWithoutUserInput = {
    where: UserGitHubCredentialsWhereUniqueInput
    create: XOR<UserGitHubCredentialsCreateWithoutUserInput, UserGitHubCredentialsUncheckedCreateWithoutUserInput>
  }

  export type ProfileCreateWithoutUserInput = {
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    socialLinks?: UserSocialLinkCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    socialLinks?: UserSocialLinkUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type UserGitHubCredentialsUpsertWithoutUserInput = {
    update: XOR<UserGitHubCredentialsUpdateWithoutUserInput, UserGitHubCredentialsUncheckedUpdateWithoutUserInput>
    create: XOR<UserGitHubCredentialsCreateWithoutUserInput, UserGitHubCredentialsUncheckedCreateWithoutUserInput>
    where?: UserGitHubCredentialsWhereInput
  }

  export type UserGitHubCredentialsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserGitHubCredentialsWhereInput
    data: XOR<UserGitHubCredentialsUpdateWithoutUserInput, UserGitHubCredentialsUncheckedUpdateWithoutUserInput>
  }

  export type UserGitHubCredentialsUpdateWithoutUserInput = {
    githubAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGitHubCredentialsUncheckedUpdateWithoutUserInput = {
    githubAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserSocialLinkUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserSocialLinkUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    githubCredentials?: UserGitHubCredentialsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    githubCredentials?: UserGitHubCredentialsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserSocialLinkCreateWithoutProfileInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
  }

  export type UserSocialLinkUncheckedCreateWithoutProfileInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
  }

  export type UserSocialLinkCreateOrConnectWithoutProfileInput = {
    where: UserSocialLinkWhereUniqueInput
    create: XOR<UserSocialLinkCreateWithoutProfileInput, UserSocialLinkUncheckedCreateWithoutProfileInput>
  }

  export type UserSocialLinkCreateManyProfileInputEnvelope = {
    data: UserSocialLinkCreateManyProfileInput | UserSocialLinkCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutProfileInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProfileInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProfileInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput>
  }

  export type ProjectCreateManyProfileInputEnvelope = {
    data: ProjectCreateManyProfileInput | ProjectCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProjectRoleApplicationCreateWithoutProfileInput = {
    id?: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectRole: ProjectRoleCreateNestedOneWithoutProjectRoleApplicationInput
    project: ProjectCreateNestedOneWithoutProjectRoleApplicationInput
  }

  export type ProjectRoleApplicationUncheckedCreateWithoutProfileInput = {
    id?: string
    projectId: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectRoleApplicationCreateOrConnectWithoutProfileInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    create: XOR<ProjectRoleApplicationCreateWithoutProfileInput, ProjectRoleApplicationUncheckedCreateWithoutProfileInput>
  }

  export type ProjectRoleApplicationCreateManyProfileInputEnvelope = {
    data: ProjectRoleApplicationCreateManyProfileInput | ProjectRoleApplicationCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubCredentials?: UserGitHubCredentialsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubCredentials?: UserGitHubCredentialsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserSocialLinkUpsertWithWhereUniqueWithoutProfileInput = {
    where: UserSocialLinkWhereUniqueInput
    update: XOR<UserSocialLinkUpdateWithoutProfileInput, UserSocialLinkUncheckedUpdateWithoutProfileInput>
    create: XOR<UserSocialLinkCreateWithoutProfileInput, UserSocialLinkUncheckedCreateWithoutProfileInput>
  }

  export type UserSocialLinkUpdateWithWhereUniqueWithoutProfileInput = {
    where: UserSocialLinkWhereUniqueInput
    data: XOR<UserSocialLinkUpdateWithoutProfileInput, UserSocialLinkUncheckedUpdateWithoutProfileInput>
  }

  export type UserSocialLinkUpdateManyWithWhereWithoutProfileInput = {
    where: UserSocialLinkScalarWhereInput
    data: XOR<UserSocialLinkUpdateManyMutationInput, UserSocialLinkUncheckedUpdateManyWithoutProfileInput>
  }

  export type UserSocialLinkScalarWhereInput = {
    AND?: UserSocialLinkScalarWhereInput | UserSocialLinkScalarWhereInput[]
    OR?: UserSocialLinkScalarWhereInput[]
    NOT?: UserSocialLinkScalarWhereInput | UserSocialLinkScalarWhereInput[]
    id?: StringFilter<"UserSocialLink"> | string
    userId?: StringFilter<"UserSocialLink"> | string
    type?: StringFilter<"UserSocialLink"> | string
    url?: StringFilter<"UserSocialLink"> | string
    createdAt?: DateTimeFilter<"UserSocialLink"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProfileInput, ProjectUncheckedUpdateWithoutProfileInput>
    create: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProfileInput, ProjectUncheckedUpdateWithoutProfileInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProfileInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    ownerId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    shortDescription?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    profileId?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
  }

  export type ProjectRoleApplicationUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    update: XOR<ProjectRoleApplicationUpdateWithoutProfileInput, ProjectRoleApplicationUncheckedUpdateWithoutProfileInput>
    create: XOR<ProjectRoleApplicationCreateWithoutProfileInput, ProjectRoleApplicationUncheckedCreateWithoutProfileInput>
  }

  export type ProjectRoleApplicationUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    data: XOR<ProjectRoleApplicationUpdateWithoutProfileInput, ProjectRoleApplicationUncheckedUpdateWithoutProfileInput>
  }

  export type ProjectRoleApplicationUpdateManyWithWhereWithoutProfileInput = {
    where: ProjectRoleApplicationScalarWhereInput
    data: XOR<ProjectRoleApplicationUpdateManyMutationInput, ProjectRoleApplicationUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProjectRoleApplicationScalarWhereInput = {
    AND?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
    OR?: ProjectRoleApplicationScalarWhereInput[]
    NOT?: ProjectRoleApplicationScalarWhereInput | ProjectRoleApplicationScalarWhereInput[]
    id?: StringFilter<"ProjectRoleApplication"> | string
    projectId?: StringFilter<"ProjectRoleApplication"> | string
    projectRoleId?: StringFilter<"ProjectRoleApplication"> | string
    projectRoleTitle?: StringFilter<"ProjectRoleApplication"> | string
    status?: StringFilter<"ProjectRoleApplication"> | string
    motivationLetter?: StringNullableFilter<"ProjectRoleApplication"> | string | null
    selectedKeyFeatures?: StringNullableListFilter<"ProjectRoleApplication">
    selectedProjectGoals?: StringNullableListFilter<"ProjectRoleApplication">
    rejectionReason?: StringNullableFilter<"ProjectRoleApplication"> | string | null
    appliedAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    createdAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRoleApplication"> | Date | string
    profileId?: StringFilter<"ProjectRoleApplication"> | string
  }

  export type UserCreateWithoutGithubCredentialsInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGithubCredentialsInput = {
    id?: string
    username: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGithubCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGithubCredentialsInput, UserUncheckedCreateWithoutGithubCredentialsInput>
  }

  export type UserUpsertWithoutGithubCredentialsInput = {
    update: XOR<UserUpdateWithoutGithubCredentialsInput, UserUncheckedUpdateWithoutGithubCredentialsInput>
    create: XOR<UserCreateWithoutGithubCredentialsInput, UserUncheckedCreateWithoutGithubCredentialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGithubCredentialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGithubCredentialsInput, UserUncheckedUpdateWithoutGithubCredentialsInput>
  }

  export type UserUpdateWithoutGithubCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGithubCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProjectExternalLinkCreateWithoutProjectInput = {
    id?: string
    type: string
    url: string
  }

  export type ProjectExternalLinkUncheckedCreateWithoutProjectInput = {
    id?: string
    type: string
    url: string
  }

  export type ProjectExternalLinkCreateOrConnectWithoutProjectInput = {
    where: ProjectExternalLinkWhereUniqueInput
    create: XOR<ProjectExternalLinkCreateWithoutProjectInput, ProjectExternalLinkUncheckedCreateWithoutProjectInput>
  }

  export type ProjectExternalLinkCreateManyProjectInputEnvelope = {
    data: ProjectExternalLinkCreateManyProjectInput | ProjectExternalLinkCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TechStackCreateWithoutProjectsInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    projectRoles?: ProjectRoleCreateNestedManyWithoutTechStacksInput
  }

  export type TechStackUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutTechStacksInput
  }

  export type TechStackCreateOrConnectWithoutProjectsInput = {
    where: TechStackWhereUniqueInput
    create: XOR<TechStackCreateWithoutProjectsInput, TechStackUncheckedCreateWithoutProjectsInput>
  }

  export type teamMemberCreateWithoutProjectInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    projectRole?: ProjectRoleCreateNestedManyWithoutTeamMemberInput
  }

  export type teamMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    projectRole?: ProjectRoleUncheckedCreateNestedManyWithoutTeamMemberInput
  }

  export type teamMemberCreateOrConnectWithoutProjectInput = {
    where: teamMemberWhereUniqueInput
    create: XOR<teamMemberCreateWithoutProjectInput, teamMemberUncheckedCreateWithoutProjectInput>
  }

  export type teamMemberCreateManyProjectInputEnvelope = {
    data: teamMemberCreateManyProjectInput | teamMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectRoleCreateWithoutProjectInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackCreateNestedManyWithoutProjectRolesInput
    teamMember?: teamMemberCreateNestedManyWithoutProjectRoleInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectRolesInput
    teamMember?: teamMemberUncheckedCreateNestedManyWithoutProjectRoleInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleCreateOrConnectWithoutProjectInput = {
    where: ProjectRoleWhereUniqueInput
    create: XOR<ProjectRoleCreateWithoutProjectInput, ProjectRoleUncheckedCreateWithoutProjectInput>
  }

  export type ProjectRoleCreateManyProjectInputEnvelope = {
    data: ProjectRoleCreateManyProjectInput | ProjectRoleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProjectsInput = {
    id?: string
    name: string
  }

  export type CategoryUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
  }

  export type CategoryCreateOrConnectWithoutProjectsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput>
  }

  export type KeyFeatureCreateWithoutProjectInput = {
    id?: string
    feature: string
  }

  export type KeyFeatureUncheckedCreateWithoutProjectInput = {
    id?: string
    feature: string
  }

  export type KeyFeatureCreateOrConnectWithoutProjectInput = {
    where: KeyFeatureWhereUniqueInput
    create: XOR<KeyFeatureCreateWithoutProjectInput, KeyFeatureUncheckedCreateWithoutProjectInput>
  }

  export type KeyFeatureCreateManyProjectInputEnvelope = {
    data: KeyFeatureCreateManyProjectInput | KeyFeatureCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectGoalCreateWithoutProjectInput = {
    id?: string
    goal: string
  }

  export type ProjectGoalUncheckedCreateWithoutProjectInput = {
    id?: string
    goal: string
  }

  export type ProjectGoalCreateOrConnectWithoutProjectInput = {
    where: ProjectGoalWhereUniqueInput
    create: XOR<ProjectGoalCreateWithoutProjectInput, ProjectGoalUncheckedCreateWithoutProjectInput>
  }

  export type ProjectGoalCreateManyProjectInputEnvelope = {
    data: ProjectGoalCreateManyProjectInput | ProjectGoalCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectRoleApplicationCreateWithoutProjectInput = {
    id?: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectRole: ProjectRoleCreateNestedOneWithoutProjectRoleApplicationInput
    profile: ProfileCreateNestedOneWithoutProjectRoleApplicationInput
  }

  export type ProjectRoleApplicationUncheckedCreateWithoutProjectInput = {
    id?: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type ProjectRoleApplicationCreateOrConnectWithoutProjectInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    create: XOR<ProjectRoleApplicationCreateWithoutProjectInput, ProjectRoleApplicationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectRoleApplicationCreateManyProjectInputEnvelope = {
    data: ProjectRoleApplicationCreateManyProjectInput | ProjectRoleApplicationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutProjectsInput = {
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProfileInput
    socialLinks?: UserSocialLinkCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutProjectsInput = {
    userId: string
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    socialLinks?: UserSocialLinkUncheckedCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutProjectsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectExternalLinkUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectExternalLinkWhereUniqueInput
    update: XOR<ProjectExternalLinkUpdateWithoutProjectInput, ProjectExternalLinkUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectExternalLinkCreateWithoutProjectInput, ProjectExternalLinkUncheckedCreateWithoutProjectInput>
  }

  export type ProjectExternalLinkUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectExternalLinkWhereUniqueInput
    data: XOR<ProjectExternalLinkUpdateWithoutProjectInput, ProjectExternalLinkUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectExternalLinkUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectExternalLinkScalarWhereInput
    data: XOR<ProjectExternalLinkUpdateManyMutationInput, ProjectExternalLinkUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectExternalLinkScalarWhereInput = {
    AND?: ProjectExternalLinkScalarWhereInput | ProjectExternalLinkScalarWhereInput[]
    OR?: ProjectExternalLinkScalarWhereInput[]
    NOT?: ProjectExternalLinkScalarWhereInput | ProjectExternalLinkScalarWhereInput[]
    id?: StringFilter<"ProjectExternalLink"> | string
    projectId?: StringFilter<"ProjectExternalLink"> | string
    type?: StringFilter<"ProjectExternalLink"> | string
    url?: StringFilter<"ProjectExternalLink"> | string
  }

  export type TechStackUpsertWithWhereUniqueWithoutProjectsInput = {
    where: TechStackWhereUniqueInput
    update: XOR<TechStackUpdateWithoutProjectsInput, TechStackUncheckedUpdateWithoutProjectsInput>
    create: XOR<TechStackCreateWithoutProjectsInput, TechStackUncheckedCreateWithoutProjectsInput>
  }

  export type TechStackUpdateWithWhereUniqueWithoutProjectsInput = {
    where: TechStackWhereUniqueInput
    data: XOR<TechStackUpdateWithoutProjectsInput, TechStackUncheckedUpdateWithoutProjectsInput>
  }

  export type TechStackUpdateManyWithWhereWithoutProjectsInput = {
    where: TechStackScalarWhereInput
    data: XOR<TechStackUpdateManyMutationInput, TechStackUncheckedUpdateManyWithoutProjectsInput>
  }

  export type TechStackScalarWhereInput = {
    AND?: TechStackScalarWhereInput | TechStackScalarWhereInput[]
    OR?: TechStackScalarWhereInput[]
    NOT?: TechStackScalarWhereInput | TechStackScalarWhereInput[]
    id?: StringFilter<"TechStack"> | string
    name?: StringFilter<"TechStack"> | string
    iconUrl?: StringFilter<"TechStack"> | string
    type?: EnumTechStackTypeFilter<"TechStack"> | $Enums.TechStackType
  }

  export type teamMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: teamMemberWhereUniqueInput
    update: XOR<teamMemberUpdateWithoutProjectInput, teamMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<teamMemberCreateWithoutProjectInput, teamMemberUncheckedCreateWithoutProjectInput>
  }

  export type teamMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: teamMemberWhereUniqueInput
    data: XOR<teamMemberUpdateWithoutProjectInput, teamMemberUncheckedUpdateWithoutProjectInput>
  }

  export type teamMemberUpdateManyWithWhereWithoutProjectInput = {
    where: teamMemberScalarWhereInput
    data: XOR<teamMemberUpdateManyMutationInput, teamMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type teamMemberScalarWhereInput = {
    AND?: teamMemberScalarWhereInput | teamMemberScalarWhereInput[]
    OR?: teamMemberScalarWhereInput[]
    NOT?: teamMemberScalarWhereInput | teamMemberScalarWhereInput[]
    id?: StringFilter<"teamMember"> | string
    userId?: StringFilter<"teamMember"> | string
    projectId?: StringFilter<"teamMember"> | string
    joinedAt?: DateTimeFilter<"teamMember"> | Date | string
  }

  export type ProjectRoleUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectRoleWhereUniqueInput
    update: XOR<ProjectRoleUpdateWithoutProjectInput, ProjectRoleUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectRoleCreateWithoutProjectInput, ProjectRoleUncheckedCreateWithoutProjectInput>
  }

  export type ProjectRoleUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectRoleWhereUniqueInput
    data: XOR<ProjectRoleUpdateWithoutProjectInput, ProjectRoleUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectRoleUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectRoleScalarWhereInput
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectRoleScalarWhereInput = {
    AND?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
    OR?: ProjectRoleScalarWhereInput[]
    NOT?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
    id?: StringFilter<"ProjectRole"> | string
    projectId?: StringFilter<"ProjectRole"> | string
    title?: StringFilter<"ProjectRole"> | string
    description?: StringFilter<"ProjectRole"> | string
    isFilled?: BoolFilter<"ProjectRole"> | boolean
    createdAt?: DateTimeFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRole"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutProjectsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProjectsInput, CategoryUncheckedUpdateWithoutProjectsInput>
    create: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProjectsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProjectsInput, CategoryUncheckedUpdateWithoutProjectsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProjectsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutProjectsInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
  }

  export type KeyFeatureUpsertWithWhereUniqueWithoutProjectInput = {
    where: KeyFeatureWhereUniqueInput
    update: XOR<KeyFeatureUpdateWithoutProjectInput, KeyFeatureUncheckedUpdateWithoutProjectInput>
    create: XOR<KeyFeatureCreateWithoutProjectInput, KeyFeatureUncheckedCreateWithoutProjectInput>
  }

  export type KeyFeatureUpdateWithWhereUniqueWithoutProjectInput = {
    where: KeyFeatureWhereUniqueInput
    data: XOR<KeyFeatureUpdateWithoutProjectInput, KeyFeatureUncheckedUpdateWithoutProjectInput>
  }

  export type KeyFeatureUpdateManyWithWhereWithoutProjectInput = {
    where: KeyFeatureScalarWhereInput
    data: XOR<KeyFeatureUpdateManyMutationInput, KeyFeatureUncheckedUpdateManyWithoutProjectInput>
  }

  export type KeyFeatureScalarWhereInput = {
    AND?: KeyFeatureScalarWhereInput | KeyFeatureScalarWhereInput[]
    OR?: KeyFeatureScalarWhereInput[]
    NOT?: KeyFeatureScalarWhereInput | KeyFeatureScalarWhereInput[]
    id?: StringFilter<"KeyFeature"> | string
    projectId?: StringFilter<"KeyFeature"> | string
    feature?: StringFilter<"KeyFeature"> | string
  }

  export type ProjectGoalUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectGoalWhereUniqueInput
    update: XOR<ProjectGoalUpdateWithoutProjectInput, ProjectGoalUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectGoalCreateWithoutProjectInput, ProjectGoalUncheckedCreateWithoutProjectInput>
  }

  export type ProjectGoalUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectGoalWhereUniqueInput
    data: XOR<ProjectGoalUpdateWithoutProjectInput, ProjectGoalUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectGoalUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectGoalScalarWhereInput
    data: XOR<ProjectGoalUpdateManyMutationInput, ProjectGoalUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectGoalScalarWhereInput = {
    AND?: ProjectGoalScalarWhereInput | ProjectGoalScalarWhereInput[]
    OR?: ProjectGoalScalarWhereInput[]
    NOT?: ProjectGoalScalarWhereInput | ProjectGoalScalarWhereInput[]
    id?: StringFilter<"ProjectGoal"> | string
    projectId?: StringFilter<"ProjectGoal"> | string
    goal?: StringFilter<"ProjectGoal"> | string
  }

  export type ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    update: XOR<ProjectRoleApplicationUpdateWithoutProjectInput, ProjectRoleApplicationUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectRoleApplicationCreateWithoutProjectInput, ProjectRoleApplicationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    data: XOR<ProjectRoleApplicationUpdateWithoutProjectInput, ProjectRoleApplicationUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectRoleApplicationUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectRoleApplicationScalarWhereInput
    data: XOR<ProjectRoleApplicationUpdateManyMutationInput, ProjectRoleApplicationUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProfileUpsertWithoutProjectsInput = {
    update: XOR<ProfileUpdateWithoutProjectsInput, ProfileUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutProjectsInput, ProfileUncheckedUpdateWithoutProjectsInput>
  }

  export type ProfileUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProfileNestedInput
    socialLinks?: UserSocialLinkUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutProjectsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserSocialLinkUncheckedUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProjectCreateWithoutExternalLinksInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutExternalLinksInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutExternalLinksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutExternalLinksInput, ProjectUncheckedCreateWithoutExternalLinksInput>
  }

  export type ProjectUpsertWithoutExternalLinksInput = {
    update: XOR<ProjectUpdateWithoutExternalLinksInput, ProjectUncheckedUpdateWithoutExternalLinksInput>
    create: XOR<ProjectCreateWithoutExternalLinksInput, ProjectUncheckedCreateWithoutExternalLinksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutExternalLinksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutExternalLinksInput, ProjectUncheckedUpdateWithoutExternalLinksInput>
  }

  export type ProjectUpdateWithoutExternalLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutExternalLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutTechStacksInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTechStacksInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTechStacksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTechStacksInput, ProjectUncheckedCreateWithoutTechStacksInput>
  }

  export type ProjectRoleCreateWithoutTechStacksInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: teamMemberCreateNestedManyWithoutProjectRoleInput
    project: ProjectCreateNestedOneWithoutProjectRolesInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUncheckedCreateWithoutTechStacksInput = {
    id?: string
    projectId: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: teamMemberUncheckedCreateNestedManyWithoutProjectRoleInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleCreateOrConnectWithoutTechStacksInput = {
    where: ProjectRoleWhereUniqueInput
    create: XOR<ProjectRoleCreateWithoutTechStacksInput, ProjectRoleUncheckedCreateWithoutTechStacksInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutTechStacksInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutTechStacksInput, ProjectUncheckedUpdateWithoutTechStacksInput>
    create: XOR<ProjectCreateWithoutTechStacksInput, ProjectUncheckedCreateWithoutTechStacksInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutTechStacksInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutTechStacksInput, ProjectUncheckedUpdateWithoutTechStacksInput>
  }

  export type ProjectUpdateManyWithWhereWithoutTechStacksInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutTechStacksInput>
  }

  export type ProjectRoleUpsertWithWhereUniqueWithoutTechStacksInput = {
    where: ProjectRoleWhereUniqueInput
    update: XOR<ProjectRoleUpdateWithoutTechStacksInput, ProjectRoleUncheckedUpdateWithoutTechStacksInput>
    create: XOR<ProjectRoleCreateWithoutTechStacksInput, ProjectRoleUncheckedCreateWithoutTechStacksInput>
  }

  export type ProjectRoleUpdateWithWhereUniqueWithoutTechStacksInput = {
    where: ProjectRoleWhereUniqueInput
    data: XOR<ProjectRoleUpdateWithoutTechStacksInput, ProjectRoleUncheckedUpdateWithoutTechStacksInput>
  }

  export type ProjectRoleUpdateManyWithWhereWithoutTechStacksInput = {
    where: ProjectRoleScalarWhereInput
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyWithoutTechStacksInput>
  }

  export type ProjectRoleCreateWithoutTeamMemberInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackCreateNestedManyWithoutProjectRolesInput
    project: ProjectCreateNestedOneWithoutProjectRolesInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUncheckedCreateWithoutTeamMemberInput = {
    id?: string
    projectId: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectRolesInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleCreateOrConnectWithoutTeamMemberInput = {
    where: ProjectRoleWhereUniqueInput
    create: XOR<ProjectRoleCreateWithoutTeamMemberInput, ProjectRoleUncheckedCreateWithoutTeamMemberInput>
  }

  export type ProjectCreateWithoutProjectMembersInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectMembersInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectRoleUpsertWithWhereUniqueWithoutTeamMemberInput = {
    where: ProjectRoleWhereUniqueInput
    update: XOR<ProjectRoleUpdateWithoutTeamMemberInput, ProjectRoleUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<ProjectRoleCreateWithoutTeamMemberInput, ProjectRoleUncheckedCreateWithoutTeamMemberInput>
  }

  export type ProjectRoleUpdateWithWhereUniqueWithoutTeamMemberInput = {
    where: ProjectRoleWhereUniqueInput
    data: XOR<ProjectRoleUpdateWithoutTeamMemberInput, ProjectRoleUncheckedUpdateWithoutTeamMemberInput>
  }

  export type ProjectRoleUpdateManyWithWhereWithoutTeamMemberInput = {
    where: ProjectRoleScalarWhereInput
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyWithoutTeamMemberInput>
  }

  export type ProjectUpsertWithoutProjectMembersInput = {
    update: XOR<ProjectUpdateWithoutProjectMembersInput, ProjectUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<ProjectCreateWithoutProjectMembersInput, ProjectUncheckedCreateWithoutProjectMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectMembersInput, ProjectUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TechStackCreateWithoutProjectRolesInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    projects?: ProjectCreateNestedManyWithoutTechStacksInput
  }

  export type TechStackUncheckedCreateWithoutProjectRolesInput = {
    id?: string
    name: string
    iconUrl: string
    type: $Enums.TechStackType
    projects?: ProjectUncheckedCreateNestedManyWithoutTechStacksInput
  }

  export type TechStackCreateOrConnectWithoutProjectRolesInput = {
    where: TechStackWhereUniqueInput
    create: XOR<TechStackCreateWithoutProjectRolesInput, TechStackUncheckedCreateWithoutProjectRolesInput>
  }

  export type teamMemberCreateWithoutProjectRoleInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectMembersInput
  }

  export type teamMemberUncheckedCreateWithoutProjectRoleInput = {
    id?: string
    userId: string
    projectId: string
    joinedAt?: Date | string
  }

  export type teamMemberCreateOrConnectWithoutProjectRoleInput = {
    where: teamMemberWhereUniqueInput
    create: XOR<teamMemberCreateWithoutProjectRoleInput, teamMemberUncheckedCreateWithoutProjectRoleInput>
  }

  export type ProjectCreateWithoutProjectRolesInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectRolesInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectRolesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectRolesInput, ProjectUncheckedCreateWithoutProjectRolesInput>
  }

  export type ProjectRoleApplicationCreateWithoutProjectRoleInput = {
    id?: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutProjectRoleApplicationInput
    project: ProjectCreateNestedOneWithoutProjectRoleApplicationInput
  }

  export type ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput = {
    id?: string
    projectId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type ProjectRoleApplicationCreateOrConnectWithoutProjectRoleInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    create: XOR<ProjectRoleApplicationCreateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput>
  }

  export type ProjectRoleApplicationCreateManyProjectRoleInputEnvelope = {
    data: ProjectRoleApplicationCreateManyProjectRoleInput | ProjectRoleApplicationCreateManyProjectRoleInput[]
    skipDuplicates?: boolean
  }

  export type TechStackUpsertWithWhereUniqueWithoutProjectRolesInput = {
    where: TechStackWhereUniqueInput
    update: XOR<TechStackUpdateWithoutProjectRolesInput, TechStackUncheckedUpdateWithoutProjectRolesInput>
    create: XOR<TechStackCreateWithoutProjectRolesInput, TechStackUncheckedCreateWithoutProjectRolesInput>
  }

  export type TechStackUpdateWithWhereUniqueWithoutProjectRolesInput = {
    where: TechStackWhereUniqueInput
    data: XOR<TechStackUpdateWithoutProjectRolesInput, TechStackUncheckedUpdateWithoutProjectRolesInput>
  }

  export type TechStackUpdateManyWithWhereWithoutProjectRolesInput = {
    where: TechStackScalarWhereInput
    data: XOR<TechStackUpdateManyMutationInput, TechStackUncheckedUpdateManyWithoutProjectRolesInput>
  }

  export type teamMemberUpsertWithWhereUniqueWithoutProjectRoleInput = {
    where: teamMemberWhereUniqueInput
    update: XOR<teamMemberUpdateWithoutProjectRoleInput, teamMemberUncheckedUpdateWithoutProjectRoleInput>
    create: XOR<teamMemberCreateWithoutProjectRoleInput, teamMemberUncheckedCreateWithoutProjectRoleInput>
  }

  export type teamMemberUpdateWithWhereUniqueWithoutProjectRoleInput = {
    where: teamMemberWhereUniqueInput
    data: XOR<teamMemberUpdateWithoutProjectRoleInput, teamMemberUncheckedUpdateWithoutProjectRoleInput>
  }

  export type teamMemberUpdateManyWithWhereWithoutProjectRoleInput = {
    where: teamMemberScalarWhereInput
    data: XOR<teamMemberUpdateManyMutationInput, teamMemberUncheckedUpdateManyWithoutProjectRoleInput>
  }

  export type ProjectUpsertWithoutProjectRolesInput = {
    update: XOR<ProjectUpdateWithoutProjectRolesInput, ProjectUncheckedUpdateWithoutProjectRolesInput>
    create: XOR<ProjectCreateWithoutProjectRolesInput, ProjectUncheckedCreateWithoutProjectRolesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectRolesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectRolesInput, ProjectUncheckedUpdateWithoutProjectRolesInput>
  }

  export type ProjectUpdateWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectRoleApplicationUpsertWithWhereUniqueWithoutProjectRoleInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    update: XOR<ProjectRoleApplicationUpdateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedUpdateWithoutProjectRoleInput>
    create: XOR<ProjectRoleApplicationCreateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedCreateWithoutProjectRoleInput>
  }

  export type ProjectRoleApplicationUpdateWithWhereUniqueWithoutProjectRoleInput = {
    where: ProjectRoleApplicationWhereUniqueInput
    data: XOR<ProjectRoleApplicationUpdateWithoutProjectRoleInput, ProjectRoleApplicationUncheckedUpdateWithoutProjectRoleInput>
  }

  export type ProjectRoleApplicationUpdateManyWithWhereWithoutProjectRoleInput = {
    where: ProjectRoleApplicationScalarWhereInput
    data: XOR<ProjectRoleApplicationUpdateManyMutationInput, ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleInput>
  }

  export type ProjectRoleCreateWithoutProjectRoleApplicationInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackCreateNestedManyWithoutProjectRolesInput
    teamMember?: teamMemberCreateNestedManyWithoutProjectRoleInput
    project: ProjectCreateNestedOneWithoutProjectRolesInput
  }

  export type ProjectRoleUncheckedCreateWithoutProjectRoleApplicationInput = {
    id?: string
    projectId: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectRolesInput
    teamMember?: teamMemberUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleCreateOrConnectWithoutProjectRoleApplicationInput = {
    where: ProjectRoleWhereUniqueInput
    create: XOR<ProjectRoleCreateWithoutProjectRoleApplicationInput, ProjectRoleUncheckedCreateWithoutProjectRoleApplicationInput>
  }

  export type ProfileCreateWithoutProjectRoleApplicationInput = {
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProfileInput
    socialLinks?: UserSocialLinkCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutProjectRoleApplicationInput = {
    userId: string
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    socialLinks?: UserSocialLinkUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutProjectRoleApplicationInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutProjectRoleApplicationInput, ProfileUncheckedCreateWithoutProjectRoleApplicationInput>
  }

  export type ProjectCreateWithoutProjectRoleApplicationInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectRoleApplicationInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectRoleApplicationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectRoleApplicationInput, ProjectUncheckedCreateWithoutProjectRoleApplicationInput>
  }

  export type ProjectRoleUpsertWithoutProjectRoleApplicationInput = {
    update: XOR<ProjectRoleUpdateWithoutProjectRoleApplicationInput, ProjectRoleUncheckedUpdateWithoutProjectRoleApplicationInput>
    create: XOR<ProjectRoleCreateWithoutProjectRoleApplicationInput, ProjectRoleUncheckedCreateWithoutProjectRoleApplicationInput>
    where?: ProjectRoleWhereInput
  }

  export type ProjectRoleUpdateToOneWithWhereWithoutProjectRoleApplicationInput = {
    where?: ProjectRoleWhereInput
    data: XOR<ProjectRoleUpdateWithoutProjectRoleApplicationInput, ProjectRoleUncheckedUpdateWithoutProjectRoleApplicationInput>
  }

  export type ProjectRoleUpdateWithoutProjectRoleApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUpdateManyWithoutProjectRolesNestedInput
    teamMember?: teamMemberUpdateManyWithoutProjectRoleNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRolesNestedInput
  }

  export type ProjectRoleUncheckedUpdateWithoutProjectRoleApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectRolesNestedInput
    teamMember?: teamMemberUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProfileUpsertWithoutProjectRoleApplicationInput = {
    update: XOR<ProfileUpdateWithoutProjectRoleApplicationInput, ProfileUncheckedUpdateWithoutProjectRoleApplicationInput>
    create: XOR<ProfileCreateWithoutProjectRoleApplicationInput, ProfileUncheckedCreateWithoutProjectRoleApplicationInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutProjectRoleApplicationInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutProjectRoleApplicationInput, ProfileUncheckedUpdateWithoutProjectRoleApplicationInput>
  }

  export type ProfileUpdateWithoutProjectRoleApplicationInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProfileNestedInput
    socialLinks?: UserSocialLinkUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutProjectRoleApplicationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserSocialLinkUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProjectUpsertWithoutProjectRoleApplicationInput = {
    update: XOR<ProjectUpdateWithoutProjectRoleApplicationInput, ProjectUncheckedUpdateWithoutProjectRoleApplicationInput>
    create: XOR<ProjectCreateWithoutProjectRoleApplicationInput, ProjectUncheckedCreateWithoutProjectRoleApplicationInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectRoleApplicationInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectRoleApplicationInput, ProjectUncheckedUpdateWithoutProjectRoleApplicationInput>
  }

  export type ProjectUpdateWithoutProjectRoleApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectRoleApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProfileCreateWithoutSocialLinksInput = {
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutSocialLinksInput = {
    userId: string
    name: string
    login: string
    avatarUrl?: string | null
    location?: string | null
    company?: string | null
    bio?: string | null
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutSocialLinksInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSocialLinksInput, ProfileUncheckedCreateWithoutSocialLinksInput>
  }

  export type ProfileUpsertWithoutSocialLinksInput = {
    update: XOR<ProfileUpdateWithoutSocialLinksInput, ProfileUncheckedUpdateWithoutSocialLinksInput>
    create: XOR<ProfileCreateWithoutSocialLinksInput, ProfileUncheckedCreateWithoutSocialLinksInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSocialLinksInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSocialLinksInput, ProfileUncheckedUpdateWithoutSocialLinksInput>
  }

  export type ProfileUpdateWithoutSocialLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSocialLinksInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProjectCreateWithoutCategoriesInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCategoriesInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCategoriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCategoriesInput, ProjectUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCategoriesInput, ProjectUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ProjectCreateWithoutKeyFeaturesInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    projectGoals?: ProjectGoalCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutKeyFeaturesInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    projectGoals?: ProjectGoalUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutKeyFeaturesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutKeyFeaturesInput, ProjectUncheckedCreateWithoutKeyFeaturesInput>
  }

  export type ProjectUpsertWithoutKeyFeaturesInput = {
    update: XOR<ProjectUpdateWithoutKeyFeaturesInput, ProjectUncheckedUpdateWithoutKeyFeaturesInput>
    create: XOR<ProjectCreateWithoutKeyFeaturesInput, ProjectUncheckedCreateWithoutKeyFeaturesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutKeyFeaturesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutKeyFeaturesInput, ProjectUncheckedUpdateWithoutKeyFeaturesInput>
  }

  export type ProjectUpdateWithoutKeyFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutKeyFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutProjectGoalsInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    externalLinks?: ProjectExternalLinkCreateNestedManyWithoutProjectInput
    techStacks?: TechStackCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationCreateNestedManyWithoutProjectInput
    profile?: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectGoalsInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    image?: string | null
    externalLinks?: ProjectExternalLinkUncheckedCreateNestedManyWithoutProjectInput
    techStacks?: TechStackUncheckedCreateNestedManyWithoutProjectsInput
    projectMembers?: teamMemberUncheckedCreateNestedManyWithoutProjectInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectsInput
    keyFeatures?: KeyFeatureUncheckedCreateNestedManyWithoutProjectInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectGoalsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectGoalsInput, ProjectUncheckedCreateWithoutProjectGoalsInput>
  }

  export type ProjectUpsertWithoutProjectGoalsInput = {
    update: XOR<ProjectUpdateWithoutProjectGoalsInput, ProjectUncheckedUpdateWithoutProjectGoalsInput>
    create: XOR<ProjectCreateWithoutProjectGoalsInput, ProjectUncheckedCreateWithoutProjectGoalsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectGoalsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectGoalsInput, ProjectUncheckedUpdateWithoutProjectGoalsInput>
  }

  export type ProjectUpdateWithoutProjectGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserSocialLinkCreateManyProfileInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
  }

  export type ProjectCreateManyProfileInput = {
    id?: string
    ownerId: string
    title: string
    description: string
    shortDescription: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
  }

  export type ProjectRoleApplicationCreateManyProfileInput = {
    id?: string
    projectId: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSocialLinkUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialLinkUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialLinkUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectRoleApplicationUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
  }

  export type ProjectRoleApplicationUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectRoleId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleApplicationUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectRoleId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectExternalLinkCreateManyProjectInput = {
    id?: string
    type: string
    url: string
  }

  export type teamMemberCreateManyProjectInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type ProjectRoleCreateManyProjectInput = {
    id?: string
    title: string
    description: string
    isFilled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyFeatureCreateManyProjectInput = {
    id?: string
    feature: string
  }

  export type ProjectGoalCreateManyProjectInput = {
    id?: string
    goal: string
  }

  export type ProjectRoleApplicationCreateManyProjectInput = {
    id?: string
    projectRoleId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type ProjectExternalLinkUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectExternalLinkUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectExternalLinkUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type TechStackUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
    projectRoles?: ProjectRoleUpdateManyWithoutTechStacksNestedInput
  }

  export type TechStackUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutTechStacksNestedInput
  }

  export type TechStackUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
  }

  export type teamMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUpdateManyWithoutTeamMemberNestedInput
  }

  export type teamMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUncheckedUpdateManyWithoutTeamMemberNestedInput
  }

  export type teamMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUpdateManyWithoutProjectRolesNestedInput
    teamMember?: teamMemberUpdateManyWithoutProjectRoleNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectRolesNestedInput
    teamMember?: teamMemberUncheckedUpdateManyWithoutProjectRoleNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFeatureUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFeatureUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFeatureUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectGoalUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectGoalUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectGoalUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectRoleApplicationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectRole?: ProjectRoleUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
    profile?: ProfileUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
  }

  export type ProjectRoleApplicationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectRoleApplicationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutTechStacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTechStacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectsNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutTechStacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectRoleUpdateWithoutTechStacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: teamMemberUpdateManyWithoutProjectRoleNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRolesNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateWithoutTechStacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: teamMemberUncheckedUpdateManyWithoutProjectRoleNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateManyWithoutTechStacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUpdateManyWithoutProjectRolesNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRolesNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectRolesNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateManyWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isFilled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleApplicationCreateManyProjectRoleInput = {
    id?: string
    projectId: string
    projectRoleTitle: string
    status: string
    motivationLetter?: string | null
    selectedKeyFeatures?: ProjectRoleApplicationCreateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationCreateselectedProjectGoalsInput | string[]
    rejectionReason?: string | null
    appliedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type TechStackUpdateWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
    projects?: ProjectUpdateManyWithoutTechStacksNestedInput
  }

  export type TechStackUncheckedUpdateWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
    projects?: ProjectUncheckedUpdateManyWithoutTechStacksNestedInput
  }

  export type TechStackUncheckedUpdateManyWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumTechStackTypeFieldUpdateOperationsInput | $Enums.TechStackType
  }

  export type teamMemberUpdateWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type teamMemberUncheckedUpdateWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamMemberUncheckedUpdateManyWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleApplicationUpdateWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectRoleApplicationNestedInput
  }

  export type ProjectRoleApplicationUncheckedUpdateWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectRoleApplicationUncheckedUpdateManyWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectRoleTitle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    motivationLetter?: NullableStringFieldUpdateOperationsInput | string | null
    selectedKeyFeatures?: ProjectRoleApplicationUpdateselectedKeyFeaturesInput | string[]
    selectedProjectGoals?: ProjectRoleApplicationUpdateselectedProjectGoalsInput | string[]
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutProjectNestedInput
    keyFeatures?: KeyFeatureUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUpdateManyWithoutProjectNestedInput
    profile?: ProfileUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    externalLinks?: ProjectExternalLinkUncheckedUpdateManyWithoutProjectNestedInput
    techStacks?: TechStackUncheckedUpdateManyWithoutProjectsNestedInput
    projectMembers?: teamMemberUncheckedUpdateManyWithoutProjectNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutProjectNestedInput
    keyFeatures?: KeyFeatureUncheckedUpdateManyWithoutProjectNestedInput
    projectGoals?: ProjectGoalUncheckedUpdateManyWithoutProjectNestedInput
    projectRoleApplication?: ProjectRoleApplicationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}